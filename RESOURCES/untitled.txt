from .application_entry import main
"""
application_entry.py: Project entry point
"""

import os
import sys
import time
import logging
import threading

from pathlib import Path

from . import constants

from .wx_gui import gui_entry

from .detections import (
    device_probe,
    os_probe
)
from .support import (
    utilities,
    defaults,
    arguments,
    reroute_payloads,
    commit_info,
    logging_handler,
    analytics_handler
)


class OpenCoreLegacyPatcher:
    """
    Initial entry point for starting OpenCore Legacy Patcher
    """

    def __init__(self) -> None:
        self.constants: constants.Constants = constants.Constants()

        logging_handler.InitializeLoggingSupport(self.constants)

        self._generate_base_data()

        if utilities.check_cli_args() is None:
            gui_entry.EntryPoint(self.constants).start()


    def _fix_cwd(self) -> None:
        """
        In some extreme scenarios, our current working directory may disappear
        """
        _test_dir = None
        try:
            _test_dir = Path.cwd()
            logging.info(f"Current working directory: {_test_dir}")
        except FileNotFoundError:
            _test_dir = Path(__file__).parent.parent.resolve()
            os.chdir(_test_dir)
            logging.warning(f"Current working directory was invalid, switched to: {_test_dir}")


    def _generate_base_data(self) -> None:
        """
        Generate base data required for the patcher to run
        """

        self.constants.wxpython_variant = True

        # Ensure we live after parent process dies (ie. LaunchAgent)
        os.setpgrp()

        # Generate OS data
        os_data = os_probe.OSProbe()
        self.constants.detected_os = os_data.detect_kernel_major()
        self.constants.detected_os_minor = os_data.detect_kernel_minor()
        self.constants.detected_os_build = os_data.detect_os_build()
        self.constants.detected_os_version = os_data.detect_os_version()

        # Generate computer data
        self.constants.computer = device_probe.Computer.probe()
        self.computer = self.constants.computer
        self.constants.booted_oc_disk = utilities.find_disk_off_uuid(utilities.clean_device_path(self.computer.opencore_path))
        if self.constants.computer.firmware_vendor:
            if self.constants.computer.firmware_vendor != "Apple":
                self.constants.host_is_hackintosh = True

        # Generate environment data
        self.constants.recovery_status = utilities.check_recovery()
        utilities.disable_cls()
        self._fix_cwd()

        # Generate binary data
        launcher_script = None
        launcher_binary = sys.executable
        if "python" in launcher_binary:
            # We're running from source
            launcher_script =  __file__
            if "main.py" in launcher_script:
                launcher_script = launcher_script.replace("/resources/main.py", "/OpenCore-Patcher-GUI.command")
        self.constants.launcher_binary = launcher_binary
        self.constants.launcher_script = launcher_script

        # Initialize working directory
        self.constants.unpack_thread = threading.Thread(target=reroute_payloads.RoutePayloadDiskImage, args=(self.constants,))
        self.constants.unpack_thread.start()

        # Generate commit info
        self.constants.commit_info = commit_info.ParseCommitInfo(self.constants.launcher_binary).generate_commit_info()
        if self.constants.commit_info[0] not in ["Running from source", "Built from source"]:
            # Now that we have commit info, update nightly link
            branch = self.constants.commit_info[0]
            branch = branch.replace("refs/heads/", "")
            self.constants.installer_pkg_url_nightly = self.constants.installer_pkg_url_nightly.replace("main", branch)

        # Generate defaults
        defaults.GenerateDefaults(self.computer.real_model, True, self.constants)
        threading.Thread(target=analytics_handler.Analytics(self.constants).send_analytics).start()

        if utilities.check_cli_args() is None:
            self.constants.cli_mode = False
            return

        logging.info("Detected arguments, switching to CLI mode")
        self.constants.gui_mode = True  # Assumes no user interaction is required

        ignore_args = ["--auto_patch", "--gui_patch", "--gui_unpatch", "--update_installed"]
        if not any(x in sys.argv for x in ignore_args):
            self.constants.current_path = Path.cwd()
        ignore_args = ignore_args.pop(0)

        if not any(x in sys.argv for x in ignore_args):
            while self.constants.unpack_thread.is_alive():
                time.sleep(self.constants.thread_sleep_interval)

        arguments.arguments(self.constants)

def main():
    """
    Main entry point
    """
    OpenCoreLegacyPatcher()

"""
constants.py: Defines versioning, file paths and other settings for the patcher
"""

from pathlib   import Path
from typing    import Optional
from packaging import version

from .datasets import os_data
from .detections import device_probe


class Constants:
    def __init__(self) -> None:
        # Patcher Versioning
        self.patcher_version:                 str = "2.4.0"  # OpenCore-Legacy-Patcher
        self.patcher_support_pkg_version:     str = "1.9.5"  # PatcherSupportPkg
        self.copyright_date:                  str = "Copyright Â© 2020-2025 Dortania"
        self.patcher_name:                    str = "OpenCore Legacy Patcher"

        # URLs
        self.url_patcher_support_pkg:         str = "https://github.com/dortania/PatcherSupportPkg/releases/download/"
        self.discord_link:                    str = "https://discord.gg/rqdPgH8xSN"
        self.guide_link:                      str = "https://dortania.github.io/OpenCore-Legacy-Patcher/"
        self.repo_link:                       str = "https://github.com/dortania/OpenCore-Legacy-Patcher"
        self.installer_pkg_url:               str = f"{self.repo_link}/releases/download/{self.patcher_version}/AutoPkg-Assets.pkg"
        self.installer_pkg_url_nightly:       str = "http://nightly.link/dortania/OpenCore-Legacy-Patcher/workflows/build-app-wxpython/main/AutoPkg-Assets.pkg.zip"

        # OpenCore Versioning
        # https://github.com/acidanthera/OpenCorePkg
        self.opencore_version: str = "1.0.4"

        # Kext Versioning
        ## Acidanthera
        ## https://github.com/acidanthera
        self.lilu_version:               str = "1.7.0"  #      Lilu
        self.whatevergreen_version:      str = "1.6.9"  #      WhateverGreen
        self.whatevergreen_navi_version: str = "1.6.9-Navi"  # WhateverGreen (Navi Patch)
        self.airportbcrmfixup_version:   str = "2.1.9"  #      AirPortBrcmFixup
        self.nvmefix_version:            str = "1.1.2"  #      NVMeFix
        self.applealc_version:           str = "1.6.3"  #      AppleALC
        self.restrictevents_version:     str = "1.1.5"  #      RestrictEvents
        self.featureunlock_version:      str = "1.1.7"  #      FeatureUnlock
        self.debugenhancer_version:      str = "1.1.0"  #      DebugEnhancer
        self.cpufriend_version:          str = "1.2.9"  #      CPUFriend
        self.bluetool_version:           str = "2.6.9"  #      BlueToolFixup (BrcmPatchRAM)
        self.cslvfixup_version:          str = "2.6.1"  #      CSLVFixup
        self.autopkg_version:            str = "1.0.4"  #      AutoPkgInstaller
        self.cryptexfixup_version:       str = "1.0.4"  #      CryptexFixup

        ## Apple
        ## https://www.apple.com
        self.marvel_version:        str = "1.0.1"  #  MarvelYukonEthernet
        self.nforce_version:        str = "1.0.1"  #  nForceEthernet
        self.piixata_version:       str = "1.0.1"  #  AppleIntelPIIXATA
        self.fw_kext:               str = "1.0.1"  #  IOFireWireFamily
        self.apple_trackpad:        str = "1.0.1"  #  AppleUSBTrackpad
        self.apple_isight_version:  str = "1.0.0"  #  AppleiSight
        self.apple_raid_version:    str = "1.0.0"  #  AppleRAIDCard
        self.apfs_zlib_version:     str = "12.3.1"  # NoAVXFSCompressionTypeZlib
        self.apfs_zlib_v2_version:  str = "12.6"  #   NoAVXFSCompressionTypeZlib (patched with AVXpel)
        self.multitouch_version:    str = "1.0.0"  #  AppleUSBMultitouch
        self.topcase_version:       str = "1.0.0"  #  AppleUSBTopCase
        self.topcase_inj_version:   str = "1.0.0"  #  AppleTopCaseInjector
        self.intel_82574l_version:  str = "1.0.0"  #  Intel82574L
        self.intel_8254x_version:   str = "1.0.0"  #  AppleIntel8254XEthernet
        self.apple_usb_11_injector: str = "1.0.0"  #  AppleUSBUHCI/OHCI
        self.aicpupm_version:       str = "1.0.0"  #  AppleIntelCPUPowerManagement/Client
        self.s3x_nvme_version:      str = "1.0.0"  #  IONVMeFamily (14.0 Beta 1, S1X and S3X classes)
        self.apple_camera_version:  str = "1.0.0"  #  AppleCameraInterface (14.0 Beta 1)
        self.t1_sse_version:        str = "1.1.0"  #  AppleSSE      (13.6 - T1 support)
        self.t1_key_store_version:  str = "1.1.0"  #  AppleKeyStore (13.6 - T1 support)
        self.t1_credential_version: str = "1.0.0"  #  AppleCredentialManager (13.6 - T1 support)
        self.t1_corecrypto_version: str = "1.0.1"  #  corecrypto    (13.6 - T1 support)
        self.apple_spi_version:     str = "1.0.0"  #  AppleHSSPISupport   (14.4 Beta 1)
        self.apple_spi_hid_version: str = "1.0.0"  #  AppleHSSPIHIDDriver (14.4 Beta 1)
        self.kernel_relay_version:  str = "1.0.0"  #  KernelRelayHost (15.0 Beta 3)

        ## Apple - Dortania Modified
        self.bcm570_version:           str = "1.0.2"  # CatalinaBCM5701Ethernet
        self.i210_version:             str = "1.0.0"  # CatalinaIntelI210Ethernet
        self.corecaptureelcap_version: str = "1.0.2"  # corecaptureElCap
        self.io80211elcap_version:     str = "2.0.1"  # IO80211ElCap
        self.io80211legacy_version:    str = "1.0.0"  # IO80211FamilyLegacy (Ventura)
        self.ioskywalk_version:        str = "1.2.0"  # IOSkywalkFamily (Ventura)
        self.bigsursdxc_version:       str = "1.0.0"  # BigSurSDXC
        self.monterey_ahci_version:    str = "1.0.0"  # CatalinaAHCI

        ## Apple - Jazzzny Modified
        self.aquantia_version: str = "1.1.0"  # AppleEthernetAbuantiaAqtion

        ## Dortania
        ## https://github.com/dortania
        self.backlight_injector_version:     str = "1.1.0"  # BacklightInjector
        self.backlight_injectorA_version:    str = "1.0.0"  # BacklightInjector (iMac9,1)
        self.smcspoof_version:               str = "1.0.0"  # SMC-Spoof
        self.mce_version:                    str = "1.0.0"  # AppleMCEReporterDisabler
        self.btspoof_version:                str = "1.0.0"  # Bluetooth-Spoof
        self.aspp_override_version:          str = "1.0.1"  # ACPI_SMC_PlatformPlugin Override
        self.ecm_override_version:           str = "1.0.0"  # AppleUSBECM Override
        self.rsrhelper_version:              str = "1.0.2"  # RSRHelper
        self.amfipass_version:               str = "1.4.1"  # AMFIPass
        self.amfipass_compatibility_version: str = "1.2.1"  # Minimum AMFIPass version required

        ## Syncretic
        ## https://forums.macrumors.com/members/syncretic.1173816/
        ## https://github.com/reenigneorcim/latebloom
        self.mousse_version:     str = "0.95-Dortania"  # MouSSE
        self.telemetrap_version: str = "1.0.0"  #         telemetrap

        ## cdf
        ## https://github.com/cdf/Innie
        self.innie_version: str = "1.3.1"  # Innie

        ## arter97
        ## https://github.com/arter97/SimpleMSR/
        self.simplemsr_version: str = "1.0.0"  # SimpleMSR

        ## blackgate
        ## https://github.com/blackgate/AMDGPUWakeHandler
        self.gpu_wake_version: str = "1.0.0"

        ## flagersgit
        ## https://github.com/flagersgit/KDKlessWorkaround
        self.kdkless_version: str = "1.0.0"

        ## Jazzzny
        self.legacy_keyboard: str = "1.0.0"  # LegacyKeyboardInjector - Jazzzny

        # Get resource path
        self.current_path:  Path = Path(__file__).parent.parent.resolve()
        self.original_path: Path = Path(__file__).parent.parent.resolve()
        self.payload_path:  Path = self.current_path / Path("payloads")


        # Patcher Settings
        ## Internal settings
        self.allow_oc_everywhere:       bool = False  # Set whether Patcher can be run on unsupported Macs
        self.gui_mode:                  bool = False  # Determine whether running in a GUI or TUI
        self.cli_mode:                  bool = True  #  Determine if running in CLI mode
        self.validate:                  bool = False  # Enable validation testing for CI
        self.recovery_status:           bool = False  # Detect if booted into RecoveryOS
        self.ignore_updates:            bool = False  # Ignore OCLP updates
        self.wxpython_variant:          bool = False  # Determine if using wxPython variant
        self.has_checked_updates:       bool = False  # Determine if check for updates has been run
        self.root_patcher_succeeded:    bool = False  # Determine if root patcher succeeded
        self.start_build_install:       bool = False  # Determine if build install should be started
        self.host_is_non_metal:         bool = False  # Determine if host is non-metal (ie. enable UI hacks)
        self.needs_to_open_preferences: bool = False  # Determine if preferences need to be opened
        self.host_is_hackintosh:        bool = False  # Determine if host is Hackintosh
        self.should_nuke_kdks:          bool = True  #  Determine if KDKs should be nuked if unused in /L*/D*/KDKs
        self.launcher_binary:            str = None  #  Determine launch binary path (ie. Python vs PyInstaller)
        self.launcher_script:            str = None  #  Determine launch file path   (None if PyInstaller)
        self.booted_oc_disk:             str = None  #  Determine current disk OCLP booted from
        self.unpack_thread                   = None  #  Determine if unpack thread finished (threading.Thread)
        self.update_stage:               int = 0  #     Determine update stage (see gui_support.py)
        self.log_filepath:              Path = None  #  Path to log file
        self.thread_sleep_interval:    float = 0.01  #  Sleep interval between UI updates (seconds) - balance between UI responsiveness and CPU usage

        self.commit_info: tuple = (None, None, None)  # Commit info (Branch, Commit Date, Commit URL)

        ## Hardware
        self.computer: device_probe.Computer = None  # type: ignore
        self.custom_model:     Optional[str] = None

        ## OpenCore Settings
        self.opencore_debug: bool = False # Enable OpenCore debug
        self.boot_efi:       bool = False # Use EFI/BOOT/BOOTx64.efi vs boot.efi bootstrap
        self.showpicker:     bool = True  # Show or Hide OpenCore's Boot Picker
        self.nvram_write:    bool = True  # Write to hardware NVRAM
        self.oc_timeout:      int = 5  #    Set OpenCore timeout

        ## Kext Settings
        self.kext_debug:  bool = False  # Enables Lilu debug and DebugEnhancer
        self.kext_variant: str = "RELEASE"

        ## NVRAM Settings
        self.verbose_debug: bool = False  # -v

        ## SMBIOS Settings
        self.serial_settings:     str  = "None"  #    Set SMBIOS level used
        self.override_smbios:     str  = "Default"  # Set SMBIOS model used
        self.allow_native_spoofs: bool = False  #     Allow native models to receive spoofs

        ### Serial Number Overrides
        self.custom_serial_number:       str = ""  # Set SMBIOS serial number
        self.custom_board_serial_number: str = ""  # Set SMBIOS board serial number

        ## FeatureUnlock Settings
        self.fu_status:    bool = False  # Enable FeatureUnlock
        self.fu_arguments: str  = None   # Set FeatureUnlock arguments

        ## Security Settings
        self.sip_status:     bool = True  #  System Integrity Protection
        self.secure_status:  bool = False  # Secure Boot Model
        self.vault:          bool = False  # EFI Vault
        self.disable_cs_lv:  bool = False  # Disable Library validation
        self.disable_amfi:   bool = False  # Disable AMFI

        ## OS Settings
        self.os_support:        float = 12.0
        self.detected_os:         int = 0  #  Major Kernel Version
        self.detected_os_minor:   int = 0  #  Minor Kernel Version
        self.detected_os_build:   str = ""  # OS Build
        self.detected_os_version: str = ""  # OS Version

        ## Boot Volume Settings
        self.firewire_boot: bool = False  # Allow macOS FireWire Boot (kernel)
        self.nvme_boot:     bool = False  # Allow UEFI NVMe Boot
        self.xhci_boot:     bool = False  # Allow UEFI XHCI Boot

        ## Graphics Settings
        self.allow_ts2_accel:             bool = True  #  Set TeraScale 2 Acceleration support
        self.drm_support:                 bool = False  # Set iMac14,x DRM support
        self.force_nv_web:                bool = False  # Force Nvidia Web Drivers on Tesla and Kepler
        self.force_output_support:        bool = False  # Force Output support for Mac Pros with PC VBIOS
        self.amd_gop_injection:           bool = False  # Set GOP Injection support
        self.nvidia_kepler_gop_injection: bool = False  # Set Kepler GOP Injection support

        ### MXM GPU Support
        self.metal_build: bool = False  # Set MXM Build support
        self.imac_vendor: str = "None"  # Set MXM GPU vendor
        self.imac_model:  str = "" #      Set MXM GPU model

        ## Miscellaneous build settings
        self.disallow_cpufriend:     bool = False  # Disable CPUFriend
        self.enable_wake_on_wlan:    bool = False  # Allow Wake on WLAN for modern Broadcom
        self.disable_tb:             bool = False  # Disable Thunderbolt Controller
        self.dGPU_switch:            bool = False  # Set Display GPU Switching for Windows
        self.force_surplus:          bool = False  # Force SurPlus patch in newer OSes
        self.force_latest_psp:       bool = False  # Force latest PatcherSupportPkg
        self.disable_fw_throttle:    bool = False  # Disable MSR Power Control and XCPM
        self.software_demux:         bool = False  # Enable Software Demux patch set
        self.force_vmm:              bool = False  # Force VMM patch
        self.disable_connectdrivers: bool = False  # Disable ConnectDrivers (hibernation)
        self.set_vmm_cpuid:          bool = False  # Set VMM bit inside CPUID
        self.disable_mediaanalysisd: bool = False  # Set mediaanalysisd to spawn
        self.force_quad_thread:      bool = False #  Force quad thread mode (cpus=4)
        self.set_alc_usage:          bool = True  #  Set AppleALC usage
        self.allow_3rd_party_drives: bool = True  #  Allow ThridPartyDrives quirk
        self.allow_nvme_fixing:      bool = True  #  Allow NVMe Kernel Space Patches
        self.apfs_trim_timeout:      bool = True  #  Set APFS Trim timeout
        self.custom_sip_value:        int = None  #  Set custom SIP value

        ## Non-Metal OS support
        self.legacy_accel_support = [
            os_data.os_data.big_sur,
            os_data.os_data.monterey,
            os_data.os_data.ventura,
            os_data.os_data.sonoma,
            os_data.os_data.sequoia,
        ]

    @property
    def special_build(self):
        """
        Special builds are used for testing. They do not get updates through the updater
        """

        try:
            version.parse(self.patcher_version)
            return False
        except version.InvalidVersion:
            return True

    # Payload Location

    # Support Disk Images
    @property
    def payload_path_dmg(self):
        return self.original_path / Path("payloads.dmg")

    @property
    def payload_local_binaries_root_path_dmg(self):
        return self.original_path / Path("Universal-Binaries.dmg")

    @property
    def overlay_psp_path_dmg(self):
        return self.original_path / Path("DortaniaInternalResources.dmg")

    # OpenCore
    @property
    def opencore_zip_source(self):
        return self.payload_path / Path(f"OpenCore/OpenCore-{'DEBUG' if self.opencore_debug is True else 'RELEASE'}.zip")

    @property
    def plist_template(self):
        return self.payload_path / Path("Config/config.plist")

    # Launch Services
    @property
    def launch_services_path(self):
        return self.payload_path / Path("Launch Services")

    @property
    def auto_patch_launch_agent_path(self):
        return self.launch_services_path / Path("com.dortania.opencore-legacy-patcher.auto-patch.plist")

    @property
    def rsr_monitor_launch_daemon_path(self):
        return self.launch_services_path / Path("com.dortania.opencore-legacy-patcher.rsr-monitor.plist")

    @property
    def update_launch_daemon_path(self):
        return self.launch_services_path / Path("com.dortania.opencore-legacy-patcher.macos-update.plist")

    @property
    def kdk_launch_daemon_path(self):
        return self.launch_services_path / Path("com.dortania.opencore-legacy-patcher.os-caching.plist")

    # ACPI
    @property
    def pci_ssdt_path(self):
        return self.payload_path / Path("ACPI/SSDT-CPBG.aml")

    @property
    def windows_ssdt_path(self):
        return self.payload_path / Path("ACPI/SSDT-PCI.aml")

    @property
    def demux_ssdt_path(self):
        return self.payload_path / Path("ACPI/SSDT-DGPU.aml")

    # Drivers
    @property
    def nvme_driver_path(self):
        return self.payload_path / Path("Drivers/NvmExpressDxe.efi")

    @property
    def exfat_legacy_driver_path(self):
        return self.payload_path / Path("Drivers/ExFatDxeLegacy.efi")

    @property
    def amd_gop_driver_path(self):
        return self.payload_path / Path("Drivers/AMDGOP.efi")

    @property
    def nvidia_kepler_gop_driver_path(self):
        return self.payload_path / Path("Drivers/NVGOP_GK.efi")

    @property
    def xhci_driver_path(self):
        return self.payload_path / Path("Drivers/XhciDxe.efi")

    @property
    def usb_bus_driver_path(self):
        return self.payload_path / Path("Drivers/UsbBusDxe.efi")

    @property
    def diags_launcher_path(self):
        return self.payload_path / Path("Drivers/diags.efi")

    @property
    def link_rate_driver_path(self):
        return self.payload_path / Path("Drivers/FixPCIeLinkRate.efi")

    @property
    def installer_sh_path(self):
        return self.payload_path / Path("Installer.sh")

    # Kexts
    @property
    def payload_kexts_path(self):
        return self.payload_path / Path("Kexts")

    @property
    def lilu_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/Lilu-v{self.lilu_version}-{self.kext_variant}.zip")

    @property
    def whatevergreen_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/WhateverGreen-v{self.whatevergreen_version}-{self.kext_variant}.zip")

    @property
    def whatevergreen_navi_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/WhateverGreen-v{self.whatevergreen_navi_version}-{self.kext_variant}.zip")

    @property
    def airportbcrmfixup_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/AirportBrcmFixup-v{self.airportbcrmfixup_version}-{self.kext_variant}.zip")

    @property
    def restrictevents_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/RestrictEvents-v{self.restrictevents_version}-{self.kext_variant}.zip")

    @property
    def efi_disabler_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/EFICheckDisabler.zip")

    @property
    def bcm570_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/CatalinaBCM5701Ethernet-v{self.bcm570_version}.zip")

    @property
    def aquantia_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/AppleEthernetAbuantiaAqtion-v{self.aquantia_version}.zip")

    @property
    def i210_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/CatalinaIntelI210Ethernet-v{self.i210_version}.zip")

    @property
    def marvel_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/MarvelYukonEthernet-v{self.marvel_version}.zip")

    @property
    def nforce_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/nForceEthernet-v{self.nforce_version}.zip")

    @property
    def intel_82574l_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/Intel82574L-v{self.intel_82574l_version}.zip")

    @property
    def intel_8254x_path(self):
        return self.payload_kexts_path / Path(f"Ethernet/AppleIntel8254XEthernet-v{self.intel_8254x_version}.zip")

    @property
    def apple_usb_11_injector_path(self):
        return self.payload_kexts_path / Path(f"USB/USB1.1-Injector-v{self.apple_usb_11_injector}.zip")

    @property
    def aicpupm_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleIntelCPUPowerManagement-v{self.aicpupm_version}.zip")

    @property
    def aicpupm_client_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleIntelCPUPowerManagementClient-v{self.aicpupm_version}.zip")

    @property
    def mce_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleMCEReporterDisabler-v{self.mce_version}.zip")

    @property
    def bigsursdxc_path(self):
        return self.payload_kexts_path / Path(f"Misc/BigSurSDXC-v{self.bigsursdxc_version}.zip")

    @property
    def monterey_ahci_path(self):
        return self.payload_kexts_path / Path(f"Misc/MonteAHCIPort-v{self.monterey_ahci_version}.zip")

    @property
    def apfs_zlib_path(self):
        return self.payload_kexts_path / Path(f"Misc/NoAVXFSCompressionTypeZlib-v{self.apfs_zlib_version}.zip")

    @property
    def apfs_zlib_v2_path(self):
        return self.payload_kexts_path / Path(f"Misc/NoAVXFSCompressionTypeZlib-AVXpel-v{self.apfs_zlib_v2_version}.zip")

    @property
    def multitouch_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleUSBMultitouch-v{self.multitouch_version}.zip")

    @property
    def top_case_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleUSBTopCase-v{self.topcase_version}.zip")

    @property
    def top_case_inj_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleTopCaseInjector-v{self.topcase_inj_version}.zip")

    @property
    def t1_key_store_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleKeyStore-v{self.t1_key_store_version}.zip")

    @property
    def t1_credential_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleCredentialManager-v{self.t1_credential_version}.zip")

    @property
    def t1_sse_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleSSE-v{self.t1_sse_version}.zip")

    @property
    def t1_corecrypto_path(self):
        return self.payload_kexts_path / Path(f"Misc/corecrypto_T1-v{self.t1_corecrypto_version}.zip")

    @property
    def apple_spi_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleHSSPISupport-v{self.apple_spi_version}.zip")

    @property
    def apple_spi_hid_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleHSSPIHIDDriver-v{self.apple_spi_hid_version}.zip")

    @property
    def kernel_relay_path(self):
        return self.payload_kexts_path / Path(f"Misc/KernelRelayHost-v{self.kernel_relay_version}.zip")

    @property
    def mousse_path(self):
        return self.payload_kexts_path / Path(f"SSE/AAAMouSSE-v{self.mousse_version}.zip")

    @property
    def telemetrap_path(self):
        return self.payload_kexts_path / Path(f"SSE/telemetrap-v{self.telemetrap_version}.zip")

    @property
    def corecaptureelcap_path(self):
        return self.payload_kexts_path / Path(f"Wifi/corecaptureElCap-v{self.corecaptureelcap_version}.zip")

    @property
    def io80211elcap_path(self):
        return self.payload_kexts_path / Path(f"Wifi/IO80211ElCap-v{self.io80211elcap_version}.zip")

    @property
    def io80211legacy_path(self):
        return self.payload_kexts_path / Path(f"Wifi/IO80211FamilyLegacy-v{self.io80211legacy_version}.zip")

    @property
    def ioskywalk_path(self):
        return self.payload_kexts_path / Path(f"Wifi/IOSkywalkFamily-v{self.ioskywalk_version}.zip")

    @property
    def applealc_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/AppleALC-v{self.applealc_version}-{self.kext_variant}.zip")

    @property
    def piixata_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleIntelPIIXATA-v{self.piixata_version}.zip")

    @property
    def backlight_injector_path(self):
        return self.payload_kexts_path / Path(f"Misc/BacklightInjector-v{self.backlight_injector_version}.zip")

    @property
    def backlight_injectorA_path(self):
        return self.payload_kexts_path / Path(f"Misc/BacklightInjectorA-v{self.backlight_injectorA_version}.zip")

    @property
    def cpufriend_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/CPUFriend-v{self.cpufriend_version}-{self.kext_variant}.zip")

    @property
    def smcspoof_path(self):
        return self.payload_kexts_path / Path(f"Misc/SMC-Spoof-v{self.smcspoof_version}.zip")

    @property
    def btspoof_path(self):
        return self.payload_kexts_path / Path(f"Misc/Bluetooth-Spoof-v{self.btspoof_version}.zip")

    @property
    def aspp_override_path(self):
        return self.payload_kexts_path / Path(f"Misc/ASPP-Override-v{self.aspp_override_version}.zip")

    @property
    def ecm_override_path(self):
        return self.payload_kexts_path / Path(f"Misc/ECM-Override-v{self.ecm_override_version}.zip")

    @property
    def nvmefix_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/NVMeFix-v{self.nvmefix_version}-{self.kext_variant}.zip")

    @property
    def featureunlock_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/FeatureUnlock-v{self.featureunlock_version}-{self.kext_variant}.zip")

    @property
    def debugenhancer_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/DebugEnhancer-v{self.debugenhancer_version}-{self.kext_variant}.zip")

    @property
    def bluetool_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/BlueToolFixup-v{self.bluetool_version}-{self.kext_variant}.zip")

    @property
    def cslvfixup_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/CSLVFixup-v{self.cslvfixup_version}.zip")

    @property
    def autopkg_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/AutoPkgInstaller-v{self.autopkg_version}-{self.kext_variant}.zip")

    @property
    def cryptexfixup_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/CryptexFixup-v{self.cryptexfixup_version}-{self.kext_variant}.zip")

    @property
    def rsrhelper_path(self):
        return self.payload_kexts_path / Path(f"Acidanthera/RSRHelper-v{self.rsrhelper_version}-{self.kext_variant}.zip")

    @property
    def amfipass_path(self):
        # AMFIPass is release only
        return self.payload_kexts_path / Path(f"Acidanthera/AMFIPass-v{self.amfipass_version}-RELEASE.zip")

    @property
    def innie_path(self):
        return self.payload_kexts_path / Path(f"Misc/Innie-v{self.innie_version}-{self.kext_variant}.zip")

    @property
    def simplemsr_path(self):
        return self.payload_kexts_path / Path(f"Misc/SimpleMSR-v{self.simplemsr_version}.zip")

    @property
    def gpu_wake_path(self):
        return self.payload_kexts_path / Path(f"Misc/AMDGPUWakeHandler-v{self.gpu_wake_version}.zip")

    @property
    def apple_trackpad_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleUSBTrackpad-v{self.apple_trackpad}.zip")

    @property
    def apple_isight_path(self):
        return self.payload_kexts_path / Path(f"Misc/LegacyUSBVideoSupport-v{self.apple_isight_version}.zip")

    @property
    def legacy_keyboard_path(self):
        return self.payload_kexts_path / Path(f"Misc/LegacyKeyboardInjector-v{self.legacy_keyboard}.zip")

    @property
    def apple_raid_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleRAIDCard-v{self.apple_raid_version}.zip")

    @property
    def kdkless_path(self):
        return self.payload_kexts_path / Path(f"Misc/KDKlessWorkaround-v{self.kdkless_version}-{self.kext_variant}.zip")

    @property
    def s3x_nvme_path(self):
        return self.payload_kexts_path / Path(f"Misc/IOS3XeFamily-v{self.s3x_nvme_version}.zip")

    @property
    def apple_camera_path(self):
        return self.payload_kexts_path / Path(f"Misc/AppleCameraInterface-v{self.apple_camera_version}.zip")

    @property
    def plist_folder_path(self):
        return self.payload_kexts_path / Path("Plists")

    @property
    def platform_plugin_plist_path(self):
        return self.plist_folder_path / Path("PlatformPlugin")

    @property
    def fw_family_path(self):
        return self.payload_kexts_path / Path(f"FireWire/IOFireWireFamily-v{self.fw_kext}.zip")

    @property
    def fw_sbp2_path(self):
        return self.payload_kexts_path / Path(f"FireWire/IOFireWireSBP2-v{self.fw_kext}.zip")

    @property
    def fw_bus_path(self):
        return self.payload_kexts_path / Path(f"FireWire/IOFireWireSerialBusProtocolTransport-v{self.fw_kext}.zip")

    # Build Location
    @property
    def build_path(self):
        return self.current_path / Path("Build-Folder/")

    @property
    def opencore_release_folder(self):
        return self.build_path / Path(f"OpenCore-Build")

    @property
    def opencore_zip_copied(self):
        return self.build_path / Path(f"OpenCore-{'DEBUG' if self.opencore_debug is True else 'RELEASE'}.zip")

    @property
    def oc_folder(self):
        return self.opencore_release_folder / Path("EFI/OC/")

    @property
    def plist_path(self):
        return self.oc_folder / Path("config.plist")

    @property
    def acpi_path(self):
        return self.oc_folder / Path("ACPI")

    @property
    def drivers_path(self):
        return self.oc_folder / Path("Drivers")

    @property
    def kexts_path(self):
        return self.oc_folder / Path("Kexts")

    @property
    def resources_path(self):
        return self.oc_folder / Path("Resources")

    @property
    def map_kext_folder(self):
        return self.kexts_path / Path("USB-Map.kext")

    @property
    def map_contents_folder(self):
        return self.map_kext_folder / Path("Contents")

    @property
    def pp_kext_folder(self):
        return self.kexts_path / Path("CPUFriendDataProvider.kext")

    @property
    def pp_contents_folder(self):
        return self.pp_kext_folder / Path("Contents")

    @property
    def agdp_kext_folder(self):
        return self.kexts_path / Path("AGDP-Override.kext")

    @property
    def agdp_contents_folder(self):
        return self.agdp_kext_folder / Path("Contents")

    @property
    def agpm_kext_folder(self):
        return self.kexts_path / Path("AGPM-Override.kext")

    @property
    def agpm_contents_folder(self):
        return self.agpm_kext_folder / Path("Contents")

    @property
    def amc_kext_folder(self):
        return self.kexts_path / Path("AMC-Override.kext")

    @property
    def amc_contents_folder(self):
        return self.amc_kext_folder / Path("Contents")

    # Tools
    @property
    def macserial_path(self):
        return self.payload_path / Path("OpenCore/macserial")

    @property
    def vault_path(self):
        return self.payload_path / Path("Tools/CreateVault/sign.command")

    @property
    def ocvalidate_path(self):
        return self.payload_path / Path(f"OpenCore/ocvalidate")

    @property
    def oclp_helper_path(self):
        return self.payload_path / Path("Tools/OpenCore-Patcher.app/Contents/MacOS/OpenCore-Patcher")

    @property
    def rsrrepair_userspace_path(self):
        return self.payload_path / Path("Tools/RSRRepair")

    # Icons
    @property
    def icns_resource_path(self):
        if self.launcher_script:
            return self.payload_path / Path("Icon/AppIcons")
        return Path(self.launcher_binary).parent.parent / Path("Resources")


    @property
    def app_icon_path(self):
        return self.payload_path / Path("Icon/AppIcons/OC-Patcher.icns")

    @property
    def icon_path_external(self):
        return self.payload_path / Path("Icon/DriveIcons/External/.VolumeIcon.icns")

    @property
    def icon_path_internal(self):
        return self.payload_path / Path("Icon/DriveIcons/Internal/.VolumeIcon.icns")

    @property
    def icon_path_sd(self):
        return self.payload_path / Path("Icon/DriveIcons/SD-Card/.VolumeIcon.icns")

    @property
    def icon_path_ssd(self):
        return self.payload_path / Path("Icon/DriveIcons/SSD/.VolumeIcon.icns")

    @property
    def icon_path_macos_generic(self):
        return self.icns_resource_path / Path("Generic.icns")

    @property
    def icon_path_macos_big_sur(self):
        return self.icns_resource_path / Path("BigSur.icns")

    @property
    def icon_path_macos_monterey(self):
        return self.icns_resource_path / Path("Monterey.icns")

    @property
    def icon_path_macos_ventura(self):
        return self.icns_resource_path / Path("Ventura.icns")

    @property
    def icon_path_macos_sonoma(self):
        return self.icns_resource_path / Path("Sonoma.icns")

    @property
    def icon_path_macos_sequoia(self):
        return self.icns_resource_path / Path("Sequoia.icns")

    @property
    def gui_path(self):
        return self.payload_path / Path("Icon/Resources.zip")

    @property
    def installer_pkg_path(self):
        return self.payload_path / Path("AutoPkg-Assets.pkg")

    @property
    def installer_pkg_zip_path(self):
        return self.payload_path / Path("AutoPkg-Assets.pkg.zip")

    # Apple Payloads Paths
    @property
    def payload_local_binaries_root_path(self):
        return self.payload_path / Path("Universal-Binaries")

    @property
    def kdk_download_path(self):
        return self.payload_path / Path("KDK.dmg")

    @property
    def metallib_download_path(self):
        return self.payload_path / Path("MetallibSupportPkg.pkg")

    @property
    def icons_path(self):
        return [
            str(self.icon_path_macos_generic),
            str(self.icon_path_macos_big_sur),
            str(self.icon_path_macos_monterey),
            str(self.icon_path_macos_ventura),
            str(self.icon_path_macos_sonoma),
            str(self.icon_path_macos_sequoia),
        ]

    sbm_values = [
        "j137ap",  #  iMacPro1,1
        "j680ap",  #  MacBookPro15,1
        "j132ap",  #  MacBookPro15,2
        "j174ap",  #  Macmini8,1
        "j140kap",  # MacBookAir8,1
        "j780ap",  #  MacBookPro15,3
        "j213ap",  #  MacBookPro15,4
        "j140aap",  # MacBookAir8,2
        "j152fap",  # MacBookPro16,1
        "j160ap",  #  MacPro7,1
        "j230kap",  # MacBookAir9,1
        "j214kap",  # MacBookPro16,2
        "j223ap",  #  MacBookPro16,3
        "j215ap",  #  MacBookPro16,4
        "j185ap",  #  iMac20,1
        "j185fap",  # iMac20,2
        # "x86legacy",  # non-T2 Macs/VMs, Monterey's boot.efi enforces this on all Macs
    ]

    sandy_board_id_stock = [
        "Mac-94245B3640C91C81",  # MacBookPro8,1
        "Mac-94245A3940C91C80",  # MacBookPro8,2
        "Mac-942459F5819B171B",  # MacBookPro8,3
        "Mac-C08A6BB70A942AC2",  # MacBookAir4,1
        "Mac-742912EFDBEE19B3",  # MacBookAir4,2
        "Mac-8ED6AF5B48C039E1",  # Macmini5,1
        "Mac-4BC72D62AD45599E",  # Macmini5,2
        "Mac-7BA5B2794B2CDB12",  # Macmini5,3
        "Mac-942B5BF58194151B",  # iMac12,1
        "Mac-942B59F58194171B",  # iMac12,2
        "Mac-94245AF5819B141B",  # AppleInternal MacBookPro8,3
        "Mac-942B5B3A40C91381",  # AppleInternal iMac12,2
    ]

"""
amfi_data.py: AppleMobileFileIntegrity Bitmask Data
"""

"""
Within AppleMobileFileIntegrity.kext, Apple has a bitmask-based boot-arg (ex. amfi=128)
Below information is from reversed values in 13.0 Beta 6's AppleMobileFileIntegrity.kext
Currently only 'amfi=3' has been used by Apple publicly
- 0x3 used in 11.0.1 dyld source:
  - https://github.com/apple-oss-distributions/dyld/blob/5c9192436bb195e7a8fe61f22a229ee3d30d8222/testing/test-cases/kernel-hello-world.dtest/main.c#L2
"""

import enum


class AppleMobileFileIntegrity(enum.IntEnum):
    # Names set are solely for readability
    # Internal names are unknown
    AMFI_ALLOW_TASK_FOR_PID:      int = 0x1   # Allow Task for PID (alt. amfi_unrestrict_task_for_pid=0x1)
    AMFI_ALLOW_INVALID_SIGNATURE: int = 0x2   # Reduce sig enforcement (alt. amfi_allow_any_signature=0x1)
    AMFI_LV_ENFORCE_THIRD_PARTY:  int = 0x4   # Don't mark external binaries as platform binaries
    AMFI_UNKNOWN_1:               int = 0x8
    AMFI_UNKNOWN_2:               int = 0x10
    AMFI_UNKNOWN_3:               int = 0x20
    AMFI_UNKNOWN_4:               int = 0x40
    AMFI_ALLOW_EVERYTHING:        int = 0x80  # Disable sig enforcement and Library Validation (alt. amfi_get_out_of_my_way=0x1)

"""
Internally within AMFI.kext, Apple references 0x2 and 0x80 as both 'Disable signature enforcement'
However 0x80 is a higher privilege than 0x2, and breaks TCC support in OS (ex. Camera, Microphone, etc prompts)

Supported boot-args within AMFI.kext, last compared against 13.0 Beta 6

  Within _initializeAppleMobileFileIntegrity():
    - amfi_unrestrict_task_for_pid=0x1
    - amfi_dev_mode_policy=0x1
    - amfi_allow_any_signature=0x1
    - amfi_get_out_of_my_way=0x1
    - amfi_unrestricted_local_signing=0x1
    - pmap_cs_unrestricted_local_signing=0x1
    - amfi_ready_to_roll=0x1
    - cs_enforcement_disable=0x1

  Within AMFIInitializeLocalSigningPublicKey():
    - -restore

  Within macOSPolicyConfigurationInit():
    - amfi_force_policy=0x1
    - amfi_block_unsigned_code=0x1
    - amfi_force_cs_kill=0x1
    - amfi_hsp_disable=0x1
    - amfi_hsp_logging=0x1
    - amfi_allow_bni_as_platform=0x1
    - amfi_allow_non_platform=0x1
    - amfi_prevent_old_entitled_platform_binaries=0x1
    - amfi_allow_only_tc=0x1
    - amfi_allow_only_tc_override=0x1

  Within configurationSettingsInit()
    - amfi_enforce_launch_constraints=0x1
    - amfi_allow_3p_launch_constraints=0x1
    - BATS_TESTPLAN_ID="Custom Team ID"
"""

"""
cpu_data.py: CPU Generation Data
"""

import enum


class CPUGen(enum.IntEnum):
    pentium_4     = 0
    yonah         = 1
    conroe        = 2
    penryn        = 3
    nehalem       = 4    # (Westmere included)
    sandy_bridge  = 5    # 2000
    ivy_bridge    = 6    # 3000
    haswell       = 7    # 4000
    broadwell     = 8    # 5000
    skylake       = 9    # 6000
    kaby_lake     = 10   # 7000
    coffee_lake   = 11   # 8000/9000
    comet_lake    = 12   # 10000
    ice_lake      = 13   # 10000

    apple_dtk     = 100  # A12
    apple_silicon = 101  # A14 and newer (not tracked beyond this point) 

# Please ensure to add specific item to this being alder_lake and items for it matching cpu
# Also raptor_lake and items for it matching cpu

"""
css_data.py: CSS data for project's update window

Comprised of https://github.com/sindresorhus/github-markdown-css and additions for OCLP
"""


updater_css = """

/* START GITHUB CSS */

@media (prefers-color-scheme: dark) {
  .markdown-body,
  [data-theme="dark"] {
    /*dark*/
    color-scheme: dark;
    --color-prettylights-syntax-comment: #8b949e;
    --color-prettylights-syntax-constant: #79c0ff;
    --color-prettylights-syntax-entity: #d2a8ff;
    --color-prettylights-syntax-storage-modifier-import: #c9d1d9;
    --color-prettylights-syntax-entity-tag: #7ee787;
    --color-prettylights-syntax-keyword: #ff7b72;
    --color-prettylights-syntax-string: #a5d6ff;
    --color-prettylights-syntax-variable: #ffa657;
    --color-prettylights-syntax-brackethighlighter-unmatched: #f85149;
    --color-prettylights-syntax-invalid-illegal-text: #f0f6fc;
    --color-prettylights-syntax-invalid-illegal-bg: #8e1519;
    --color-prettylights-syntax-carriage-return-text: #f0f6fc;
    --color-prettylights-syntax-carriage-return-bg: #b62324;
    --color-prettylights-syntax-string-regexp: #7ee787;
    --color-prettylights-syntax-markup-list: #f2cc60;
    --color-prettylights-syntax-markup-heading: #1f6feb;
    --color-prettylights-syntax-markup-italic: #c9d1d9;
    --color-prettylights-syntax-markup-bold: #c9d1d9;
    --color-prettylights-syntax-markup-deleted-text: #ffdcd7;
    --color-prettylights-syntax-markup-deleted-bg: #67060c;
    --color-prettylights-syntax-markup-inserted-text: #aff5b4;
    --color-prettylights-syntax-markup-inserted-bg: #033a16;
    --color-prettylights-syntax-markup-changed-text: #ffdfb6;
    --color-prettylights-syntax-markup-changed-bg: #5a1e02;
    --color-prettylights-syntax-markup-ignored-text: #c9d1d9;
    --color-prettylights-syntax-markup-ignored-bg: #1158c7;
    --color-prettylights-syntax-meta-diff-range: #d2a8ff;
    --color-prettylights-syntax-brackethighlighter-angle: #8b949e;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #484f58;
    --color-prettylights-syntax-constant-other-reference-link: #a5d6ff;
    --color-fg-default: #e6edf3;
    --color-fg-muted: #848d97;
    --color-fg-subtle: #6e7681;
    --color-canvas-default: #0d1117;
    --color-canvas-subtle: #161b22;
    --color-border-default: #30363d;
    --color-border-muted: #21262d;
    --color-neutral-muted: rgba(110,118,129,0.4);
    --color-accent-fg: #2f81f7;
    --color-accent-emphasis: #1f6feb;
    --color-success-fg: #3fb950;
    --color-success-emphasis: #238636;
    --color-attention-fg: #d29922;
    --color-attention-emphasis: #9e6a03;
    --color-attention-subtle: rgba(187,128,9,0.15);
    --color-danger-fg: #f85149;
    --color-danger-emphasis: #da3633;
    --color-done-fg: #a371f7;
    --color-done-emphasis: #8957e5;
  }
}

@media (prefers-color-scheme: light) {
  .markdown-body,
  [data-theme="light"] {
    /*light*/
    color-scheme: light;
    --color-prettylights-syntax-comment: #57606a;
    --color-prettylights-syntax-constant: #0550ae;
    --color-prettylights-syntax-entity: #6639ba;
    --color-prettylights-syntax-storage-modifier-import: #24292f;
    --color-prettylights-syntax-entity-tag: #116329;
    --color-prettylights-syntax-keyword: #cf222e;
    --color-prettylights-syntax-string: #0a3069;
    --color-prettylights-syntax-variable: #953800;
    --color-prettylights-syntax-brackethighlighter-unmatched: #82071e;
    --color-prettylights-syntax-invalid-illegal-text: #f6f8fa;
    --color-prettylights-syntax-invalid-illegal-bg: #82071e;
    --color-prettylights-syntax-carriage-return-text: #f6f8fa;
    --color-prettylights-syntax-carriage-return-bg: #cf222e;
    --color-prettylights-syntax-string-regexp: #116329;
    --color-prettylights-syntax-markup-list: #3b2300;
    --color-prettylights-syntax-markup-heading: #0550ae;
    --color-prettylights-syntax-markup-italic: #24292f;
    --color-prettylights-syntax-markup-bold: #24292f;
    --color-prettylights-syntax-markup-deleted-text: #82071e;
    --color-prettylights-syntax-markup-deleted-bg: #ffebe9;
    --color-prettylights-syntax-markup-inserted-text: #116329;
    --color-prettylights-syntax-markup-inserted-bg: #dafbe1;
    --color-prettylights-syntax-markup-changed-text: #953800;
    --color-prettylights-syntax-markup-changed-bg: #ffd8b5;
    --color-prettylights-syntax-markup-ignored-text: #eaeef2;
    --color-prettylights-syntax-markup-ignored-bg: #0550ae;
    --color-prettylights-syntax-meta-diff-range: #8250df;
    --color-prettylights-syntax-brackethighlighter-angle: #57606a;
    --color-prettylights-syntax-sublimelinter-gutter-mark: #8c959f;
    --color-prettylights-syntax-constant-other-reference-link: #0a3069;
    --color-fg-default: #1F2328;
    --color-fg-muted: #656d76;
    --color-fg-subtle: #6e7781;
    --color-canvas-default: #ffffff;
    --color-canvas-subtle: #f6f8fa;
    --color-border-default: #d0d7de;
    --color-border-muted: hsla(210,18%,87%,1);
    --color-neutral-muted: rgba(175,184,193,0.2);
    --color-accent-fg: #0969da;
    --color-accent-emphasis: #0969da;
    --color-success-fg: #1a7f37;
    --color-success-emphasis: #1f883d;
    --color-attention-fg: #9a6700;
    --color-attention-emphasis: #9a6700;
    --color-attention-subtle: #fff8c5;
    --color-danger-fg: #d1242f;
    --color-danger-emphasis: #cf222e;
    --color-done-fg: #8250df;
    --color-done-emphasis: #8250df;
  }
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  margin: 0;
  color: var(--color-fg-default);
  background-color: var(--color-canvas-default);
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body h1:hover .anchor .octicon-link:before,
.markdown-body h2:hover .anchor .octicon-link:before,
.markdown-body h3:hover .anchor .octicon-link:before,
.markdown-body h4:hover .anchor .octicon-link:before,
.markdown-body h5:hover .anchor .octicon-link:before,
.markdown-body h6:hover .anchor .octicon-link:before {
  width: 16px;
  height: 16px;
  content: ' ';
  display: inline-block;
  background-color: currentColor;
  -webkit-mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
  mask-image: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");
}

.markdown-body details,
.markdown-body figcaption,
.markdown-body figure {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body [hidden] {
  display: none !important;
}

.markdown-body a {
  background-color: transparent;
  color: var(--color-accent-fg);
  text-decoration: none;
}

.markdown-body abbr[title] {
  border-bottom: none;
  -webkit-text-decoration: underline dotted;
  text-decoration: underline dotted;
}

.markdown-body b,
.markdown-body strong {
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body dfn {
  font-style: italic;
}

.markdown-body h1 {
  margin: .67em 0;
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 2em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body mark {
  background-color: var(--color-attention-subtle);
  color: var(--color-fg-default);
}

.markdown-body small {
  font-size: 90%;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body sup {
  top: -0.5em;
}

.markdown-body img {
  border-style: none;
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--color-canvas-default);
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace;
  font-size: 1em;
}

.markdown-body figure {
  margin: 1em 40px;
}

.markdown-body hr {
  box-sizing: content-box;
  overflow: hidden;
  background: transparent;
  border-bottom: 1px solid var(--color-border-muted);
  height: .25em;
  padding: 0;
  margin: 24px 0;
  background-color: var(--color-border-default);
  border: 0;
}

.markdown-body input {
  font: inherit;
  margin: 0;
  overflow: visible;
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body [type=button],
.markdown-body [type=reset],
.markdown-body [type=submit] {
  -webkit-appearance: button;
  appearance: button;
}

.markdown-body [type=checkbox],
.markdown-body [type=radio] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body [type=number]::-webkit-inner-spin-button,
.markdown-body [type=number]::-webkit-outer-spin-button {
  height: auto;
}

.markdown-body [type=search]::-webkit-search-cancel-button,
.markdown-body [type=search]::-webkit-search-decoration {
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body ::-webkit-input-placeholder {
  color: inherit;
  opacity: .54;
}

.markdown-body ::-webkit-file-upload-button {
  -webkit-appearance: button;
  appearance: button;
  font: inherit;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body ::placeholder {
  color: var(--color-fg-subtle);
  opacity: 1;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
  display: block;
  width: max-content;
  max-width: 100%;
  overflow: auto;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body details:not([open])>*:not(summary) {
  display: none !important;
}

.markdown-body a:focus,
.markdown-body [role=button]:focus,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=checkbox]:focus {
  outline: 2px solid var(--color-accent-fg);
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:focus:not(:focus-visible),
.markdown-body [role=button]:focus:not(:focus-visible),
.markdown-body input[type=radio]:focus:not(:focus-visible),
.markdown-body input[type=checkbox]:focus:not(:focus-visible) {
  outline: solid 1px transparent;
}

.markdown-body a:focus-visible,
.markdown-body [role=button]:focus-visible,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus-visible {
  outline: 2px solid var(--color-accent-fg);
  outline-offset: -2px;
  box-shadow: none;
}

.markdown-body a:not([class]):focus,
.markdown-body a:not([class]):focus-visible,
.markdown-body input[type=radio]:focus,
.markdown-body input[type=radio]:focus-visible,
.markdown-body input[type=checkbox]:focus,
.markdown-body input[type=checkbox]:focus-visible {
  outline-offset: 0;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  line-height: 10px;
  color: var(--color-fg-default);
  vertical-align: middle;
  background-color: var(--color-canvas-subtle);
  border: solid 1px var(--color-neutral-muted);
  border-bottom-color: var(--color-neutral-muted);
  border-radius: 6px;
  box-shadow: inset 0 -1px 0 var(--color-neutral-muted);
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: var(--base-text-weight-semibold, 600);
  line-height: 1.25;
}

.markdown-body h2 {
  font-weight: var(--base-text-weight-semibold, 600);
  padding-bottom: .3em;
  font-size: 1.5em;
  border-bottom: 1px solid var(--color-border-muted);
}

.markdown-body h3 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1.25em;
}

.markdown-body h4 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: 1em;
}

.markdown-body h5 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .875em;
}

.markdown-body h6 {
  font-weight: var(--base-text-weight-semibold, 600);
  font-size: .85em;
  color: var(--color-fg-muted);
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
  padding: 0 1em;
  color: var(--color-fg-muted);
  border-left: .25em solid var(--color-border-default);
}

.markdown-body ul,
.markdown-body ol {
  margin-top: 0;
  margin-bottom: 0;
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body tt,
.markdown-body code,
.markdown-body samp {
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;
  font-size: 12px;
  word-wrap: normal;
}

.markdown-body .octicon {
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-body input::-webkit-outer-spin-button,
.markdown-body input::-webkit-inner-spin-button {
  margin: 0;
  -webkit-appearance: none;
  appearance: none;
}

.markdown-body .mr-2 {
  margin-right: var(--base-size-8, 8px) !important;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .absent {
  color: var(--color-danger-fg);
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body details {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: var(--color-fg-default);
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 tt,
.markdown-body h1 code,
.markdown-body h2 tt,
.markdown-body h2 code,
.markdown-body h3 tt,
.markdown-body h3 code,
.markdown-body h4 tt,
.markdown-body h4 code,
.markdown-body h5 tt,
.markdown-body h5 code,
.markdown-body h6 tt,
.markdown-body h6 code {
  padding: 0 .2em;
  font-size: inherit;
}

.markdown-body summary h1,
.markdown-body summary h2,
.markdown-body summary h3,
.markdown-body summary h4,
.markdown-body summary h5,
.markdown-body summary h6 {
  display: inline-block;
}

.markdown-body summary h1 .anchor,
.markdown-body summary h2 .anchor,
.markdown-body summary h3 .anchor,
.markdown-body summary h4 .anchor,
.markdown-body summary h5 .anchor,
.markdown-body summary h6 .anchor {
  margin-left: -40px;
}

.markdown-body summary h1,
.markdown-body summary h2 {
  padding-bottom: 0;
  border-bottom: 0;
}

.markdown-body ul.no-list,
.markdown-body ol.no-list {
  padding: 0;
  list-style-type: none;
}

.markdown-body ol[type="a s"] {
  list-style-type: lower-alpha;
}

.markdown-body ol[type="A s"] {
  list-style-type: upper-alpha;
}

.markdown-body ol[type="i s"] {
  list-style-type: lower-roman;
}

.markdown-body ol[type="I s"] {
  list-style-type: upper-roman;
}

.markdown-body ol[type="1"] {
  list-style-type: decimal;
}

.markdown-body div>ol:not([type]) {
  list-style-type: decimal;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table th {
  font-weight: var(--base-text-weight-semibold, 600);
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid var(--color-border-default);
}

.markdown-body table td>:last-child {
  margin-bottom: 0;
}

.markdown-body table tr {
  background-color: var(--color-canvas-default);
  border-top: 1px solid var(--color-border-muted);
}

.markdown-body table tr:nth-child(2n) {
  background-color: var(--color-canvas-subtle);
}

.markdown-body table img {
  background-color: transparent;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body .emoji {
  max-width: none;
  vertical-align: text-top;
  background-color: transparent;
}

.markdown-body span.frame {
  display: block;
  overflow: hidden;
}

.markdown-body span.frame>span {
  display: block;
  float: left;
  width: auto;
  padding: 7px;
  margin: 13px 0 0;
  overflow: hidden;
  border: 1px solid var(--color-border-default);
}

.markdown-body span.frame span img {
  display: block;
  float: left;
}

.markdown-body span.frame span span {
  display: block;
  padding: 5px 0 0;
  clear: both;
  color: var(--color-fg-default);
}

.markdown-body span.align-center {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-center>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: center;
}

.markdown-body span.align-center span img {
  margin: 0 auto;
  text-align: center;
}

.markdown-body span.align-right {
  display: block;
  overflow: hidden;
  clear: both;
}

.markdown-body span.align-right>span {
  display: block;
  margin: 13px 0 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body span.align-right span img {
  margin: 0;
  text-align: right;
}

.markdown-body span.float-left {
  display: block;
  float: left;
  margin-right: 13px;
  overflow: hidden;
}

.markdown-body span.float-left span {
  margin: 13px 0 0;
}

.markdown-body span.float-right {
  display: block;
  float: right;
  margin-left: 13px;
  overflow: hidden;
}

.markdown-body span.float-right>span {
  display: block;
  margin: 13px auto 0;
  overflow: hidden;
  text-align: right;
}

.markdown-body code,
.markdown-body tt {
  padding: .2em .4em;
  margin: 0;
  font-size: 85%;
  white-space: break-spaces;
  background-color: var(--color-neutral-muted);
  border-radius: 6px;
}

.markdown-body code br,
.markdown-body tt br {
  display: none;
}

.markdown-body del code {
  text-decoration: inherit;
}

.markdown-body samp {
  font-size: 85%;
}

.markdown-body pre code {
  font-size: 100%;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  color: var(--color-fg-default);
  background-color: var(--color-canvas-subtle);
  border-radius: 6px;
}

.markdown-body pre code,
.markdown-body pre tt {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .csv-data td,
.markdown-body .csv-data th {
  padding: 5px;
  overflow: hidden;
  font-size: 12px;
  line-height: 1;
  text-align: left;
  white-space: nowrap;
}

.markdown-body .csv-data .blob-num {
  padding: 10px 8px 9px;
  text-align: right;
  background: var(--color-canvas-default);
  border: 0;
}

.markdown-body .csv-data tr {
  border-top: 0;
}

.markdown-body .csv-data th {
  font-weight: var(--base-text-weight-semibold, 600);
  background: var(--color-canvas-subtle);
  border-top: 0;
}

.markdown-body [data-footnote-ref]::before {
  content: "[";
}

.markdown-body [data-footnote-ref]::after {
  content: "]";
}

.markdown-body .footnotes {
  font-size: 12px;
  color: var(--color-fg-muted);
  border-top: 1px solid var(--color-border-default);
}

.markdown-body .footnotes ol {
  padding-left: 16px;
}

.markdown-body .footnotes ol ul {
  display: inline-block;
  padding-left: 16px;
  margin-top: 16px;
}

.markdown-body .footnotes li {
  position: relative;
}

.markdown-body .footnotes li:target::before {
  position: absolute;
  top: -8px;
  right: -8px;
  bottom: -8px;
  left: -24px;
  pointer-events: none;
  content: "";
  border: 2px solid var(--color-accent-emphasis);
  border-radius: 6px;
}

.markdown-body .footnotes li:target {
  color: var(--color-fg-default);
}

.markdown-body .footnotes .data-footnote-backref g-emoji {
  font-family: monospace;
}

.markdown-body .pl-c {
  color: var(--color-prettylights-syntax-comment);
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: var(--color-prettylights-syntax-constant);
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: var(--color-prettylights-syntax-entity);
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: var(--color-prettylights-syntax-storage-modifier-import);
}

.markdown-body .pl-ent {
  color: var(--color-prettylights-syntax-entity-tag);
}

.markdown-body .pl-k {
  color: var(--color-prettylights-syntax-keyword);
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: var(--color-prettylights-syntax-string);
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: var(--color-prettylights-syntax-variable);
}

.markdown-body .pl-bu {
  color: var(--color-prettylights-syntax-brackethighlighter-unmatched);
}

.markdown-body .pl-ii {
  color: var(--color-prettylights-syntax-invalid-illegal-text);
  background-color: var(--color-prettylights-syntax-invalid-illegal-bg);
}

.markdown-body .pl-c2 {
  color: var(--color-prettylights-syntax-carriage-return-text);
  background-color: var(--color-prettylights-syntax-carriage-return-bg);
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: var(--color-prettylights-syntax-string-regexp);
}

.markdown-body .pl-ml {
  color: var(--color-prettylights-syntax-markup-list);
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-heading);
}

.markdown-body .pl-mi {
  font-style: italic;
  color: var(--color-prettylights-syntax-markup-italic);
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: var(--color-prettylights-syntax-markup-bold);
}

.markdown-body .pl-md {
  color: var(--color-prettylights-syntax-markup-deleted-text);
  background-color: var(--color-prettylights-syntax-markup-deleted-bg);
}

.markdown-body .pl-mi1 {
  color: var(--color-prettylights-syntax-markup-inserted-text);
  background-color: var(--color-prettylights-syntax-markup-inserted-bg);
}

.markdown-body .pl-mc {
  color: var(--color-prettylights-syntax-markup-changed-text);
  background-color: var(--color-prettylights-syntax-markup-changed-bg);
}

.markdown-body .pl-mi2 {
  color: var(--color-prettylights-syntax-markup-ignored-text);
  background-color: var(--color-prettylights-syntax-markup-ignored-bg);
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: var(--color-prettylights-syntax-meta-diff-range);
}

.markdown-body .pl-ba {
  color: var(--color-prettylights-syntax-brackethighlighter-angle);
}

.markdown-body .pl-sg {
  color: var(--color-prettylights-syntax-sublimelinter-gutter-mark);
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: var(--color-prettylights-syntax-constant-other-reference-link);
}

.markdown-body g-emoji {
  display: inline-block;
  min-width: 1ch;
  font-family: "Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 1em;
  font-style: normal !important;
  font-weight: var(--base-text-weight-normal, 400);
  line-height: 1;
  vertical-align: -0.075em;
}

.markdown-body g-emoji img {
  width: 1em;
  height: 1em;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item label {
  font-weight: var(--base-text-weight-normal, 400);
}

.markdown-body .task-list-item.enabled label {
  cursor: pointer;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 4px;
}

.markdown-body .task-list-item .handle {
  display: none;
}

.markdown-body .task-list-item-checkbox {
  margin: 0 .2em .25em -1.4em;
  vertical-align: middle;
}

.markdown-body .contains-task-list:dir(rtl) .task-list-item-checkbox {
  margin: 0 -1.6em .25em .2em;
}

.markdown-body .contains-task-list {
  position: relative;
}

.markdown-body .contains-task-list:hover .task-list-item-convert-container,
.markdown-body .contains-task-list:focus-within .task-list-item-convert-container {
  display: block;
  width: auto;
  height: 24px;
  overflow: visible;
  clip: auto;
}

.markdown-body ::-webkit-calendar-picker-indicator {
  filter: invert(50%);
}

.markdown-body .markdown-alert {
  padding: var(--base-size-8) var(--base-size-16);
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid var(--color-border-default);
}

.markdown-body .markdown-alert>:first-child {
  margin-top: 0;
}

.markdown-body .markdown-alert>:last-child {
  margin-bottom: 0;
}

.markdown-body .markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: var(--base-text-weight-medium, 500);
  align-items: center;
  line-height: 1;
}

.markdown-body .markdown-alert.markdown-alert-note {
  border-left-color: var(--color-accent-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-accent-fg);
}

.markdown-body .markdown-alert.markdown-alert-important {
  border-left-color: var(--color-done-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-done-fg);
}

.markdown-body .markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-attention-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-attention-fg);
}

.markdown-body .markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-success-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-success-fg);
}

.markdown-body .markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-danger-emphasis);
}

.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-danger-fg);
}

/* START CUSTOM CSS */

body {
  padding: 10px;
  zoom: 80%;
}

"""


example_data.py:
"""
example_data.py: Sample Hardware probes, for use in OpenCore Legacy Patcher validation
"""

from ..detections import device_probe


class MacBook:

    MacBook71 = device_probe.Computer(
        real_model="MacBook7,1",
        real_board_id="Mac-F22C89C8",
        reported_model="MacBook7,1",
        reported_board_id="Mac-F22C89C8",
        gpus=[
            device_probe.NVIDIA(vendor_id=4318, device_id=2208, class_code=196608, name="IGPU", model="NVIDIA GeForce 320M", pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
        ],
        igpu=device_probe.NVIDIA(vendor_id=4318, device_id=2208, class_code=196608, name="IGPU", model="NVIDIA GeForce 320M", pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
        dgpu=None,
        storage=[
            device_probe.SATAController(vendor_id=4318, device_id=3464, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0xa,0x0)"),
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17235, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x15,0x0)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "SMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

class MacBookPro:

    MacBookPro92_Stock = device_probe.Computer(
        real_model="MacBookPro9,2",
        real_board_id="Mac-6F01561E16C75D06",
        reported_model="MacBookPro9,2",
        reported_board_id="Mac-6F01561E16C75D06",
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=358, class_code=196608, name="IGPU", model="Intel HD Graphics 4000", pci_path="PciRoot(0x0)/Pci(0x2,0x0)")
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=358, class_code=196608, name="IGPU", model="Intel HD Graphics 4000", pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
        dgpu=None,
        storage=[device_probe.SATAController(vendor_id=32902, device_id=7683, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17201, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'EST', 'TM2', 'SSSE3', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    MacBookPro111_Stock = device_probe.Computer(
        real_model='MacBookPro11,1',
        real_board_id='Mac-189A3D4F975D5FFC',
        reported_model='MacBookPro11,1',
        reported_board_id='Mac-189A3D4F975D5FFC',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=2606, class_code=196608, name='IGPU', model='Intel Iris', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)')
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=2606, class_code=196608, name='IGPU', model='Intel Iris', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
        dgpu=None,
        storage=[
            device_probe.SATAController(vendor_id=6987, device_id=37251, class_code=67073, name='SSD0', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP06@1c0005/SSD0@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x5)/Pci(0x0,0x0)')
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=39985, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)')
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17312, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP03@1c0002/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)'),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-4258U CPU @ 2.40GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[],
        ),
        oclp_version='0.4.2',
        opencore_version='DBG-077-2022-01-10',
        bluetooth_chipset='BRCM20702 Hub',
        third_party_sata_ssd=False
    )

    MacBookPro133_Stock = device_probe.Computer(
        real_model='MacBookPro13,3',
        real_board_id='Mac-A5C67F76ED83108C',
        reported_model='MacBookPro13,3',
        reported_board_id='Mac-A5C67F76ED83108C',
        build_model='MacBookPro13,3',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=6427, class_code=196608, name='IGPU', model='Intel HD Graphics 530', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
            device_probe.AMD(vendor_id=4098, device_id=26607, class_code=196608, name='GFX0', model='AMD Radeon Pro 455', acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG0@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=6427, class_code=196608, name='IGPU', model='Intel HD Graphics 530', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26607, class_code=196608, name='GFX0', model='AMD Radeon Pro 455', acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG0@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        storage=[
            device_probe.NVMeController(vendor_id=5197, device_id=43012, class_code=67586, name='SSD0', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP17@1b0000/SSD0@0', pci_path='PciRoot(0x0)/Pci(0x1b,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False, aspm=258)
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=41263, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)', disable_metal=False, force_compatible=False),
            device_probe.XHCIController(vendor_id=32902, device_id=5588, class_code=787248, name='XHC3', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG2@10002/UPSB@0/DSB2@20000/XHC3@0', pci_path='PciRoot(0x0)/Pci(0x1,0x2)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
            device_probe.XHCIController(vendor_id=32902, device_id=5588, class_code=787248, name='XHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG1@10001/UPSB@0/DSB2@20000/XHC2@0', pci_path='PciRoot(0x0)/Pci(0x1,0x1)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[],
        ethernet=[],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17338, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[]
        ),
        oclp_version='0.5.0',
        opencore_version=None,
        opencore_path=None,
        bluetooth_chipset=None,
        ambient_light_sensor=False,
        third_party_sata_ssd=False,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version=None,
        oclp_sys_date=None,
        oclp_sys_url=None,
        firmware_vendor='Apple'
    )

    MacBookPro141_SSD_Upgrade = device_probe.Computer(
        real_model='MacBookPro14,1',
        real_board_id='Mac-B4831CEBD52A0C4C',
        reported_model='MacBookPro14,1',
        reported_board_id='Mac-B4831CEBD52A0C4C',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=22822, class_code=196608, name='IGPU', model='Intel Iris Plus Graphics 640', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)')
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=22822, class_code=196608, name='IGPU', model='Intel Iris Plus Graphics 640', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
        dgpu=None,
        storage=[
            device_probe.NVMeController(vendor_id=6535, device_id=20499, class_code=67586, name='SSD0', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/SSD0@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', aspm=2)
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=40239, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)'),
            device_probe.XHCIController(vendor_id=32902, device_id=5588, class_code=787248, name='XHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP05@1c0004/UPSB@0/DSB2@20000/XHC2@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x4)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)')
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17315, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP09@1d0000/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1d,0x0)/Pci(0x0,0x0)'),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[],
        ), oclp_version='0.4.1',
        opencore_version=None,
        bluetooth_chipset=None,
        third_party_sata_ssd=False)

    MacBookPro171_Stock = device_probe.Computer(
        # Run under Rosetta
        real_model="MacBookPro17,1",
        real_board_id="J293",
        reported_model="MacBookPro17,1",
        reported_board_id="J293",
        gpus=[device_probe.AMD(vendor_id=4098, device_id=26640, class_code=196608, name="display", model="Unknown Unknown", pci_path="")],
        igpu=None,
        dgpu=None,
        storage=[],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17445, class_code=163840, name="wlan", model=None, pci_path=""),
        cpu=device_probe.CPU(
            name="Apple M1",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "PCLMULQDQ", "DTSE64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "AES", "SEGLIM64"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

class Macmini:

    Macmini52_Stock = device_probe.Computer(
        real_model='Macmini5,2',
        real_board_id='Mac-4BC72D62AD45599E',
        reported_model='Macmini5,2',
        reported_board_id='Mac-4BC72D62AD45599E',
        build_model='Macmini5,2',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=294, class_code=229376, name='IGPU', model='Intel HD Graphics 3000', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
            device_probe.AMD(vendor_id=4098, device_id=26433, class_code=196608, name='GFX0', model='AMD Radeon HD 6630M', acpi_path='IOACPIPlane:/_SB/PCI0@0/P0P2@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)],
        igpu=device_probe.Intel(vendor_id=32902, device_id=294, class_code=229376, name='IGPU', model='Intel HD Graphics 3000', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26433, class_code=196608, name='GFX0', model='AMD Radeon HD 6630M', acpi_path='IOACPIPlane:/_SB/PCI0@0/P0P2@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=7171, class_code=67073, name='SATA', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SATA@1f0002', pci_path='PciRoot(0x0)/Pci(0x1f,0x2)', disable_metal=False, force_compatible=False)
        ],
        usb_controllers=[
            device_probe.EHCIController(vendor_id=32902, device_id=7213, class_code=787232, name='EHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC2@1a0007', pci_path='PciRoot(0x0)/Pci(0x1a,0x7)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=7206, class_code=787232, name='EHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC1@1d0007', pci_path='PciRoot(0x0)/Pci(0x1d,0x7)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=7212, class_code=787200, name='UHC5', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC5@1a0000', pci_path='PciRoot(0x0)/Pci(0x1a,0x0)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=7207, class_code=787200, name='UHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC1@1d0000', pci_path='PciRoot(0x0)/Pci(0x1d,0x0)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[
            device_probe.SDXCController(vendor_id=5348, device_id=5820, class_code=525569, name='SDXC', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/SDXC@1', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x1)', disable_metal=False, force_compatible=False)
        ],
        ethernet=[
            device_probe.BroadcomEthernet(vendor_id=5348, device_id=5812, class_code=131072, name='GIGE', model='Broadcom 57765-B0', acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/GIGE@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17201, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP02@1c0001/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-2520M CPU @ 2.50GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'TSCTMR', 'AVX1.0'],
            leafs=['']
        ),
        oclp_version='0.5.0',
        opencore_version='REL-083-2022-08-01',
        opencore_path='PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0x0,0x0)/HD(1,GPT,D011D782-7E9A-459B-905D-9DA8D6494A53,0x28,0x64000)/EFI\\OC\\OpenCore.efi',
        bluetooth_chipset='BRCM20702 Hub',
        ambient_light_sensor=False,
        third_party_sata_ssd=True,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version='v0.4.11',
        oclp_sys_date='October 06, 2022 @ 10:06:53',
        oclp_sys_url=None,
        firmware_vendor='Apple',
        rosetta_active=False
    )

    Macmini61_Stock = device_probe.Computer(
        real_model='Macmini6,1',
        real_board_id='Mac-031AEE4D24BFF0B1',
        reported_model='Macmini6,1',
        reported_board_id='Mac-031AEE4D24BFF0B1',
        build_model='Macmini6,1',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=358, class_code=196608, name='IGPU', model='Intel HD Graphics 4000', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False)
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=358, class_code=196608, name='IGPU', model='Intel HD Graphics 4000', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
        dgpu=None,
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=7683, class_code=67073, name='SATA', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SATA@1f0002', pci_path='PciRoot(0x0)/Pci(0x1f,0x2)', disable_metal=False, force_compatible=False)
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=7729, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=7725, class_code=787232, name='EHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC2@1a0000', pci_path='PciRoot(0x0)/Pci(0x1a,0x0)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=7718, class_code=787232, name='EHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC1@1d0000', pci_path='PciRoot(0x0)/Pci(0x1d,0x0)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[
            device_probe.SDXCController(vendor_id=5348, device_id=5820, class_code=525569, name='SDXC', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/SDXC@1', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x1)', disable_metal=False, force_compatible=False)
        ],
        ethernet=[
            device_probe.BroadcomEthernet(vendor_id=5348, device_id=5766, class_code=131072, name='GIGE', model='Broadcom 57766-A1', acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/GIGE@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17201, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP02@1c0001/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False
        ),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-3210M CPU @ 2.50GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'EST', 'TM2', 'SSSE3', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=['RDWRFSGS', 'SMEP', 'ERMS', 'MDCLEAR', 'IBRS', 'STIBP', 'L1DF', 'SSBD']
        ),
        oclp_version='0.5.0',
        opencore_version='REL-083-2022-08-01',
        opencore_path='PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0x0,0x0)/HD(1,GPT,B46958E3-7EB7-40C2-BB3A-2C88A0856DC7,0x28,0x64000)/EFI\\OC\\OpenCore.efi',
        bluetooth_chipset='BRCM20702 Hub',
        ambient_light_sensor=False,
        third_party_sata_ssd=True,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version='v0.5.0',
        oclp_sys_date='October 04, 2022 @ 12:24:50',
        oclp_sys_url='',
        firmware_vendor='Apple',
        rosetta_active=False
    )

    Macmini71_Stock = device_probe.Computer(
        real_model='Macmini7,1',
        real_board_id='Mac-35C5E08120C7EEAF',
        reported_model='Macmini7,1',
        reported_board_id='Mac-35C5E08120C7EEAF',
        build_model='Macmini7,1',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=2606, class_code=196608, name='IGPU', model='Intel Iris', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False)
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=2606, class_code=196608, name='IGPU', model='Intel Iris', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)', disable_metal=False, force_compatible=False),
        dgpu=None,
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=39939, class_code=67073, name='SATA', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SATA@1f0002', pci_path='PciRoot(0x0)/Pci(0x1f,0x2)', disable_metal=False, force_compatible=False)
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=39985, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[
            device_probe.SDXCController(vendor_id=5348, device_id=5820, class_code=525569, name='SDXC', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP04@1c0003/SDXC@1', pci_path='PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x1)', disable_metal=False, force_compatible=False)
        ],
        ethernet=[
            device_probe.BroadcomEthernet(vendor_id=5348, device_id=5766, class_code=131072, name='GIGE', model='Broadcom 57766-A1', acpi_path='IOACPIPlane:/_SB/PCI0@0/RP04@1c0003/GIGE@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17312, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP03@1c0002/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-4278U CPU @ 2.60GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=['RDWRFSGS', 'TSC_THREAD_OFFSET', 'BMI1', 'AVX2', 'SMEP', 'BMI2', 'ERMS', 'INVPCID', 'FPU_CSDS', 'MDCLEAR', 'IBRS', 'STIBP', 'L1DF', 'SSBD']
        ),
        oclp_version='0.5.0',
        opencore_version='REL-083-2022-08-01',
        opencore_path='PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0x0,0x0)/HD(1,GPT,293E8ABF-B98C-4258-A811-04464BCA90EF,0x28,0x64000)/EFI\\OC\\OpenCore.efi',
        bluetooth_chipset='BRCM20702 Hub',
        ambient_light_sensor=False,
        third_party_sata_ssd=True,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version='v0.5.0',
        oclp_sys_date='October 04, 2022 @ 12:04:48',
        oclp_sys_url='https://github.com/dortania/OpenCore-Legacy-Patcher/commit/daf28a62effb2ce06a71cb5961c9d0c79d72c16b',
        firmware_vendor='Apple',
        rosetta_active=False
    )

    Macmini81_Stock = device_probe.Computer(
        real_model="Macmini8,1",
        real_board_id="Mac-7BA5B2DFE22DDD8C",
        reported_model="Macmini8,1",
        reported_board_id="Mac-7BA5B2DFE22DDD8C",
        gpus=[device_probe.Intel(vendor_id=32902, device_id=16027, class_code=196608, name="IGPU", model="Intel UHD Graphics 630", pci_path="PciRoot(0x0)/Pci(0x2,0x0)")],
        igpu=device_probe.Intel(vendor_id=32902, device_id=16027, class_code=196608, name="IGPU", model="Intel UHD Graphics 630", pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
        dgpu=None,
        storage=[],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17508, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "PCLMULQDQ", "DTES64", "MON", "DSCPL", "VMX", "SMX", "EST", "TM2", "SSSE3", "FMA", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "x2APIC", "MOVBE", "POPCNT", "AES", "PCID", "XSAVE", "OSXSAVE", "SEGLIM64", "TSCTMR", "AVX1.0", "RDRAND", "F16C"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None
    )

    Macmini91_Stock = device_probe.Computer(
        # Run under Rosetta
        real_model="Macmini9,1",
        real_board_id="J274",
        reported_model="Macmini9,1",
        reported_board_id="J274",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=26640, class_code=196608, name="display", model="Unknown Unknown", pci_path="", )
        ],
        igpu=None,
        dgpu=None,
        storage=[],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17445, class_code=163840, name="wlan", model=None, pci_path=""),
        cpu=device_probe.CPU(
            name="Apple M1",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "PCLMULQDQ", "DTSE64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "AES", "SEGLIM64"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None
    )

class iMac:

    iMac81_Stock = device_probe.Computer(
        # Stock Model
        real_model="iMac8,1",
        real_board_id="Mac-F226BEC8",
        reported_model="iMac8,1",
        reported_board_id="Mac-F226BEC8",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=38088, class_code=196608, name="GFX0", model="ATI Radeon HD 2400", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)")
        ],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=38088, class_code=196608, name="GFX0", model="ATI Radeon HD 2400", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=10281, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17192, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x4)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Core(TM)2 Duo CPU     E8135  @ 2.40GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    iMac112_Stock = device_probe.Computer(
        # Stock Model
        real_model="iMac11,2",
        real_board_id="Mac-F2238AC8",
        reported_model="iMac11,2",
        reported_board_id="Mac-F2238AC8",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=38024, class_code=196608, name="GFX0", model="ATI Radeon HD 4670", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)")
        ],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=38024, class_code=196608, name="GFX0", model="ATI Radeon HD 4670", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=15138, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Atheros(vendor_id=5772, device_id=42, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Core(TM) i3 CPU         540  @ 3.07GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "POPCNT", "PCID"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    iMac122_Upgraded = device_probe.Computer(
        real_model="iMac12,2",
        real_board_id="Mac-942B59F58194171B",
        reported_model="iMac12,2",
        reported_board_id="Mac-942B59F58194171B",
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=258, class_code=196608, name="HD Graphics 3000", model=None, pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
            device_probe.AMD(vendor_id=4098, device_id=26600, class_code=196608, name="GFX0", model="Radeon Pro WX4130", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"),
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=258, class_code=196608, name="HD Graphics 3000", model=None, pci_path="PciRoot(0x0)/Pci(0x2,0x0)"),
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26600, class_code=196608, name="GFX0", model="Radeon Pro WX4130", pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=7170, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17338, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "PCLMULQDQ", "DTES64", "MON", "DSCPL", "VMX", "SMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "xAPIC", "POPCNT", "AES", "PCID", "XSAVE", "OSXSAVE", "TSCTMR", "AVX1.0"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    iMac122_Upgraded_Nvidia = device_probe.Computer(
        real_model='iMac12,2',
        real_board_id='Mac-942B59F58194171B',
        reported_model='iMac12,2',
        reported_board_id='Mac-942B59F58194171B',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=258, class_code=229376, name='IGPU',  model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
            device_probe.NVIDIA(vendor_id=4318, device_id=4092, class_code=196608, name='GFX0', model='Quadro K1000M by Nick[D]vB', acpi_path='IOACPIPlane:/_SB/PCI0@0/P0P2@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)')],
        igpu=device_probe.Intel(vendor_id=32902, device_id=258, class_code=229376, name='IGPU', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
        dgpu=device_probe.NVIDIA(vendor_id=4318, device_id=4092, class_code=196608, name='GFX0', model='Quadro K1000M by Nick[D]vB', acpi_path='IOACPIPlane:/_SB/PCI0@0/P0P2@10000/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)'),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=7170, class_code=67073, name='SATA', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SATA@1f0002', pci_path='PciRoot(0x0)/Pci(0x1f,0x2)')
        ],
        usb_controllers=[
            device_probe.EHCIController(vendor_id=32902, device_id=7213, class_code=787232, name='EHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC2@1a0007', pci_path='PciRoot(0x0)/Pci(0x1a,0x7)'),
            device_probe.EHCIController(vendor_id=32902, device_id=7206, class_code=787232, name='EHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC1@1d0007', pci_path='PciRoot(0x0)/Pci(0x1d,0x7)')
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17201, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP02@1c0001/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)'),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i7-2600 CPU @ 3.40GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'TSCTMR', 'AVX1.0'],
            leafs=[],
        ),
        oclp_version='0.3.3',
        opencore_version=None,
        bluetooth_chipset='BRCM2046 Hub',
        third_party_sata_ssd=True
    )

    iMac151_Stock = device_probe.Computer(
        real_model='iMac15,1',
        real_board_id='Mac-42FD25EABCABB274',
        reported_model='iMac15,1',
        reported_board_id='Mac-42FD25EABCABB274',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=1042, class_code=196608, name='IGPU', model='Intel Iris Pro', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
            device_probe.AMD(vendor_id=4098, device_id=26640, class_code=196608, name='GFX0', model='AMD Radeon R9 M290X', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)')
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=1042, class_code=196608, name='IGPU', model='Intel Iris Pro', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26640, class_code=196608, name='GFX0', model='AMD Radeon R9 M290X', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)'),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=35842, class_code=67073, name='SATA', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1f,0x2)'),
            device_probe.SATAController(vendor_id=6987, device_id=37251, class_code=67073, name='SSD0', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)')
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17312, class_code=163840, name='ARPT', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)'),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-4690 CPU @ 3.50GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
        bluetooth_chipset='BRCM20702 Hub',
        third_party_sata_ssd=False
    )

    iMac201_Stock = device_probe.Computer(
        real_model='iMac20,1',
        real_board_id='Mac-CFF7D910A743CAAF',
        reported_model='iMac20,1',
        reported_board_id='Mac-CFF7D910A743CAAF',
        gpus=[
            device_probe.Intel(vendor_id=32902, device_id=39880, class_code=196608, name='IGPU', model='Intel HD Graphics CFL', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
            device_probe.AMD(vendor_id=4098, device_id=29504, class_code=196608, name='GFX0', model='AMD Radeon Pro 5300', acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG0@10000/EGP0@0/EGP1@0/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)')
        ],
        igpu=device_probe.Intel(vendor_id=32902, device_id=39880, class_code=196608, name='IGPU', model='Intel HD Graphics CFL', acpi_path='IOACPIPlane:/_SB/PCI0@0/IGPU@20000', pci_path='PciRoot(0x0)/Pci(0x2,0x0)'),
        dgpu=device_probe.AMD(vendor_id=4098, device_id=29504, class_code=196608, name='GFX0', model='AMD Radeon Pro 5300', acpi_path='IOACPIPlane:/_SB/PCI0@0/PEG0@10000/EGP0@0/EGP1@0/GFX0@0', pci_path='PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)'),
        storage=[],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=32902, device_id=1773, class_code=787248, name='XHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/XHC1@140000', pci_path='PciRoot(0x0)/Pci(0x14,0x0)'),
            device_probe.XHCIController(vendor_id=32902, device_id=5612, class_code=787248, name='XHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP05@1c0004/UPSB@0/DSB2@20000/XHC2@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x4)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)')
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17508, class_code=163840, name='ARPT', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/RP01@1c0000/ARPT@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)'),
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i5-10500 CPU @ 3.10GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'FMA', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'PCID', 'XSAVE', 'OSXSAVE', 'SEGLIM64', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
        bluetooth_chipset=None,
        third_party_sata_ssd=False
    )

class MacPro:

    MacPro31_Stock = device_probe.Computer(
        # Stock Model, stock TS1 GPU and no Wifi card
        real_model="MacPro3,1",
        real_board_id="Mac-F42C88C8",
        reported_model="MacPro3,1",
        reported_board_id="Mac-F42C88C8",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=38272, class_code=196608, name="GFX0", model="ATI Radeon HD 2600", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)")
        ],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=38272, class_code=196608, name="GFX0", model="ATI Radeon HD 2600", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=9857, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=None,
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           X5482  @ 3.20GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    MacPro31_Upgrade = device_probe.Computer(
        # Upgraded Model, TS2 GPU and El-Capitan era Wifi card
        real_model="MacPro3,1",
        real_board_id="Mac-F42C88C8",
        reported_model="MacPro3,1",
        reported_board_id="Mac-F42C88C8",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=26808, class_code=196608, name="GFX0", model="ATI Radeon HD 5770", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)")
        ],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26808, class_code=196608, name="GFX0", model="ATI Radeon HD 5770", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=9857, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Broadcom(
            vendor_id=5348, device_id=17192, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x0)"
        ),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           X5482  @ 3.20GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    MacPro31_Modern_AMD = device_probe.Computer(
        # Upgraded Model, Polaris GPU and BCM94360CD
        real_model="MacPro3,1",
        real_board_id="Mac-F42C88C8",
        reported_model="MacPro3,1",
        reported_board_id="Mac-F42C88C8",
        gpus=[
            device_probe.AMD(vendor_id=4098, device_id=26591, class_code=196608, name="GFX0", model="Radeon RX 470/570", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)")
        ],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26591, class_code=196608, name="GFX0", model="Radeon RX 470/570", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=9857, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Broadcom(
            vendor_id=5348, device_id=17312, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x0)"
        ),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           X5482  @ 3.20GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    MacPro31_Modern_Kepler = device_probe.Computer(
        # Upgraded Model, Kepler GPU and BCM94360CD
        real_model="MacPro3,1",
        real_board_id="Mac-F42C88C8",
        reported_model="MacPro3,1",
        reported_board_id="Mac-F42C88C8",
        gpus=[device_probe.NVIDIA(vendor_id=4318, device_id=4737, class_code=196608, name="GFX0", model="NVIDIA GeForce GT 710", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)")],
        igpu=None,
        dgpu=device_probe.NVIDIA(vendor_id=4318, device_id=4737, class_code=196608, name="GFX0", model="NVIDIA GeForce GT 710", pci_path="PciRoot(0x0)/Pci(0x5,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=9857, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")
        ],
        wifi=device_probe.Broadcom(
            vendor_id=5348, device_id=17312, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x0)"
        ),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           X5482  @ 3.20GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None,
    )

    MacPro41_Upgrade = device_probe.Computer(
        # Upgraded model with AMD HD7950, Atheros PCIe card
        real_model="MacPro4,1",
        real_board_id="Mac-F221BEC8",
        reported_model="MacPro4,1",
        reported_board_id="Mac-F221BEC8",
        gpus=[device_probe.AMD(vendor_id=4098, device_id=26522, class_code=196608, name="PXS1", model="AMD Radeon HD 7950", pci_path="PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)")],
        igpu=None,
        dgpu=None,
        storage=[device_probe.SATAController(vendor_id=32902, device_id=14882, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)")],
        wifi=device_probe.Atheros(vendor_id=5772, device_id=48, class_code=163840, name="PXS4", model=None, pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x4,0x0)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           W3520  @ 2.67GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "POPCNT"],
            leafs=[],
        ),
        oclp_version=None,
        opencore_version=None
    )

    MacPro41_Modern_AMD = device_probe.Computer(
        # Upgraded model with AMD RX470, BCM94360CD, Intel 660p
        # Booted through OpenCore
        real_model="MacPro4,1",
        real_board_id="Mac-F221BEC8",
        reported_model="MacPro4,1",
        reported_board_id="Mac-27AD2F918AE68F61",
        gpus=[device_probe.AMD(vendor_id=4098, device_id=26591, class_code=196608, name="GFX0", model="Radeon RX 470/570", pci_path="PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)")],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=26591, class_code=196608, name="GFX0", model="Radeon RX 470/570", pci_path="PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=14882, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)"),
            device_probe.NVMeController(vendor_id=32902, device_id=61864, class_code=67586, name="PXS3", model=None, pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)", aspm=2)
        ],
        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17312, class_code=163840, name="ARPT", model=None, pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x4,0x0)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           W3520  @ 2.67GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "DTES64", "MON", "DSCPL", "VMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "POPCNT"],
            leafs=[],
        ),
        oclp_version="0.2.5",
        opencore_version="REL-071-2021-07-02"
    )

    MacPro41_51__Flashed_Modern_AMD = device_probe.Computer(
        # 4,1 flashed to 5,1, RX5700XT, BCM94360CD, WD SN750 NVMe
        real_model="MacPro5,1",
        real_board_id="Mac-F221BEC8",
        reported_model="MacPro5,1",
        reported_board_id="Mac-F221BEC8",
        gpus=[device_probe.AMD(vendor_id=4098, device_id=29471, class_code=196608, name="GFX0", model="AMD Radeon RX 5700 XT", pci_path="PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)")],
        igpu=None,
        dgpu=device_probe.AMD(vendor_id=4098, device_id=29471, class_code=196608, name="GFX0", model="AMD Radeon RX 5700 XT", pci_path="PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)"),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=14882, class_code=67073, name="SATA", model=None, pci_path="PciRoot(0x0)/Pci(0x1f,0x2)"),
            device_probe.NVMeController(vendor_id=5559, device_id=20482, class_code=67586, name="PXS3", model=None, pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x2,0x0)/Pci(0x0,0x0)", aspm=2)
        ],

        wifi=device_probe.Broadcom(vendor_id=5348, device_id=17312, class_code=163840, name="PXS4", model=None, pci_path="PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x4,0x0)/Pci(0x0,0x0)"),
        cpu=device_probe.CPU(
            name="Intel(R) Xeon(R) CPU           X5670  @ 2.93GHz",
            flags=["FPU", "VME", "DE", "PSE", "TSC", "MSR", "PAE", "MCE", "CX8", "APIC", "SEP", "MTRR", "PGE", "MCA", "CMOV", "PAT", "PSE36", "CLFSH", "DS", "ACPI", "MMX", "FXSR", "SSE", "SSE2", "SS", "HTT", "TM", "PBE", "SSE3", "PCLMULQDQ", "DTES64", "MON", "DSCPL", "VMX", "SMX", "EST", "TM2", "SSSE3", "CX16", "TPR", "PDCM", "SSE4.1", "SSE4.2", "POPCNT", "AES", "PCID"],
            leafs=[],
        ),
        oclp_version="0.2.5",
        opencore_version="REL-071-2021-07-02"
    )

    MacPro41_51_Flashed_NVIDIA_WEB_DRIVERS = device_probe.Computer(
        real_model='MacPro5,1',
        real_board_id='Mac-F221BEC8',
        reported_model='MacPro5,1',
        reported_board_id='Mac-F221BEC8',
        build_model='MacPro5,1',
        gpus=[
            device_probe.NVIDIA(vendor_id=4318, device_id=5051, class_code=196608, name='GFX0', model='NVIDIA Quadro K620', acpi_path='IOACPIPlane:/_SB/PCI0@0/IOU0@30000/PXS1@ffff', pci_path='PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)', disable_metal=True, force_compatible=True)
        ],
        igpu=None,
        dgpu=device_probe.NVIDIA(vendor_id=4318, device_id=5051, class_code=196608, name='GFX0', model='NVIDIA Quadro K620', acpi_path='IOACPIPlane:/_SB/PCI0@0/IOU0@30000/PXS1@ffff', pci_path='PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)', disable_metal=True, force_compatible=True),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=14882, class_code=67073, name='SATA', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SATA@1f0002', pci_path='PciRoot(0x0)/Pci(0x1f,0x2)', disable_metal=False, force_compatible=False)
        ],
        usb_controllers=[
            device_probe.EHCIController(vendor_id=32902, device_id=14908, class_code=787232, name='EHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC2@1a0007', pci_path='PciRoot(0x0)/Pci(0x1a,0x7)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=14906, class_code=787232, name='EHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/EHC1@1d0007', pci_path='PciRoot(0x0)/Pci(0x1d,0x7)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14903, class_code=787200, name='UHC4', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC4@1a0000', pci_path='PciRoot(0x0)/Pci(0x1a,0x0)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14904, class_code=787200, name='UHC5', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC5@1a0001', pci_path='PciRoot(0x0)/Pci(0x1a,0x1)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14905, class_code=787200, name='UHC6', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC6@1a0002', pci_path='PciRoot(0x0)/Pci(0x1a,0x2)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14900, class_code=787200, name='UHC1', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC1@1d0000', pci_path='PciRoot(0x0)/Pci(0x1d,0x0)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14901, class_code=787200, name='UHC2', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC2@1d0001', pci_path='PciRoot(0x0)/Pci(0x1d,0x1)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=14902, class_code=787200, name='UHC3', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/UHC3@1d0002', pci_path='PciRoot(0x0)/Pci(0x1d,0x2)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[],
        ethernet=[
            device_probe.IntelEthernet(vendor_id=32902, device_id=4342, class_code=131072, name='ETH1', model='Intel 82574L', acpi_path='IOACPIPlane:/_SB/PCI0@0/RP04@1c0003/ETH1@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x3)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
            device_probe.IntelEthernet(vendor_id=32902, device_id=4342, class_code=131072, name='ETH0', model='Intel 82574L', acpi_path='IOACPIPlane:/_SB/PCI0@0/RP03@1c0002/ETH0@0', pci_path='PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        wifi=None,
        cpu=device_probe.CPU(
            name='Intel(R) Xeon(R) CPU           X5670  @ 2.93GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'DS', 'ACPI', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'TM', 'PBE', 'SSE3', 'PCLMULQDQ', 'DTES64', 'MON', 'DSCPL', 'VMX', 'SMX', 'EST', 'TM2', 'SSSE3', 'CX16', 'TPR', 'PDCM', 'SSE4.1', 'SSE4.2', 'POPCNT', 'AES', 'PCID'],
            leafs=[],
        ),
        oclp_version='0.4.6',
        opencore_version='REL-080-2022-04-18',
        opencore_path='PciRoot(0x0)/Pci(0x1D,0x7)/USB(0x4,0x0)/HD(2,GPT,AEC1E933-C311-40E2-BBCE-FC4B14BCD770,0x64800,0x38E3000)/EFI\\OC\\OpenCore.efi',
        bluetooth_chipset='BRCM2046 Hub',
        ambient_light_sensor=False,
        third_party_sata_ssd=True,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version='v0.4.6',
        oclp_sys_date='September 03, 2019 @ 23:13:43',
        firmware_vendor='Apple'
    )


class Hackintosh:

    QEMU_Virtual_Machine_GT710 = device_probe.Computer(
        real_model='iMac14,4',
        real_board_id='Mac-81E3E92DD6088272',
        reported_model='iMac14,4',
        reported_board_id='Mac-81E3E92DD6088272',
        build_model=None,
        gpus=[
            device_probe.NVIDIA(vendor_id=4318, device_id=4747, class_code=196608, name='GFX0', model='NVIDIA GeForce GT 710', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False)
        ],
        igpu=None,
        dgpu=device_probe.NVIDIA(vendor_id=4318, device_id=4747, class_code=196608, name='GFX0', model='NVIDIA GeForce GT 710', acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x0)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
        storage=[
            device_probe.SATAController(vendor_id=32902, device_id=10530, class_code=67073, name='pci8086,2922', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1f,0x2)', disable_metal=False, force_compatible=False),
            device_probe.SATAController(vendor_id=32902, device_id=10530, class_code=67073, name='pci8086,2922', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1e,0x0)/Pci(0x1,0x0)/Pci(0x7,0x0)', disable_metal=False, force_compatible=False),
            device_probe.NVMeController(vendor_id=5197, device_id=43016, class_code=67586, name='pci144d,a808', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x1)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False, aspm=0)
        ],
        usb_controllers=[
            device_probe.XHCIController(vendor_id=6945, device_id=8514, class_code=787248, name='pci1b21,2142', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1c,0x2)/Pci(0x0,0x0)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=10556, class_code=787232, name='pci8086,293c', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1a,0x7)', disable_metal=False, force_compatible=False),
            device_probe.EHCIController(vendor_id=32902, device_id=10554, class_code=787232, name='pci8086,293a', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1d,0x7)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10551, class_code=787200, name='SD0', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SD0@1a0000', pci_path='PciRoot(0x0)/Pci(0x1a,0x0)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10552, class_code=787200, name='pci8086,2938', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1a,0x1)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10553, class_code=787200, name='pci8086,2939', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1a,0x2)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10548, class_code=787200, name='SE8', model=None, acpi_path='IOACPIPlane:/_SB/PCI0@0/SE8@1d0000', pci_path='PciRoot(0x0)/Pci(0x1d,0x0)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10549, class_code=787200, name='pci8086,2935', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1d,0x1)', disable_metal=False, force_compatible=False),
            device_probe.UHCIController(vendor_id=32902, device_id=10550, class_code=787200, name='pci8086,2936', model=None, acpi_path=None, pci_path='PciRoot(0x0)/Pci(0x1d,0x2)', disable_metal=False, force_compatible=False)
        ],
        sdxc_controller=[],
        ethernet=[],
        wifi=None,
        cpu=device_probe.CPU(
            name='Intel(R) Core(TM) i9-7920X CPU @ 2.90GHz',
            flags=['FPU', 'VME', 'DE', 'PSE', 'TSC', 'MSR', 'PAE', 'MCE', 'CX8', 'APIC', 'SEP', 'MTRR', 'PGE', 'MCA', 'CMOV', 'PAT', 'PSE36', 'CLFSH', 'MMX', 'FXSR', 'SSE', 'SSE2', 'SS', 'HTT', 'SSE3', 'PCLMULQDQ', 'VMX', 'SSSE3', 'FMA', 'CX16', 'PDCM', 'SSE4.1', 'SSE4.2', 'x2APIC', 'MOVBE', 'POPCNT', 'AES', 'VMM', 'PCID', 'XSAVE', 'OSXSAVE', 'TSCTMR', 'AVX1.0', 'RDRAND', 'F16C'],
            leafs=['RDWRFSGS', 'TSC_THREAD_OFFSET', 'BMI1', 'HLE', 'AVX2', 'SMEP', 'BMI2', 'ERMS', 'INVPCID', 'RTM', 'MPX', 'AVX512F', 'AVX512DQ', 'RDSEED', 'ADX', 'SMAP', 'CLFSOPT', 'CLWB', 'AVX512CD', 'AVX512BW', 'AVX512VL', 'UMIP', 'MDCLEAR', 'IBRS', 'STIBP', 'ACAPMSR', 'SSBD']
        ),
        oclp_version=None,
        opencore_version='REL-083-2022-08-01',
        opencore_path=None,
        bluetooth_chipset=None,
        ambient_light_sensor=False,
        third_party_sata_ssd=False,
        secure_boot_model='x86legacyap',
        secure_boot_policy=0,
        oclp_sys_version=None,
        oclp_sys_date=None,
        oclp_sys_url=None,
        firmware_vendor='EDK II',
        rosetta_active=False
    )

"""
model_array.py: Datasets for different models
"""


SupportedSMBIOS = [
    # MacBook
    "MacBook5,1",
    "MacBook5,2",
    "MacBook6,1",
    "MacBook7,1",
    "MacBook8,1",
    "MacBook9,1",
    "MacBook10,1",
    # MacBook Air
    "MacBookAir2,1",
    "MacBookAir3,1",
    "MacBookAir3,2",
    "MacBookAir4,1",
    "MacBookAir4,2",
    "MacBookAir5,1",
    "MacBookAir5,2",
    "MacBookAir6,1",
    "MacBookAir6,2",
    "MacBookAir7,1",
    "MacBookAir7,2",
    # "MacBookAir8,1",
    # "MacBookAir8,2",
    # MacBook Pro
    "MacBookPro4,1",
    "MacBookPro5,1",
    "MacBookPro5,2",
    "MacBookPro5,3",
    "MacBookPro5,4",
    "MacBookPro5,5",
    "MacBookPro6,1",
    "MacBookPro6,2",
    "MacBookPro7,1",
    "MacBookPro8,1",
    "MacBookPro8,2",
    "MacBookPro8,3",
    "MacBookPro9,1",
    "MacBookPro9,2",
    "MacBookPro10,1",
    "MacBookPro10,2",
    "MacBookPro11,1",
    "MacBookPro11,2",
    "MacBookPro11,3",
    "MacBookPro11,4",
    "MacBookPro11,5",
    "MacBookPro12,1",
    "MacBookPro13,1",
    "MacBookPro13,2",
    "MacBookPro13,3",
    "MacBookPro14,1",
    "MacBookPro14,2",
    "MacBookPro14,3",
    # Mac Mini
    "Macmini3,1",
    "Macmini4,1",
    "Macmini5,1",
    "Macmini5,2",
    "Macmini5,3",
    "Macmini6,1",
    "Macmini6,2",
    "Macmini7,1",
    # iMac
    "iMac7,1",
    "iMac8,1",
    "iMac9,1",
    "iMac10,1",
    "iMac11,1",
    "iMac11,2",
    "iMac11,3",
    "iMac12,1",
    "iMac12,2",
    "iMac13,1",
    "iMac13,2",
    "iMac13,3",
    "iMac14,1",
    "iMac14,2",
    "iMac14,3",
    "iMac14,4",
    "iMac15,1",
    "iMac16,1",
    "iMac16,2",
    "iMac17,1",
    "iMac18,1",
    "iMac18,2",
    "iMac18,3",
    # Mac Pro
    "MacPro3,1",
    "MacPro4,1",
    "MacPro5,1",
    "MacPro6,1",
    # Xserve
    "Xserve2,1",
    "Xserve3,1",
]

# Audio

LegacyAudio = [
    "MacBook5,1",
    "MacBook5,2",
    "MacBook6,1",
    "MacBook7,1",
    "MacBookAir2,1",
    "MacBookAir3,1",
    "MacBookAir3,2",
    "MacBookAir4,1",
    "MacBookAir4,2",
    "MacBookPro4,1",
    "MacBookPro5,1",
    "MacBookPro5,2",
    "MacBookPro5,3",
    "MacBookPro5,4",
    "MacBookPro5,5",
    "MacBookPro6,1",
    "MacBookPro6,2",
    "MacBookPro7,1",
    "MacBookPro8,1",
    "MacBookPro8,2",
    "MacBookPro8,3",
    "Macmini3,1",
    "Macmini4,1",
    "Macmini5,1",
    "Macmini5,2",
    "Macmini5,3",
    # "iMac7,1",
    # "iMac8,1",
    "iMac9,1",
    "iMac10,1",
    "iMac11,1",
    "iMac11,2",
    "iMac11,3",
    "iMac12,1",
    "iMac12,2",
    "MacPro3,1",
    "Dortania1,1",
]

# GPU

ModernGPU = [
    "MacBook8,1", # Intel 6000
    "MacBook9,1", # Intel Skylake
    "MacBookAir5,1",  # Intel 4000
    "MacBookAir5,2",  # Intel 4000
    "MacBookAir6,1",  # Intel 5000
    "MacBookAir6,2",  # Intel 5000
    "MacBookAir7,1",  # Intel 6000
    "MacBookAir7,2",  # Intel 6000
    "MacBookPro9,1",  # Intel 4000 + Nvidia 650M
    "MacBookPro9,2",  # Intel 4000
    "MacBookPro10,1",  # Intel 4000 + Nvidia 650M
    "MacBookPro10,2",  # Intel 4000
    "MacBookPro11,1",  # Intel 5000
    "MacBookPro11,2",  # Intel 5000
    "MacBookPro11,3",  # Intel 5000 + Nvidia Kepler
    "MacBookPro11,4",  # Intel 5000
    "MacBookPro11,5",  # Intel 5000 + GCN 1
    "MacBookPro12,1",  # Intel 6000
    "MacBookPro13,1",  # Intel Skylake
    "MacBookPro13,2",  # Intel Skylake
    "MacBookPro13,3",  # Intel Skylake
    "Macmini6,1",  # Intel 4000
    "Macmini6,2",  # Intel 4000
    "Macmini7,1",  # Intel 5000
    "iMac13,1",  # Intel 4000
    "iMac13,2",  # Intel 4000 + Nvidia Kepler
    "iMac13,3",  # Intel 4000
    "iMac14,1",  # Intel 5000 + Nvidia Kepler
    "iMac14,2",  # Intel 5000 + Nvidia Kepler
    "iMac14,3",  # Intel 5000 + Nvidia Kepler
    "iMac14,4",  # Intel 5000
    "iMac15,1",  # Intel 5000 + GCN 1
    "iMac16,1",  # Intel 6000
    "iMac16,2",  # Intel 6000
    "iMac17,1",  # Intel Skylake + GCN1
    "MacPro3,1", # Lacks AVX2.0
    "MacPro4,1", # Lacks AVX2.0
    "MacPro5,1", # Lacks AVX2.0
    "MacPro6,1", # GCN 1
]

LegacyGPU = [
    "MacBook5,1",  # Nvidia 9000
    "MacBook5,2",  # Nvidia 9000
    "MacBook6,1",  # Nvidia 9000
    "MacBook7,1",  # Nvidia 300
    "MacBookAir2,1",  # Nvidia 9000
    "MacBookAir3,1",  # Nvidia 300
    "MacBookAir3,2",  # Nvidia 300
    "MacBookAir4,1",  # Intel 3000
    "MacBookAir4,2",  # Intel 3000
    "MacBookPro4,1",  # Nvidia 8000
    "MacBookPro5,1",  # Nvidia 9000
    "MacBookPro5,2",  # Nvidia 9000
    "MacBookPro5,3",  # Nvidia 9000
    "MacBookPro5,4",  # Nvidia 9000
    "MacBookPro5,5",  # Nvidia 9000
    "MacBookPro6,1",  # Intel 100 + Nvidia 300
    "MacBookPro6,2",  # Intel 100 + Nvidia 300
    "MacBookPro7,1",  # Nvidia 300
    "MacBookPro8,1",  # Intel 3000
    "MacBookPro8,2",  # Intel 3000 + AMD 6000
    "MacBookPro8,3",  # Intel 3000 + AMD 6000
    "Macmini3,1",  # Nvidia 9000
    "Macmini4,1",  # Nvidia 300
    "Macmini5,1",  # Intel 3000
    "Macmini5,2",  # AMD 6000
    "Macmini5,3",  # Intel 3000
    "iMac7,1",  # AMD 2000
    "iMac8,1",  # Nvidia and AMD 2400
    "iMac9,1",  # Nvidia 9000
    "iMac10,1",  # Nvidia 9000 and AMD 4000
    "iMac11,1",  # AMD 4000
    "iMac11,2",  # AMD 4000 and 5000
    "iMac11,3",  # AMD 5000
    "iMac12,1",  # AMD 6000
    "iMac12,2",  # AMD 6000
    "Dortania1,1",  # RTX 3080
]

LegacyBrightness = [
    "MacBook5,2",
    "iMac7,1",
    "iMac8,1",
    "iMac9,1",
]

DualGPUPatch = [
    "MacBookPro5,1",
    "MacBookPro5,2",
    "MacBookPro5,3",
    "MacBookPro6,1",
    "MacBookPro6,2",
    "MacBookPro8,2",
    "MacBookPro8,3",
    "Macmini5,2",
    "iMac12,1",
    "iMac12,2",
    "iMac13,1",
    "iMac13,2",
    "iMac14,2",
    "iMac14,3",
    "Dortania1,1",
]

IntelNvidiaDRM = [
    "iMac13,1",
    "iMac13,2",
    "iMac14,2",
    "iMac14,3",
]

# Mac Pro and Xserve
MacPro = ["MacPro3,1", "MacPro4,1", "MacPro5,1", "Xserve2,1", "Xserve3,1", "Dortania1,1"]

# MXM iMac
MXMiMac = ["iMac11,1", "iMac11,2", "iMac11,3", "iMac10,1", "iMac12,1", "iMac12,2", "Dortania1,1"]

NoAGPMSupport = ["MacBookPro4,1", "iMac7,1", "iMac8,1", "MacPro3,1", "Xserve2,1", "Dortania1,1"]

AGDPSupport = [
    "MacBookPro9,1",
    "MacBookPro10,1",
    "iMac13,1",
    "iMac13,2",
    "iMac14,1",
    "iMac14,2",
    "iMac14,3",
    "iMac14,4",
    "iMac15,1",
    # TODO: Uncomment when dropped from macOS
    # "iMac17,1",
    # "iMac18,2",
    # "iMac18,3",
    # "iMac19,1",
    # "iMac19,2",
    # "iMac20,1",
    # "iMac20,2",
    # "iMacPro1,1",
    # "MacPro6,1",
]

Missing_USB_Map = [
    "MacBook5,1",
    "MacBook5,2",
    "MacBook6,1",
    "MacBook7,1",
    "MacBookAir2,1",
    "MacBookAir3,1",
    "MacBookAir3,2",
    "MacBookAir4,1",
    "MacBookAir4,2",
    "MacBookPro4,1",
    "MacBookPro5,1",
    "MacBookPro5,2",
    "MacBookPro5,3",
    "MacBookPro5,4",
    "MacBookPro5,5",
    "MacBookPro6,1",
    "MacBookPro6,2",
    "MacBookPro7,1",
    "MacBookPro8,1",
    "MacBookPro8,2",
    "MacBookPro8,3",
    "Macmini3,1",
    "Macmini4,1",
    "Macmini5,1",
    "Macmini5,2",
    "Macmini5,3",
    "iMac7,1",
    "iMac8,1",
    "iMac9,1",
    "iMac10,1",
    "iMac11,1",
    "iMac11,2",
    "iMac11,3",
    "iMac12,1",
    "iMac12,2",
    "MacPro3,1",
    "MacPro4,1",
    "Xserve2,1",
    "Xserve3,1",
]

Missing_USB_Map_Ventura = [
    "MacBook8,1",
    "MacBookAir5,1",
    "MacBookAir5,2",
    "MacBookAir6,1",
    "MacBookAir6,2",
    "MacBookAir7,1",
    "MacBookAir7,2",
    "MacBookPro9,1",
    "MacBookPro9,2",
    "MacBookPro10,1",
    "MacBookPro10,2",
    "MacBookPro11,1",
    "MacBookPro11,2",
    "MacBookPro11,3",
    "MacBookPro11,4",
    "MacBookPro11,5",
    "MacBookPro12,1",
    "MacPro5,1",
    "MacPro6,1",
    "Macmini6,1",
    "Macmini6,2",
    "Macmini7,1",
    "iMac13,1",
    "iMac13,2",
    "iMac14,1",
    "iMac14,2",
    "iMac14,3",
    "iMac14,4",
    "iMac15,1",
    "iMac15,2",
    "iMac16,1",
    "iMac16,2",
    "iMac17,1",
]


"""
os_data.py: OS Version Data
"""

import enum

from curses.ascii import isdigit


class os_data(enum.IntEnum):
    # OS Versions, Based off Major Kernel Version
    cheetah =       4 # Actually 1.3.1
    puma =          5
    jaguar =        6
    panther =       7
    tiger =         8
    leopard =       9
    snow_leopard =  10
    lion =          11
    mountain_lion = 12
    mavericks =     13
    yosemite =      14
    el_capitan =    15
    sierra =        16
    high_sierra =   17
    mojave =        18
    catalina =      19
    big_sur =       20
    monterey =      21
    ventura =       22
    sonoma =        23
    sequoia =       24
    max_os =        99


class os_conversion:

    def os_to_kernel(os: str) -> int:
        """
        Convert OS version to major XNU version

        Parameters:
            os (str): OS version

        Returns:
            int: Major XNU version
        """
        if os.startswith("10."):
            return (int(os.split(".")[1]) + 4)
        else:
            return (int(os.split(".")[0]) + 9)


    def kernel_to_os(kernel: int) -> str:
        """
        Convert major XNU version to OS version

        Parameters:
            kernel (int): Major XNU version

        Returns:
            str: OS version
        """
        if kernel >= os_data.big_sur:
            return str((kernel - 9))
        else:
            return str((f"10.{kernel - 4}"))


    def is_os_newer(source_major: int, source_minor: int, target_major: int, target_minor: int) -> bool:
        """
        Check if OS version 1 is newer than OS version 2

        Parameters:
            source_major (int): Major XNU version of OS version 1
            source_minor (int): Minor XNU version of OS version 1
            target_major (int): Major XNU version of OS version 2
            target_minor (int): Minor XNU version of OS version 2

        Returns:
            bool: True if OS version 1 is newer than OS version 2
        """
        if source_major < target_major:
            return True
        elif source_major == target_major:
            if source_minor < target_minor:
                return True
            else:
                return False


    def convert_kernel_to_marketing_name(kernel: int) -> str:
        """
        Convert major XNU version to Marketing name

        Parameters:
            kernel (int): Major XNU version

        Returns:
            str: Marketing name of OS
        """
        try:
            # Find os_data enum name
            os_name = os_data(kernel).name

            # Remove "_" from the string
            os_name = os_name.replace("_", " ")

            # Upper case the first letter of each word
            os_name = os_name.title()
        except ValueError:
            # Handle cases where no enum value exists
            # Pass kernel_to_os() as a substitute for a proper OS name
            os_name = os_conversion.kernel_to_os(kernel)

        return os_name


    def convert_marketing_name_to_kernel(marketing_name: str) -> int:
        """
        Convert Marketing Name to major XNU version

        Parameters:
            marketing_name (str): Marketing Name of OS

        Returns:
            int: Major XNU version
        """
        try:
            # Find os_data enum value
            os_kernel = os_data[marketing_name.lower().replace(" ", "_")]
        except KeyError:
            os_kernel = 0

        return int(os_kernel)


    def find_largest_build(build_array: list) -> str:
        """
        Find the newest version within an array of versions
        These builds will have both numbers and letters in the version
        ex:
        [
            "22A5295i",
            "22A5266r",
            "22A5286j",
            "22A5295h",
        ]
        """

        max_length =        0  # Length of the longest build
        build_array_split = [] # 'build_array', converted into individual array of elements
        final_build =       "" # Largest determined build


        # Convert strings to arrays
        for build in build_array:
            list_build = list(build)
            if len(list_build) > max_length:
                max_length = len(list_build)
            build_array_split.append(list_build)

        # Pad out each array to same length
        for build in build_array_split:
            while len(build) < max_length:
                build.append("0")

        # Convert all letters to int using ord()
        for build in build_array_split:
            for entry in build:
                if not entry.isdigit():
                    build[build.index(entry)] = ord(entry)

        for build_outer_loop in build_array_split:
            for build_inner_loop in list(build_array_split):
                for i in range(len(build_outer_loop)):
                    # remove any builds that are not the largest
                    if int(build_outer_loop[i]) > int(build_inner_loop[i]):
                        build_array_split.remove(build_inner_loop)
                        break
                    if int(build_outer_loop[i]) < int(build_inner_loop[i]):
                        break

        # Convert array back to string
        for entry in build_array_split[0]:
            # Since we split per character, we know that anything above 9 is a letter
            if int(entry) > 9:
                # revert back to letter
                final_build += chr(entry)
            else:
                final_build += str(entry)

        # Since we pad with 0s, we need to next determine how many 0s to remove
        for build in build_array:
            if final_build.startswith(build):
                # Handle cases where Apple added a letter to the build
                # ex. "22A5295" vs "22A5295"
                remaining_strings = final_build.split(build)[1]
                # If all remaining strings are 0s, then we can remove the 0s
                if all(char == "0" for char in remaining_strings):
                    final_build = build

        return final_build


#IMPORTANT NOTE: ensure to add macOS Tahoe 26 support to this and other items please, it is listed as version 26 or 26.0, 26.1, 26.2, 26.3 or macOS beta, macOS Beta, macOS Tahoe

"""
pci_data.py: PCI Device IDs for different vendors and devices
"""


class nvidia_ids:
    # Courteous of envytools as well as MacRumors:
    # https://envytools.readthedocs.io/en/latest/hw/pciid.html
    # https://forums.macrumors.com/threads/2011-imac-graphics-card-upgrade.1596614/
    # https://pci-ids.ucw.cz/read/PC/10de
    curie_ids = [
        0x0040,  # NV40 [GeForce 6800 Ultra]
        0x00f0,  # BR02
        0x0220,  # NV44A
        0x0140,  # NV43 [GeForce 6600 GT]
        0x0160,  # NV44 [GeForce 6500]
        0x0090,  # G70 [GeForce 7800 GTX]
        0x01d0,  # G72 [GeForce 7350 LE]
        0x0390,  # G73 [GeForce 7650 GS]
        0x0290,  # G71 [GeForce 7900 GTX]
    ]

    tesla_ids = [
        # G80
        0x0190,  # G80 [GeForce 8800 GTS / 8800 GTX]
        0x0191,  # G80 [GeForce 8800 GTX]
        0x0193,  # G80 [GeForce 8800 GTS]
        0x0194,  # G80 [GeForce 8800 Ultra]
        0x019E,  # G80GL [Quadro FX 4600]
        0x019D,  # G80GL [Quadro FX 5600]
        # G84
        0x0400,  # G84 [8600 GTS]
        0x0401,  # G84 [8600 GT]
        0x0402,  # G84 [8600 GT]
        0x0403,  # G84 [8600 GS]
        0x0404,  # G84 [8400 GS]
        0x0405,  # G84 [9500M GS]
        0x0406,  # G84 [8300 GS]
        0x0407,  # G84 [8600M GT]
        0x0408,  # G84 [9650M GS]
        0x0409,  # G84 [8700M GT]
        0x040A,  # G84 [FX 370]
        0x040B,  # G84 [NVS 320M]
        0x040C,  # G84 [FX 570M]
        0x040D,  # G84 [FX 1600M]
        0x040E,  # G84 [FX 570]
        0x040F,  # G84 [FX 1700]
        # G86
        0x0420,  # G86 [8400 SE]
        0x0421,  # G86 [8500 GT]
        0x0422,  # G86 [8400 GS]
        0x0423,  # G86 [8300 GS]
        0x0424,  # G86 [8400 GS]
        0x0425,  # G86 [8600M GS]
        0x0426,  # G86 [8400M GT]
        0x0427,  # G86 [8400M GS]
        0x0428,  # G86 [8400M G]
        0x0429,  # G86 [NVS 140M]
        0x042A,  # G86 [NVS 130M]
        0x042B,  # G86 [NVS 135M]
        0x042C,  # G86 [9400 GT]
        0x042D,  # G86 [FX 360M]
        0x042E,  # G86 [9300M G]
        0x042F,  # G86 [NVS 290]
        # G92
        0x0410,  # G92 [GT 330]
        0x0600,  # G92 [8800 GTS 512]
        0x0601,  # G92 [9800 GT]
        0x0602,  # G92 [8800 GT]
        0x0603,  # G92 [GT 230]
        0x0604,  # G92 [9800 GX2]
        0x0605,  # G92 [9800 GT]
        0x0606,  # G92 [8800 GS]
        0x0607,  # G92 [GTS 240]
        0x0608,  # G92 [9800M GTX]
        0x0609,  # G92 [8800M GTS]
        0x060A,  # G92 [GTX 280M]
        0x060B,  # G92 [9800M GT]
        0x060C,  # G92 [8800M GTX]
        0x060F,  # G92 [GTX 285M]
        0x0610,  # G92 [9600 GSO]
        0x0611,  # G92 [8800 GT]
        0x0612,  # G92 [9800 GTX/9800 GTX+]
        0x0613,  # G92 [9800 GTX+]
        0x0614,  # G92 [9800 GT]
        0x0615,  # G92 [GTS 250]
        0x0617,  # G92 [9800M GTX]
        0x0618,  # G92 [GTX 260M]
        0x0619,  # G92 [FX 4700 X2]
        0x061A,  # G92 [FX 3700]
        0x061B,  # G92 [VX 200]
        0x061C,  # G92 [FX 3600M]
        0x061D,  # G92 [FX 2800M]
        0x061E,  # G92 [FX 3700M]
        0x061F,  # G92 [FX 3800M]
        # G94
        0x0621,  # G94 [GT 230]
        0x0622,  # G94 [9600 GT]
        0x0623,  # G94 [9600 GS]
        0x0624,  # G94 [9600 GT Green Edition]
        0x0625,  # G94 [9600 GSO 512]
        0x0626,  # G94 [GT 130]
        0x0627,  # G94 [GT 140]
        0x0628,  # G94 [9800M GTS]
        0x062A,  # G94 [9700M GTS]
        0x062B,  # G94 [9800M GS]
        0x062C,  # G94 [9800M GTS ]
        0x062D,  # G94 [9600 GT]
        0x062E,  # G94 [9600 GT]
        0x062F,  # G94 [9800 S]
        0x0631,  # G94 [GTS 160M]
        0x0635,  # G94 [9600 GSO]
        0x0637,  # G94 [9600 GT]
        0x0638,  # G94 [FX 1800]
        0x063A,  # G94 [FX 2700M]
        # G96
        0x0640,  # G96 [9500 GT]
        0x0641,  # G96 [9400 GT]
        0x0643,  # G96 [9500 GT]
        0x0644,  # G96 [9500 GS]
        0x0645,  # G96 [9500 GS]
        0x0646,  # G96 [GT 120]
        0x0647,  # G96 [9600M GT]
        0x0648,  # G96 [9600M GS]
        0x0649,  # G96 [9600M GT]
        0x064A,  # G96 [9700M GT]
        0x064B,  # G96 [9500M G]
        0x064C,  # G96 [9650M GT]
        0x0651,  # G96 [G 110M]
        0x0652,  # G96 [GT 130M]
        0x0653,  # G96 [GT 120M]
        0x0654,  # G96 [GT 220M]
        0x0655,  # G96 [GT 120]
        0x0656,  # G96 [GT 120 ]
        0x0658,  # G96 [FX 380]
        0x0659,  # G96 [FX 580]
        0x065A,  # G96 [FX 1700M]
        0x065B,  # G96 [9400 GT]
        0x065C,  # G96 [FX 770M]
        0x065F,  # G96 [G210]
        # G98
        0x06E0,  # G98 [9300 GE]
        0x06E1,  # G98 [9300 GS]
        0x06E2,  # G98 [8400]
        0x06E3,  # G98 [8400 SE]
        0x06E4,  # G98 [8400 GS]
        0x06E5,  # G98M [9300M GS]
        0x06E6,  # G98 [G100]
        0x06E7,  # G98 [9300 SE]
        0x06E8,  # G98 [9200M GS]
        0x06E9,  # G98 [9300M GS]
        0x06EA,  # G98 [NVS 150M]
        0x06EB,  # G98 [NVS 160M]
        0x06EC,  # G98 [G 105M]
        0x06ED,  # G98 [9600 GT / 9800 GT]
        0x06EF,  # G98 [G 103M]
        0x06F1,  # G98 [G105M]
        0x06F8,  # G98 [NVS 420]
        0x06F9,  # G98 [FX 370 LP]
        0x06FA,  # G98 [NVS 450]
        0x06FB,  # G98 [FX 370M]
        0x06FD,  # G98 [NVS 295]
        0x06FF,  # G98 [HICx16]
        # GT200
        0x05E0,  # GT200 [GTX 295]
        0x05E1,  # GT200 [GTX 280]
        0x05E2,  # GT200 [GTX 260]
        0x05E3,  # GT200 [GTX 285]
        0x05E6,  # GT200 [GTX 275]
        0x05E7,  # GT200 [C1060]
        0x05E9,  # GT200 [CX]
        0x05EA,  # GT200 [GTX 260]
        0x05EB,  # GT200 [GTX 295]
        0x05ED,  # GT200 [FX 5800]
        0x05EE,  # GT200 [FX 4800]
        0x05EF,  # GT200 [FX 3800]
        0x05FD,  # GT200GL [Quadro FX 5800]
        0x05FE,  # GT200GL [Quadro FX 4800]
        0x05FF,  # GT200GL [Quadro FX 3800]
        # MCP77 GPU
        0x0840,  # MCP77 GPU [8200M]
        0x0844,  # MCP77 GPU [9100M G]
        0x0845,  # MCP77 GPU [8200M G]
        0x0846,  # MCP77 GPU [9200]
        0x0847,  # MCP77 GPU [9100]
        0x0848,  # MCP77 GPU [8300]
        0x0849,  # MCP77 GPU [8200]
        0x084A,  # MCP77 GPU [730A]
        0x084B,  # MCP77 GPU [9200]
        0x084C,  # MCP77 GPU [980A/780A SLI]
        0x084D,  # MCP77 GPU [750A SLI]
        0x084F,  # MCP77 GPU [8100 / 720A]
        # MCP79 GPU
        0x0860,  # MCP79 GPU [9400]
        0x0861,  # MCP79 GPU [9400]
        0x0862,  # MCP79 GPU [9400M G]
        0x0863,  # MCP79 GPU [9400M]
        0x0864,  # MCP79 GPU [9300]
        0x0865,  # MCP79 GPU [ION]
        0x0866,  # MCP79 GPU [9400M G]
        0x0867,  # MCP79 GPU [9400]
        0x0868,  # MCP79 GPU [760i SLI]
        0x0869,  # MCP79 GPU [9400]
        0x086A,  # MCP79 GPU [9400]
        0x086C,  # MCP79 GPU [9300 / 730i]
        0x086D,  # MCP79 GPU [9200]
        0x086E,  # MCP79 GPU [9100M G]
        0x086F,  # MCP79 GPU [8200M G]
        0x0870,  # MCP79 GPU [9400M]
        0x0871,  # MCP79 GPU [9200]
        0x0872,  # MCP79 GPU [G102M]
        0x0873,  # MCP79 GPU [G102M]
        0x0874,  # MCP79 GPU [ION]
        0x0876,  # MCP79 GPU [ION]
        0x087A,  # MCP79 GPU [9400]
        0x087D,  # MCP79 GPU [ION]
        0x087E,  # MCP79 GPU [ION LE]
        0x087F,  # MCP79 GPU [ION LE]
        # GT215
        0x0CA0,  # GT215 [GT 330]
        0x0CA2,  # GT215 [GT 320]
        0x0CA3,  # GT215 [GT 240]
        0x0CA4,  # GT215 [GT 340]
        0x0CA5,  # GT215 [GT 220]
        0x0CA7,  # GT215 [GT 330]
        0x0CA9,  # GT215 [GTS 250M]
        0x0CAC,  # GT215 [GT 220]
        0x0CAF,  # GT215 [GT 335M]
        0x0CB0,  # GT215 [GTS 350M]
        0x0CB1,  # GT215 [GTS 360M]
        0x0CBC,  # GT215 [FX 1800M]
        # GT216
        0x0A20,  # GT216 [GT 220]
        0x0A22,  # GT216 [315]
        0x0A23,  # GT216 [210]
        0x0A26,  # GT216 [405]
        0x0A27,  # GT216 [405]
        0x0A28,  # GT216 [GT 230M]
        0x0A29,  # GT216 [GT 330M]
        0x0A2A,  # GT216 [GT 230M]
        0x0A2B,  # GT216 [GT 330M]
        0x0A2C,  # GT216 [NVS 5100M]
        0x0A2D,  # GT216 [GT 320M]
        0x0A32,  # GT216 [GT 415]
        0x0A34,  # GT216 [GT 240M]
        0x0A35,  # GT216 [GT 325M]
        0x0A38,  # GT216 [400]
        0x0A3C,  # GT216 [FX 880M]
        # GT218
        0x0A60,  # GT218 [G210]
        0x0A62,  # GT218 [205]
        0x0A63,  # GT218 [310]
        0x0A64,  # GT218 [ION]
        0x0A65,  # GT218 [210]
        0x0A66,  # GT218 [310]
        0x0A67,  # GT218 [315]
        0x0A68,  # GT218 [G105M]
        0x0A69,  # GT218 [G105M]
        0x0A6A,  # GT218 [NVS 2100M]
        0x0A6C,  # GT218 [NVS 3100M]
        0x0A6E,  # GT218 [305M]
        0x0A6F,  # GT218 [ION]
        0x0A70,  # GT218 [310M]
        0x0A71,  # GT218 [305M]
        0x0A72,  # GT218 [310M]
        0x0A73,  # GT218 [305M]
        0x0A74,  # GT218 [G210M]
        0x0A75,  # GT218 [310M]
        0x0A76,  # GT218 [ION]
        0x0A78,  # GT218 [FX 380 LP]
        0x0A7A,  # GT218 [315M]
        0x0A7C,  # GT218 [FX 380M]
        0x10C0,  # GT218 [9300 GS]
        0x10C3,  # GT218 [8400GS]
        0x10C5,  # GT218 [405]
        0x10D8,  # GT218 [NVS 300]
        # MCP89 GPU
        0x08A0,  # MCP89 GPU [320M]
        0x08A2,  # MCP89 GPU [320M]
        0x08A3,  # MCP89 GPU [320M]
        0x08A4,  # MCP89 GPU [320M]
    ]

    fermi_ids = [
        # GF100
        0x06C0,  # GF100 [GTX 480]
        0x06C4,  # GF100 [GTX 465]
        0x06CA,  # GF100 [GTX 480M]
        0x06CB,  # GF100 [GTX 480]
        0x06CD,  # GF100 [GTX 470]
        0x06D1,  # GF100 [C2050 / C2070]
        0x06D2,  # GF100 [M2070]
        0x06D8,  # GF100 [6000]
        0x06D9,  # GF100 [5000]
        0x06DA,  # GF100 [5000M]
        0x06DC,  # GF100 [6000]
        0x06DD,  # GF100 [4000]
        0x06DE,  # GF100 [T20]
        0x06DF,  # GF100 [M2070-Q]
        # GF104
        0x0E22,  # GF104 [GTX 460]
        0x0E23,  # GF104 [GTX 460 SE]
        0x0E24,  # GF104 [GTX 460 OEM]
        0x0E30,  # GF104 [GTX 470M]
        0x0E31,  # GF104 [GTX 485M]
        0x0E3A,  # GF104 [3000M]
        0x0E3B,  # GF104 [4000M]
        # GF114
        0x1200,  # GF114 [GTX 560 Ti]
        0x1201,  # GF114 [GTX 560]
        0x1202,  # GF114 [GTX 560 Ti OEM]
        0x1203,  # GF114 [GTX 460 SE v2]
        0x1205,  # GF114 [GTX 460 v2]
        0x1206,  # GF114 [GTX 555]
        0x1207,  # GF114 [GT 645 OEM]
        0x1208,  # GF114 [GTX 560 SE]
        0x1210,  # GF114 [GTX 570M]
        0x1211,  # GF114 [GTX 580M]
        0x1212,  # GF114 [GTX 675M]
        0x1213,  # GF114 [GTX 670M]
        # GF106
        0x0DC0,  # GF106 [GT 440]
        0x0DC4,  # GF106 [GTS 450]
        0x0DC5,  # GF106 [GTS 450]
        0x0DC6,  # GF106 [GTS 450]
        0x0DCD,  # GF106 [GT 555M]
        0x0DCE,  # GF106 [GT 555M]
        0x0DD1,  # GF106 [GTX 460M]
        0x0DD2,  # GF106 [GT 445M]
        0x0DD3,  # GF106 [GT 435M]
        0x0DD6,  # GF106 [GT 550M]
        0x0DD8,  # GF106 [2000]
        0x0DDA,  # GF106 [2000M]
        # GF116
        0x1241,  # GF116 [GT 545 OEM]
        0x1243,  # GF116 [GT 545]
        0x1244,  # GF116 [GTX 550 Ti]
        0x1245,  # GF116 [GTS 450 Rev. 2]
        0x1246,  # GF116 [GT 550M]
        0x1247,  # GF116 [GT 635M]
        0x1248,  # GF116 [GT 555M]
        0x1249,  # GF116 [GTS 450 Rev. 3]
        0x124B,  # GF116 [GT 640 OEM]
        0x124D,  # GF116 [GT 555M]
        0x1251,  # GF116 [GTX 560M]
        # GF108
        0x0DE0,  # GF108 [GT 440]
        0x0DE1,  # GF108 [GT 430]
        0x0DE2,  # GF108 [GT 420]
        0x0DE3,  # GF108 [GT 635M]
        0x0DE4,  # GF108 [GT 520]
        0x0DE5,  # GF108 [GT 530]
        0x0DE8,  # GF108 [GT 620M]
        0x0DE9,  # GF108 [GT 630M]
        0x0DEA,  # GF108 [610M]
        0x0DEB,  # GF108 [GT 555M]
        0x0DEC,  # GF108 [GT 525M]
        0x0DED,  # GF108 [GT 520M]
        0x0DEE,  # GF108 [GT 415M]
        0x0DEF,  # GF108 [NVS 5400M]
        0x0DF0,  # GF108 [GT 425M]
        0x0DF1,  # GF108 [GT 420M]
        0x0DF2,  # GF108 [GT 435M]
        0x0DF3,  # GF108 [GT 420M]
        0x0DF4,  # GF108 [GT 540M]
        0x0DF5,  # GF108 [GT 525M]
        0x0DF6,  # GF108 [GT 550M]
        0x0DF7,  # GF108 [GT 520M]
        0x0DF8,  # GF108 [600]
        0x0DF9,  # GF108 [500M]
        0x0DFA,  # GF108 [1000M]
        0x0DFC,  # GF108 [NVS 5200M]
        0x0F00,  # GF108 [GT 630]
        0x0F01,  # GF108 [GT 620]
        0x0F02,  # GF108 [GT 730]
        # GF110
        0x1080,  # GF110 [GTX 580]
        0x1081,  # GF110 [GTX 570]
        0x1082,  # GF110 [GTX 560 Ti]
        0x1084,  # GF110 [GTX 560]
        0x1086,  # GF110 [GTX 570]
        0x1087,  # GF110 [GTX 560 Ti]
        0x1088,  # GF110 [GTX 590]
        0x1089,  # GF110 [GTX 580]
        0x108B,  # GF110 [GTX 580]
        0x1091,  # GF110 [M2090]
        0x1096,  # GF110GL [Tesla C2050 / C2075]
        0x109A,  # GF110 [5010M]
        0x109B,  # GF110 [7000]
        # GF119
        0x1040,  # GF119 [GT 520]
        0x1042,  # GF119 [510]
        0x1048,  # GF119 [605]
        0x1049,  # GF119 [GT 620]
        0x104A,  # GF119 [GT 610]
        0x104B,  # GF119 [GT 625 OEM]
        0x104C,  # GF119 [GT 705]
        0x1050,  # GF119 [GT 520M]
        0x1051,  # GF119 [GT 520MX]
        0x1052,  # GF119 [GT 520M]
        0x1054,  # GF119 [410M]
        0x1055,  # GF119 [410M]
        0x1056,  # GF119 [NVS 4200M]
        0x1057,  # GF119 [NVS 4200M]
        0x1058,  # GF119 [610M]
        0x1059,  # GF119 [610M]
        0x105A,  # GF119 [610M]
        0x105B,  # GF119M [705M]
        0x107C,  # GF119 [NVS 315]
        0x107D,  # GF119 [NVS 310]
        # GF117
        0x1140,  # GF117 [GT 620M]
    ]

    kepler_ids = [
        # GK104
        0x1180,  # GK104 [GTX 680]
        0x1182,  # GK104 [GTX 760 Ti]
        0x1183,  # GK104 [GTX 660 Ti]
        0x1184,  # GK104 [GTX 770]
        0x1185,  # GK104 [GTX 660]
        0x1186,  # GK104 [GTX 660 Ti]
        0x1187,  # GK104 [GTX 760]
        0x1188,  # GK104 [GTX 690]
        0x1189,  # GK104 [GTX 670]
        0x118a,  # GK104GL [GRID K520]
        0x118b,  # GK104GL [GRID K2 GeForce USM]
        0x118c,  # GK104 [GRID K2 NVS USM]
        0x118d,  # GK104GL [GRID K200 vGPU]
        0x118E,  # GK104 [GTX 760 OEM]
        0x118F,  # GK104GL [Tesla K10]
        0x1191,  # GK104 [GTX 760 Rev. 2]
        0x1193,	 # GK104 [GTX 760 Ti OEM]
        0x1194,  # GK104GL [Tesla K8]
        0x1195,  # GK104 [GTX 660 Rev. 2]
        0x1198,  # GK104M [GTX 880M]
        0x1199,  # GK104M [GTX 870M]
        0x119A,  # GK104M [GTX 860M]
        0x119D,  # GK104M [GTX 775M Mac Edition]
        0x119E,  # GK104M [GTX 780M Mac Edition]
        0x119F,  # GK104 [GTX 780M]
        0x11A0,  # GK104 [GTX 680M]
        0x11A1,  # GK104 [GTX 670MX]
        0x11A2,  # GK104 [GTX 675MX Mac Edition]
        0x11A3,  # GK104 [GTX 680MX]
        0x11A7,  # GK104 [GTX 675MX]
        0x11A8,  # GK104GLM [Quadro K5100M]
        0x11A9,  # GK104M [GTX 870M]
        0x11AF,  # GK104GLM [GRID IceCube]
        0x11B0,  # GK104GL [GRID K240Q / K260Q vGPU]
        0x11B1,  # GK104GL [GRID K2 Tesla USM]
        0x11B4,  # GK104GL [Quadro K4200]
        0x11B6,  # GK104GLM [Quadro K3100M]
        0x11B7,  # GK104GLM [Quadro K4100M]
        0x11B8,  # GK104GLM [Quadro K5100M]
        0x11B9,  # GK104GLM
        0x11BA,  # GK104GL [Quadro K5000]
        0x11BC,  # GK104GLM [Quadro K5000M]
        0x11BD,  # GK104GLM [Quadro K4000M]
        0x11BE,  # GK104GLM [Quadro K3000M]
        0x11BF,  # GK104 [GRID K2]
        # GK106
        0x11C0,  # GK106 [GTX 660]
        0x11C2,  # GK106 [GTX 650 Ti BOOST]
        0x11c3,  # GK106 [GTX 650 Ti OEM]
        0x11c4,  # GK106 [GTX 645 OEM]
        0x11c5,  # GK106 [GT 740]
        0x11C6,  # GK106 [GTX 650 Ti]
        0x11C7,  # GK106 [GTX 750 Ti]
        0x11C8,  # GK106 [GTX 650 OEM]
        0x11E0,  # GK106 [GTX 770M]
        0x11CB,  # GK106 [GT 740]
        0x11E0,  # GK106M [GTX 770M]
        0x11E1,  # GK106M [GTX 765M]
        0x11E2,  # GK106M [GTX 765M]
        0x11E3,  # GK106M [GTX 760M]
        0x11E7,  # GK106M
        0x11FA,  # GK106GL [Quadro K4000]
        0x11FC,  # GL106GLM [Quadro K2100M]
        # GK107
        0x0FC0,  # GK107 [GT 640]
        0x0FC1,  # GK107 [GT 640]
        0x0FC2,  # GK107 [GT 630]
        0x0FC5,  # GK107 [GT 1030]
        0x0FC6,  # GK107 [GTX 650]
        0x0FC8,  # GK107 [GT 740]
        0x0FC9,  # GK107 [GT 730]
        0x0FCD,  # GK107M [GT 755M]
        0x0FCE,  # GK107M [GT 640M LE]
        0x0FD1,  # GK107 [GT 650M]
        0x0FD2,  # GK107 [GT 640M]
        0x0FD3,  # GK107 [GT 640M LE]
        0x0FD4,  # GK107 [GTX 660M]
        0x0FD5,  # GK107 [GT 650M]
        0x0FD6,  # GK107M
        0x0FD8,  # GK107 [GT 640M]
        0x0FD9,  # GK107 [GT 645M]
        0x0FDB,  # GK107M
        0x0FDF,  # GK107M [GT 740M]
        0x0FE0,  # GK107 [GTX 660M]
        0x0FE1,  # GK107M [GT 730M]
        0x0FE2,  # GK107M [GT 745M]
        0x0FE3,  # GK107M [GT 745M]
        0x0FE4,  # GK107M [GT 750M]
        0x0FE5,  # GK107 [GeForce K340 USM]
        0x0FE6,  # GK107 [GRID K1 NVS USM]
        0x0FE7,  # GK107GL [GRID K100 vGPU]
        0x0FE8,  # GK107M [N14P-GS]
        0x0FE9,  # GK107 [GT 750M Mac Edition]
        0x0FEA,  # GK107M [GT 755M Mac Edition]
        0x0FEC,  # GK107M [710A]
        0x0FEE,  # GK107M [810M]
        0x0FED,  # GK107M [820M]
        0x0FEF,  # GK107GL [GRID K340]
        0x0FF1,  # GK107 [NVS 1000]
        0x0FF2,  # GK107GL [GRID K1]
        0x0FF3,  # GK107GL [Quadro K420]
        0x0FF5,  # GK107GL [GRID K1 Tesla USM]
        0x0FF6,  # GK107GLM [Quadro K1100M]
        0x0FF7,  # GK107GL [GRID K140Q vGPU]
        0x0FF8,  # GK107GLM [Quadro K500M]
        0x0FF9,  # GK107 [K2000D]
        0x0FFA,  # GK107 [K600]
        0x0FFB,  # GK107 [K2000M]
        0x0FFC,  # GK107 [K1000M]
        0x0FFD,  # GK107 [NVS 510]
        0x0FFE,  # GK107 [Quadro K2000]
        0x0FFF,  # GK107 [Quadro 410]
        # GK110
        0x1001,  # GK110B [GTX TITAN Z]
        0x1003,  # GK110 [GTX Titan LE]
        0x1004,  # GK110 [GTX 780]
        0x1005,  # GK110 [GTX Titan]
        0x1007,  # GK110 [GTX 780 Rev. 2]
        0x1008,  # GK110 [GTX 780 Ti 6GB]
        0x100A,  # GK110B [GTX 780 Ti]
        0x100C,  # GK110B [GTX TITAN Black]
        0x101E,  # GK110GL [Tesla K20X]
        0x101F,  # GK110GL [Tesla K20]
        0x1020,  # GK110GL [Tesla K20X]
        0x1021,  # GK110GL [Tesla K20Xm]
        0x1022,  # GK110GL [Tesla K20C]
        0x1023,  # GK110BGL [Tesla K40m]
        0x1026,  # GK110GL [Tesla K20s]
        0x1027,  # GK110BGL [Tesla K40st]
        0x1028,  # GK110GL [Tesla K20m]
        0x1029,  # GK110BGL [Tesla K40s]
        0x102A,  # GK110BGL [Tesla K40t]
        0x102E,  # GK110BGL [Tesla K40d]
        0x102F,  # GK110BGL [Tesla Stella Solo]
        0x103A,  # GK110GL [Quadro K6000]
        0x103C,  # GK110GL [Quadro K5200]
        0x103F,  # GK110BGL [Tesla Stella SXM]
        # GK180
        0x1024,  # GK180GL [Tesla K40c]
        # GK208
        0x1280,  # GK208 [GT 635]
        0x1281,  # GK208 [GT 710]
        0x1282,  # GK208 [GT 640 REv. 2]
        0x1284,  # GK208 [GT 630 REv. 2]
        0x1286,  # GK208 [GT 720]
        0x1287,  # GK208B [GT 730]
        0x1288,  # GK208B [GT 720]
        0x1289,  # GK208 [GT 710]
        0x128A,  # GK208B
        0x128B,  # GK208B [GT 710]
        0x128C,  # GK208B
        0x1290,  # GK208 [GT 730M]
        0x1291,  # GK208 [GT 735M]
        0x1292,  # GK208 [GT 740M]
        0x1293,  # GK208 [GT 730M]
        0x1294,  # GK208 [GT 740M]
        0x1295,  # GK208 [710M]
        0x1296,  # GK208M [825M]
        0x1298,  # GK208M [GT 720M]
        0x1299,  # GK208BM [920M]
        0x129A,  # GK208BM [910M]
        0x12A0,  # GK208
        0x12B9,  # GK208 [K610M]
        0x12BA,  # GK208 [K510M]
        # GK210
        0x102D,  # GK210GL [Tesla K80]
    ]


    maxwell_ids = [
        0x1340,	# GM108M [GeForce 830M]
        0x1341,	# GM108M [GeForce 840M]
        0x1344,	# GM108M [GeForce 845M]
        0x1346,	# GM108M [GeForce 930M]
        0x1347,	# GM108M [GeForce 940M]
        0x1348,	# GM108M [GeForce 945M / 945A]
        0x1349,	# GM108M [GeForce 930M]
        0x134b,	# GM108M [GeForce 940MX]
        0x134d,	# GM108M [GeForce 940MX]
        0x134e,	# GM108M [GeForce 930MX]
        0x134f,	# GM108M [GeForce 920MX]
        0x137a,	# GM108GLM [Quadro K620M / Quadro M500M]
        0x137b,	# GM108GLM [Quadro M520 Mobile]
        0x137d,	# GM108M [GeForce 940A]
        0x174d, # GM108M [GeForce MX130]
        0x174e, # GM108M [GeForce MX110]

        0x1380,	# GM107 [GTX 750 Ti]
        0x1381,	# GM107 [GTX 750]
        0x1382,	# GM107 [GTX 745]
        0x1389,	# GM107GL [GRID M30]
        0x1390,	# GM107M [GeForce 845M]
        0x1391,	# GM107M [GTX 850M]
        0x1392,	# GM107M [GTX 860M]
        0x1393,	# GM107M [GeForce 840M]
        0x1398,	# GM107M [GeForce 845M]
        0x1399,	# GM107M [GeForce 945M]
        0x139a,	# GM107M [GTX 950M]
        0x139b,	# GM107M [GTX 960M]
        0x139c,	# GM107M [GeForce 940M]
        0x139d,	# GM107M [GTX 750 Ti]
        0x13b0,	# GM107GLM [Quadro M2000M]
        0x13b1,	# GM107GLM [Quadro M1000M]
        0x13b2,	# GM107GLM [Quadro M600M]
        0x13b3,	# GM107GLM [Quadro K2200M]
        0x13b4,	# GM107GLM [Quadro M620 Mobile]
        0x13b6,	# GM107GLM [Quadro M1200 Mobile]
        0x13b9,	# GM107GL [NVS 810]
        0x13ba,	# GM107GL [Quadro K2200]
        0x13bb,	# GM107GL [Quadro K620]
        0x13bc,	# GM107GL [Quadro K1200]
        0x13bd,	# GM107GL [Tesla M10]
        0x1789, # GM107GL [GRID M3-3020]
        0x179c, # GM107 [GeForce 940MX]

        0x17c2, # GM200 [GTX TITAN X]
        0x17c8, # GM200 [GTX 980 Ti]
        0x17f0,	# GM200GL [Quadro M6000]
        0x17f1, # GM200GL [Quadro M6000 24GB]
        0x17fd, # GM200GL [Tesla M40]

        0x13c0,	# GM204 [GTX 980]
        0x13c1,	# GM204
        0x13c2,	# GM204 [GTX 970]
        0x13c3,	# GM204
        0x13d7,	# GM204M [GTX 980M]
        0x13d8,	# GM204M [GTX 970M]
        0x13d9,	# GM204M [GTX 965M]
        0x13da,	# GM204M [GTX 980 Mobile]
        0x13e7,	# GM204GL [GTX 980 Engineering Sample]
        0x13f0,	# GM204GL [Quadro M5000]
        0x13f1,	# GM204GL [Quadro M4000]
        0x13f2,	# GM204GL [Tesla M60]
        0x13f3,	# GM204GL [Tesla M6]
        0x13f8,	# GM204GLM [Quadro M5000M / M5000 SE]
        0x13f9,	# GM204GLM [Quadro M4000M]
        0x13fa,	# GM204GLM [Quadro M3000M]
        0x13fb,	# GM204GLM [Quadro M5500]

        0x1401,	# GM206 [GTX 960]
        0x1402,	# GM206 [GTX 950]
        0x1404,	# GM206 [GTX 960 FAKE]
        0x1406,	# GM206 [GTX 960 OEM]
        0x1407,	# GM206 [GTX 750 v2]
        0x1427,	# GM206M [GTX 965M]
        0x1430,	# GM206GL [Quadro M2000]
        0x1431,	# GM206GL [Tesla M4]
        0x1436,	# GM206GLM [Quadro M2200 Mobile]
    ]

    pascal_ids = [
        0x1725,
        0x172e,
        0x172f,
        0x15f0,	# GP100GL [Quadro GP100]
        0x15f1,	# GP100GL
        0x15f7,	# GP100GL [Tesla P100 PCIe 12GB]
        0x15f8,	# GP100GL [Tesla P100 PCIe 16GB]
        0x15f9,	# GP100GL [Tesla P100 SXM2 16GB]

        0x1b00,	# GP102 [TITAN X]
        0x1b01,	# GP102 [GTX 1080 Ti 10GB]
        0x1b02,	# GP102 [TITAN Xp]
        0x1b04,	# GP102
        0x1b06,	# GP102 [GTX 1080 Ti]
        0x1b07,	# GP102 [P102-100]
        0x1b30,	# GP102GL [Quadro P6000]
        0x1b38,	# GP102GL [Tesla P40]
        0x1b39,	# GP102GL [Tesla P10]
        0x1b70,	# GP102GL
        0x1b78,	# GP102GL

        0x1b80,	# GP104 [GTX 1080]
        0x1b81,	# GP104 [GTX 1070]
        0x1b82,	# GP104 [GTX 1070 Ti]
        0x1b83,	# GP104 [GTX 1060 6GB]
        0x1b84,	# GP104 [GTX 1060 3GB]
        0x1b87,	# GP104 [P104-100]
        0x1ba0,	# GP104M [GTX 1080 Mobile]
        0x1ba1,	# GP104M [GTX 1070 Mobile]
        0x1ba2,	# GP104M [GTX 1070 Mobile]
        0x1ba9,	# GP104M
        0x1baa,	# GP104M
        0x1bad,	# GP104 [GTX 1070 Engineering Sample]
        0x1bb0,	# GP104GL [Quadro P5000]
        0x1bb1,	# GP104GL [Quadro P4000]
        0x1bb3,	# GP104GL [Tesla P4]
        0x1bb4,	# GP104GL [Tesla P6]
        0x1bb5,	# GP104GLM [Quadro P5200 Mobile]
        0x1bb6,	# GP104GLM [Quadro P5000 Mobile]
        0x1bb7,	# GP104GLM [Quadro P4000 Mobile]
        0x1bb8,	# GP104GLM [Quadro P3000 Mobile]
        0x1bb9,	# GP104GLM [Quadro P4200 Mobile]
        0x1bbb,	# GP104GLM [Quadro P3200 Mobile]
        0x1bc7,	# GP104 [P104-101]
        0x1be0,	# GP104BM [GTX 1080 Mobile]
        0x1be1,	# GP104BM [GTX 1070 Mobile]

        0x1c00,	# GP106
        0x1c01,	# GP106
        0x1c02,	# GP106 [GTX 1060 3GB]
        0x1c03,	# GP106 [GTX 1060 6GB]
        0x1c04,	# GP106 [GTX 1060 5GB]
        0x1c06,	# GP106 [GTX 1060 6GB Rev. 2]
        0x1c07,	# GP106 [P106-100]
        0x1c09,	# GP106 [P106-090]
        0x1c20,	# GP106M [GTX 1060 Mobile]
        0x1c21,	# GP106M [GTX 1050 Ti Mobile]
        0x1c22,	# GP106M [GTX 1050 Mobile]
        0x1c23,	# GP106M [GTX 1060 Mobile Rev. 2]
        0x1c2d,	# GP106M
        0x1c30,	# GP106GL [Quadro P2000]
        0x1c31,	# GP106GL [Quadro P2200]
        0x1c35,	# GP106M [Quadro P2000 Mobile]
        0x1c36,	# GP106 [P106M]
        0x1c60,	# GP106BM [GTX 1060 Mobile 6GB]
        0x1c61,	# GP106BM [GTX 1050 Ti Mobile]
        0x1c62,	# GP106BM [GTX 1050 Mobile]
        0x1c70,	# GP106GL

        0x1c80,
        0x1c81,	# GP107 [GTX 1050]
        0x1c82,	# GP107 [GTX 1050 Ti]
        0x1c83,	# GP107 [GTX 1050 3GB]
        0x1c8c,	# GP107M [GTX 1050 Ti Mobile]
        0x1c8d,	# GP107M [GTX 1050 Mobile]
        0x1c8e,	# GP107M
        0x1c8f,	# GP107M [GTX 1050 Ti Max-Q]
        0x1c90,	# GP107M [GeForce MX150]
        0x1c91,	# GP107M [GTX 1050 3 GB Max-Q]
        0x1c92,	# GP107M [GTX 1050 Mobile]
        0x1c94,	# GP107M [GeForce MX350]
        0x1c96,	# GP107M [GeForce MX350]
        0x1ca7,	# GP107GL
        0x1ca8,	# GP107GL
        0x1caa,	# GP107GL
        0x1cb1,	# GP107GL [Quadro P1000]
        0x1cb2,	# GP107GL [Quadro P600]
        0x1cb3,	# GP107GL [Quadro P400]
        0x1cb6,	# GP107GL [Quadro P620]
        0x1cba,	# GP107GLM [Quadro P2000 Mobile]
        0x1cbb,	# GP107GLM [Quadro P1000 Mobile]
        0x1cbc,	# GP107GLM [Quadro P600 Mobile]
        0x1cbd,	# GP107GLM [Quadro P620]
        0x1ccc,	# GP107BM [GTX 1050 Ti Mobile]
        0x1ccd,	# GP107BM [GTX 1050 Mobile]
        0x1cfa,	# GP107GL [Quadro P2000]
        0x1cfb,	# GP107GL [Quadro P1000]

        0x1d01,	# GP108 [GeForce GT 1030]
        0x1d02,	# GP108 [GeForce GT 1010]
        0x1d10,	# GP108M [GeForce MX150]
        0x1d11,	# GP108M [GeForce MX230]
        0x1d12,	# GP108M [GeForce MX150]
        0x1d13,	# GP108M [GeForce MX250]
        0x1d16,	# GP108M [GeForce MX330]
        0x1d33,	# GP108GLM [Quadro P500 Mobile]
        0x1d34,	# GP108GLM [Quadro P520]
        0x1d52,	# GP108BM [GeForce MX250]
        0x1d56,	# GP108BM [GeForce MX330]
    ]


class amd_ids:

    gcn_7000_ids = [
        # GCN v1
        # AMDPitcairnGraphicsAccelerator - AMD7000Controller
        0x6800,  # HD 7970M
        0x6801,  # HD 8970M
        0x6806,  # Unknown
        0x6808,  # W7000
        0x6810,  # R7 370 / R9 270X/370X
        0x6818,  # HD 7870
        0x6819,  # HD 7850 / R7 265 / R9 270 1024SP
        # AMDTahitiGraphicsAccelerator - AMD7000Controller
        0x6790,  # Unknown
        0x6798,  # HD 7970/8970 OEM / R9 280X / D700
        0x679A,  # HD 7950/8950 OEM / R9 280
        0x679E,  # HD 7870 XT
        0x6780,  # W9000
        # AMDVerdeGraphicsAccelerator - AMD7000Controller
        0x6820,  # HD 8890M / R9 M275X/M375X / M5100
        0x6821,  # HD 8870M / R9 M270X/M370X
        0x6823,  # HD 8850M / R9 M265X
        0x6825,  # HD 7870M
        0x6827,  # HD 7850M/8850M
        0x682B,  # HD 8830M / R7 250 / R7 M465X
        0x682D,  # M4000
        0x682F,  # HD 7730M
        0x6835,  # R9 255
        0x6839,  # Unknown
        0x683B,  # Unknown
        0x683D,  # HD 7770/8760 / R7 250X
        0x683F,  # HD 7750/8740 / R7 250E
    ]

    gcn_8000_ids = [
        # GCN v2
        # AMDBonaireGraphicsAccelerator - AMD8000Controller
        0x6640,  # M6100
        0x6641,  # HD 8930M
        0x6646,  # R9 M280X / W6170M
        0x6647,  # R9 M270X/M280X
        0x6650,  # Unknown
        0x6651,  # Unknown
        0x665C,  # HD 7790/8770 / R7 360 / R9 260/360
        0x665D,  # R7 200
        # AMDHawaiiGraphicsAccelerator - AMD8000Controller
        0x67B0,  # R9 290X/390X
    ]

    gcn_9000_ids = [
        # GCN v3
        # AMDFijiGraphicsAccelerator - AMD9000Controller
        0x7300,  # R9 FURY / NANO
        0x730F,  # Unknown
        # AMDTongaGraphicsAccelerator - AMD9000Controller
        0x6920,  # R9 M395/ M395X
        0x6921,  # R9 M295X / M390X
        0x6930,  # Unknown
        0x6938,  # R9 380X / R9 M295X
        0x6939,  # R9 285/380
    ]

    polaris_ids = [
        # GCN v4
        # AMDRadeonX4000
        # AMDBaffinGraphicsAccelerator - AMD9500Controller
        0x67E0,  # Pro WX 4170
        0x67E3,  # Pro WX 4100
        0x67E8,  # Pro WX 4130/4150
        0x67EB,  # Pro V5300X
        0x67EF,  # 460/560D / Pro 450/455/460/555/555X/560/560X
        0x67FF,  # 550 640SP / RX 560/560X
        0x67E1,  # Unknown
        0x67E7,  # Unknown
        0x67E9,  # Unknown
        # AMDEllesmereGraphicsAccelerator - AMD9500Controller
        0x67C0,  # Pro WX 7100 Mobile
        0x67C1,  # Unknown
        0x67C2,  # Pro V7300X / V7350x2
        0x67C4,  # Pro WX 7100
        0x67C7,  # Pro WX 5100
        0x67DF,  # 470/480/570/570X/580/580X/590
        0x67D0,  # Pro V7300X / V7350x2
        0x67C8,  # Unknown
        0x67C9,  # Unknown
        0x67CA,  # Unknown
        0x67CC,  # Unknown
        0x67CF,  # Unknown
    ]

    polaris_spoof_ids = [
        # Polaris 12 (Lexa)
        0x6981,  # Lexa XT [Radeon PRO WX 3200]
    ]

    vega_ids = [
        # GCN v5
        # AMDRadeonX5000
        # AMDVega10GraphicsAccelerator - AMD10000Controller
        0x6860,  # Instinct MI25
        0x6861,  # Pro WX 9100
        0x6862,  # Pro SSG
        0x6863,  # Vega Frontier
        0x6864,  # Pro V340
        0x6867,  # Pro Vega 56
        0x6868,  # Pro WX 8100/8200
        0x6869,  # Pro Vega 48
        0x686A,  # Unknown
        0x686B,  # Pro Vega 64X
        0x686C,  # Instinct MI25
        0x686D,  # Unknown
        0x686E,  # Unknown
        0x686F,  # Unknown
        0x687F,  # RX Vega 56/64
        # AMDVega12GraphicsAccelerator - AMD10000Controller
        0x69A0,  # Unknown
        0x69A1,  # Unknown
        0x69A2,  # Unknown
        0x69A3,  # Unknown
        0x69AF,  # Unknown
        # AMDVega20GraphicsAccelerator - AMD10000Controller
        0x66A0,  # Instinct
        0x66A1,  # Pro VII/Instinct MI50
        0x66A2,  # Unknown
        0x66A3,  # Pro Vega II/ Pro Vega II Duo
        0x66A7,  # Unknown
        0x66AF,  # VII
    ]

    navi_ids = [
        # AMDRadeonX6000
        # AMDNavi10GraphicsAccelerator
        0x7310,  # Pro W5700X
        0x7312,  # Pro W5700
        0x7318,  # Unknown
        0x7319,  # Unknown
        0x731A,  # Unknown
        0x731B,  # Unknown
        0x731F,  # RX 5600/5600 XT / 5700/5700 XT
        # AMDNavi12GraphicsAccelerator
        0x7360,  # 5600M
        # AMDNavi14GraphicsAccelerator
        0x7340,  # 5500/5500M / Pro 5500M
        0x7341,  # Pro W5500
        0x7343,  # Unknown
        0x7347,  # Pro W5500M
        0x734F,  # Pro W5300M
        # AMDNavi21GraphicsAccelerator
        0x73A2,  # Pro W6900X
        0x73AB,  # Pro W6800X/Pro W6800X Duo
        0x73BF,  # 6800/6800 XT / 6900 XT
        0x73A3,  # Pro W6800
        # AMDNavi23GraphicsAccelerator
        0x73E3,  # Pro W6600
        0x73FF,  # 6600/6600 XT/6600M
        0x73E0,  # Unknown
    ]

    r500_ids = [
        0x7187,  # X1300/X1550
        0x7146,  # X1300/X1550
        0x71c5,  # Mobile X1600
        0x7249,  # X1900 XT
    ]

    terascale_1_ids = [
        0x9400,  # HD 2900 PRO/XT
        0x9401,  # HD 2900 XT
        0x9402,  # Unknown
        0x9403,  # HD 2900 PRO
        0x9581,  # HD 2600 (mobile)
        0x9583,  # HD 2600 XT/2700 (mobile)
        0x9588,  # HD 2600 XT
        0x94C8,  # HD 2400 XT (mobile)
        0x94C9,  # HD 2400 (mobile)
        0x9500,  # HD 3850 X2
        0x9501,  # HD 3870
        0x9505,  # HD 3690/3850
        0x9507,  # HD 3830
        0x9504,  # HD 3850 (mobile)
        0x9506,  # HD 3850 X2 (mobile)
        0x9598,  # HD 3650/3750/4570/4580
        0x9488,  # HD 4670 (mobile)
        0x9599,  # HD 3650 AGP
        0x9591,  # HD 3650 (mobile)
        0x9593,  # HD 3670 (mobile)
        0x9440,  # HD 4870
        0x9442,  # HD 4850
        0x944A,  # HD 4850 (mobile)
        0x945A,  # HD 4870 (mobile)
        0x9490,  # HD 4670
        0x949E,  # FirePro V5700
        0x9480,  # HD 4650/5165 (mobile)
        0x9540,  # HD 4550
        0x9541,  # Unknown
        0x954E,  # Unknown
        0x954F,  # HD 4350/4550
        0x9552,  # HD 4330/4350/4550 (mobile)
        0x9553,  # HD 4530/4570/545v (mobile)
        0x94A0,  # HD 4830
    ]

    terascale_2_ids = [
        0x6738,  # HD 6870
        0x6739,  # HD 6850
        0x6720,  # HD 6970M/6990M
        0x6722,  # Unknown
        0x6768,  # Unknown
        0x6770,  # HD 6450A/7450A
        0x6779,  # HD 6450/7450/8450 / R5 230 OEM
        0x6760,  # HD 6400M/7400M
        0x6761,  # HD 6430M
        0x68E0,  # HD 5430/5450/547
        0x6898,  # HD 5870
        0x6899,  # HD 5850
        0x68B8,  # HD 5770
        0x68B0,  # Unknown
        0x68B1,  # Unknown
        0x68A0,  # HD 5870 (mobile)
        0x68A1,  # HD 5850 (mobile)
        0x6840,  # HD 7500M/7600M
        0x6841,  # HD 7550M/7570M/7650M
        0x68D8,  # HD 5670/5690/5730
        0x68C0,  # HD 5730 / 6570M
        0x68C1,  # HD 5650/5750 / 6530M/6550M
        0x68D9,  # HD 5550/5570/5630/6510/6610/7570
        0x6750,  # HD 6650A/7650A
        0x6758,  # HD 6670/7670
        0x6759,  # HD 6570/7570/8550
        0x6740,  # HD 6730M/6770M/7690M XT
        0x6741,  # HD 6630M/6650M/6750M/7670M/7690M
        0x6745,  # Unknown
    ]


class intel_ids:
    # https://dgpu-docs.intel.com/devices/hardware-table.html
    gma_950_ids = [
        0x2582,  # 915G
        0x2592,  # 915GM
        0x2772,  # 945G
        0x27A2,  # 945GM
    ]

    gma_x3100_ids = [
        0x2a02,  # 965GM
    ]

    iron_ids = [
        # AppleIntelHDGraphics IDs
        0x0044,  # Unknown
        0x0046,  # HD Graphics
    ]

    sandy_ids = [
        # AppleIntelHD3000Graphics IDs
        # AppleIntelSNBGraphicsFB IDs
        0x0106,  # HD Graphics 2000
        0x0601,  # Unknown
        0x0116,  # HD Graphics 3000
        0x0102,  # HD Graphics 2000
        0x0126,  # HD Graphics 3000
    ]

    ivy_ids = [
        # AppleIntelHD4000Graphics IDs
        # AppleIntelFramebufferCapri IDs
        0x0152,  # HD Graphics 2500
        0x0156,  # HD Graphics 2500
        0x0162,  # HD Graphics 4000
        0x0166,  # HD Graphics 4000
    ]

    haswell_ids = [
        # AppleIntelHD5000Graphics IDs
        # AppleIntelFramebufferAzul IDs
        0x0D26,  # Iris Pro Graphics P5200
        0x0A26,  # HD Graphics 5000
        0x0A2E,  # Iris Graphics 5100
        0x0D22,  # Iris Pro Graphics 5200
        0x0412,  # HD Graphics 4600
    ]

    broadwell_ids = [
        # AppleIntelBDWGraphicsFramebuffer IDs
        0x0BD1,  # Unknown
        0x0BD2,  # Unknown
        0x0BD3,  # Unknown
        0x1606,  # HD Graphics
        0x160E,  # HD Graphics
        0x1616,  # HD Graphics 5500
        0x161E,  # HD Graphics 5300
        0x1626,  # HD Graphics 6000
        0x1622,  # Iris Pro Graphics 6200
        0x1612,  # HD Graphics 5600
        0x162B,  # Iris Graphics 6100
    ]

    skylake_ids = [
        # AppleIntelSKLGraphicsFramebuffer IDs
        0x1916,  # HD Graphics 520
        0x191E,  # HD Graphics 515
        0x1926,  # Iris Graphics 540
        0x1927,  # Iris Graphics 550
        0x1912,  # HD Graphics 530
        0x1932,  # Iris Pro Graphics 580
        0x1902,  # HD Graphics 510
        0x1917,  # Unknown
        0x193B,  # Iris Pro Graphics 580
        0x191B,  # HD Graphics 530
    ]

    kaby_lake_ids = [
        # AppleIntelKBLGraphicsFramebuffer IDs
        0x5912,  # HD Graphics 630
        0x5916,  # HD Graphics 620
        0x591B,  # HD Graphics 630
        0x591C,  # UHD Graphics 615
        0x591E,  # HD Graphics 615
        0x5926,  # Iris Plus Graphics 640
        0x5927,  # Iris Plus Graphics 650
        0x5923,  # HD Graphics 635
    ]

    coffee_lake_ids = [
        # AppleIntelCFLGraphicsFramebuffer IDs
        0x3E9B,  # UHD Graphics 630
        0x3EA5,  # Iris Plus Graphics 655
        0x3EA6,  # Unknown
        0x3E92,  # UHD Graphics 630
        0x3E91,  # UHD Graphics 630
        0x3E98,  # UHD Graphics 630
    ]

    comet_lake_ids = [
        0x9BC8,  # UHD Graphics 630
        0x9BC5,  # UHD Graphics 630
        0x9BC4,  # UHD Graphics
    ]

    ice_lake_ids = [
        # AppleIntelICLLPGraphicsFramebuffer IDs
        0xFF05,  # Unknown
        0x8A70,  # Unknown
        0x8A71,  # Unknown
        0x8A51,  # Iris Plus Graphics G7
        0x8A5C,  # Iris Plus Graphics G4
        0x8A5D,  # Unknown
        0x8A52,  # Iris Plus Graphics G7
        0x8A53,  # Iris Plus Graphics G7
        0x8A5A,  # Iris Plus Graphics G4
        0x8A5B,  # Unknown
    ]

    AppleIntel8254XEthernet = [
        # AppleIntel8254XEthernet IDs
        0x1096,  # 80003ES2LAN
        0x100F,  # 82545EM
        0x105E,  # 82571EB/82571GB
    ]

    AppleIntelI210Ethernet = [
        # AppleIntelI210Ethernet IDs
        0x1533,  # I210
        0x15F2,  # I225
        0x15F3,  # I225
        0x3100,  # I225
        0x3101,  # I225
        0x5502,  # I225
        0x0D9F,  # I225
        0x15F8,  # I225
        0x15F7,  # I225
        0x15FD,  # I225
    ]

    Intel82574L = [
        # Intel82574L IDs
        0x104B,  # 82566DC
        0x10F6,  # 82574L
    ]


class broadcom_ids:
    AppleBCMWLANBusInterfacePCIe = [
        0x43DC,  # BCM4355
        0x4464,  # BCM4364
        0x4488,  # BCM4377b
        0x4425,  # BCM4378 (M1)
        0x4433,  # BCM4387 (M1 Pro/Max/Ultra)
    ]

    AirPortBrcmNIC = [
        # AirPortBrcmNIC IDs
        0x43BA,  # BCM43602
        0x43A3,  # BCM4350
        0x43A0,  # BCM4360
    ]

    # Not natively supported, but supported by AirportBrcmFixup
    AirPortBrcmNICThirdParty = [
        0x4357,  # BCM43225
        0x43B1,  # BCM4352
        0x43B2,  # BCM4352 (2.4 GHz)
    ]

    AirPortBrcm4360 = [
        # AirPortBrcm4360 IDs (removed duplicates for 4360 class cards)
        0x4331,  # BCM94331
        0x4353,  # BCM943224
    ]

    AirPortBrcm4331 = [
        # AirPortBrcm4331 IDs (removed duplicates for 4331 class cards)
        0x432B,  # BCM94322
    ]

    AppleAirPortBrcm43224 = [
        # AppleAirPortBrcm43224 IDs
        0x4311,  # BCM4311 - never used by Apple
        0x4312,  # BCM4311 - never used by Apple
        0x4313,  # BCM4311 - never used by Apple
        0x4318,  # BCM4318 - never used by Apple
        0x4319,  # BCM4318 - never used by Apple
        0x431A,  # Unknown - never used by Apple
        0x4320,  # BCM4306 - never used by Apple
        0x4324,  # BCM4309 - never used by Apple
        0x4325,  # BCM4306 - never used by Apple
        0x4328,  # BCM4328
        0x432C,  # BCM4322 - never used by Apple
        0x432D,  # BCM4322 - never used by Apple
    ]

    AppleBCM5701Ethernet = [
        # AppleBCM5701Ethernet IDs
        0x1684,  # BCM5764M
        0x16B0,  # BCM57761
        0x16B4,  # BCM57765
        0x1682,  # BCM57762
        0x1686,  # BCM57766
    ]


class aquantia_ids:
    AppleEthernetAquantiaAqtion = [
        # AppleEthernetAquantiaAqtion IDs
        0x0001,  # AQC107
        0xD107,  # AQC107
        0x07B1,  # AQC107
        0x80B1,  # AQC107
        0x87B1,  # AQC107
        0x88B1,  # AQC107
        0x89B1,  # AQC107
        0x91B1,  # AQC107
        0x92B1,  # AQC107
        0x00C0,  # AQC113
        0x04C0,  # AQC113
        0x94C0,  # AQC113
        0x93C0,  # AQC113
    ]


class marvell_ids:
    MarvelYukonEthernet = [
        # AppleYukon2.kext IDs
        # AppleYukon2 supports 2 vendors (Marvell and SysKonnect)
        0x9E00,
        0x2100,
        0x9E00,
        0x2200,
        0x9E00,
        0x8100,
        0x9E00,
        0x8200,
        0x9E00,
        0x9100,
        0x9E00,
        0x9200,
        0x9000,
        0x2100,
        0x9000,
        0x2200,
        0x9000,
        0x8100,
        0x9000,
        0x8200,
        0x9000,
        0x9100,
        0x9000,
        0x9200,
        0x9E00,
        0x2200,
        0x9E00,
        0x2200,
    ]


class syskonnect_ids:
    MarvelYukonEthernet = [
        # AppleYukon2.kext IDs
        # AppleYukon2 supports 2 vendors (Marvell and SysKonnect)
        0x4365,
        0x4360,
        0x435A,
        0x4354,
        0x4362,
        0x4363,
        0x00BA,
        0x436A,
    ]


class atheros_ids:
    AtherosWifi = [
        # AirPortAtheros40 IDs
        0x0030,  # AR93xx
        0x002A,  # AR928X
        0x001C,  # AR242x / AR542x
        0x0023,  # AR5416 - never used by Apple
        0x0024,  # AR5418
    ]

# The above item was pci_data.py
# now sip_data.py:

"""
sip_data.py: System Integrity Protection Data
"""

from . import os_data


class system_integrity_protection:
    csr_values = {
        # Source: macOS 11.4 (XNU's csr.h)
        # https://opensource.apple.com/source/xnu/xnu-7195.121.3/bsd/sys/csr.h.auto.html
        "CSR_ALLOW_UNTRUSTED_KEXTS": False,  #            0x1   - Allows Unsigned Kexts           - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_UNRESTRICTED_FS": False,  #            0x2   - File System Access              - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_TASK_FOR_PID": False,  #               0x4   - Unrestricted task_for_pid()     - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_KERNEL_DEBUGGER": False,  #            0x8   - Allow Kernel Debugger           - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_APPLE_INTERNAL": False,  #             0x10  - Set AppleInternal Features      - Introduced in El Capitan  # noqa: E241
        # "CSR_ALLOW_DESTRUCTIVE_DTRACE": False,  #       0x20  - Allow destructive DTrace        - Deprecated                # noqa: E241
        "CSR_ALLOW_UNRESTRICTED_DTRACE": False,  #        0x20  - Unrestricted DTrace usage       - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_UNRESTRICTED_NVRAM": False,  #         0x40  - Unrestricted NVRAM write        - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_DEVICE_CONFIGURATION": False,  #       0x80  - Allow custom DeviceTree (iOS)   - Introduced in El Capitan  # noqa: E241
        "CSR_ALLOW_ANY_RECOVERY_OS": False,  #            0x100 - Skip BaseSystem Verification    - Introduced in Sierra      # noqa: E241
        "CSR_ALLOW_UNAPPROVED_KEXTS": False,  #           0x200 - Allow Unnotarized Kexts         - Introduced in High Sierra # noqa: E241
        "CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE": False,  # 0x400 - Override Executable Policy      - Introduced in Mojave      # noqa: E241
        "CSR_ALLOW_UNAUTHENTICATED_ROOT": False,  #       0x800 - Allow Root Volume Mounting      - Introduced in Big Sur     # noqa: E241
    }

    csr_values_extended = {
        "CSR_ALLOW_UNTRUSTED_KEXTS": {
            "name": "CSR_ALLOW_UNTRUSTED_KEXTS",
            "description": "Allows Unsigned Kexts to be hot loaded from disk",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x1,
        },
        "CSR_ALLOW_UNRESTRICTED_FS": {
            "name": "CSR_ALLOW_UNRESTRICTED_FS",
            "description": "File System Access",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x2,
        },
        "CSR_ALLOW_TASK_FOR_PID": {
            "name": "CSR_ALLOW_TASK_FOR_PID",
            "description": "Unrestricted task_for_pid()",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x4,
        },
        "CSR_ALLOW_KERNEL_DEBUGGER": {
            "name": "CSR_ALLOW_KERNEL_DEBUGGER",
            "description": "Allow Kernel Debugger",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x8,
        },
        "CSR_ALLOW_APPLE_INTERNAL": {
            "name": "CSR_ALLOW_APPLE_INTERNAL",
            "description": "Set AppleInternal Features",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x10,
        },
        # "CSR_ALLOW_DESTRUCTIVE_DTRACE": {
        #     "name": "CSR_ALLOW_DESTRUCTIVE_DTRACE",
        #     "description": "Allow destructive DTrace",
        #     "deprecated": True,
        #     "introduced": os_data.os_data.el_capitan.value,
        #     "introduced_friendly": "El Capitan",
        #     "value": 0x20,
        # },
        "CSR_ALLOW_UNRESTRICTED_DTRACE": {
            "name": "CSR_ALLOW_UNRESTRICTED_DTRACE",
            "description": "Unrestricted DTrace usage",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x20,
        },
        "CSR_ALLOW_UNRESTRICTED_NVRAM": {
            "name": "CSR_ALLOW_UNRESTRICTED_NVRAM",
            "description": "Unrestricted NVRAM write",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x40,
        },
        "CSR_ALLOW_DEVICE_CONFIGURATION": {
            "name": "CSR_ALLOW_DEVICE_CONFIGURATION",
            "description": "Allow custom DeviceTree (iOS)",
            "introduced": os_data.os_data.el_capitan.value,
            "introduced_friendly": "El Capitan",
            "value": 0x80,
        },
        "CSR_ALLOW_ANY_RECOVERY_OS": {
            "name": "CSR_ALLOW_ANY_RECOVERY_OS",
            "description": "Skip BaseSystem Verification",
            "introduced": os_data.os_data.sierra.value,
            "introduced_friendly": "Sierra",
            "value": 0x100,
        },
        "CSR_ALLOW_UNAPPROVED_KEXTS": {
            "name": "CSR_ALLOW_UNAPPROVED_KEXTS",
            "description": "Allow Unnotarized Kexts to be hot loaded from disk",
            "introduced": os_data.os_data.high_sierra.value,
            "introduced_friendly": "High Sierra",
            "value": 0x200,
        },
        "CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE": {
            "name": "CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE",
            "description": "Override Executable Policy",
            "introduced": os_data.os_data.mojave.value,
            "introduced_friendly": "Mojave",
            "value": 0x400,
        },
        "CSR_ALLOW_UNAUTHENTICATED_ROOT": {
            "name": "CSR_ALLOW_UNAUTHENTICATED_ROOT",
            "description": "Allow Root Volume Mounting",
            "introduced": os_data.os_data.big_sur.value,
            "introduced_friendly": "Big Sur",
            "value": 0x800,
        },
    }

    root_patch_sip_mojave = [
        # Variables required to root patch in Mojave and Catalina
        "CSR_ALLOW_UNTRUSTED_KEXTS",  #            0x1   - Required for hot loading modded Kexts
        "CSR_ALLOW_UNRESTRICTED_FS",  #            0x2   - Mount and Edit System Partitions
        "CSR_ALLOW_UNAPPROVED_KEXTS",  #           0x200 - Required for hot loading modded Kexts
    ]

    root_patch_sip_big_sur = [
        # Variables required to root patch in Big Sur and Monterey
        "CSR_ALLOW_UNRESTRICTED_FS",  #            0x2   - Required to mount and edit root volume, as well as load modded platform binaries
        "CSR_ALLOW_UNAUTHENTICATED_ROOT",  #       0x800 - Required to avoid KC mismatch kernel panic
    ]

    root_patch_sip_big_sur_3rd_part_kexts = [
        # Variables required to root patch in Big Sur and Monterey with 3rd party kexts
        "CSR_ALLOW_UNTRUSTED_KEXTS",  #            0x1   - Required for Aux Cache in Big Sur+
        "CSR_ALLOW_UNRESTRICTED_FS",  #            0x2   - Required to mount and edit root volume, as well as load modded platform binaries
        "CSR_ALLOW_UNAUTHENTICATED_ROOT",  #       0x800 - Required to avoid KC mismatch kernel panic
        "CSR_ALLOW_UNAPPROVED_KEXTS",  #           0x200 - Required for Aux Cache in Big Sur+
    ]

    root_patch_sip_ventura = [
        # Variables required to root patch in Ventura
        "CSR_ALLOW_UNTRUSTED_KEXTS",  #            0x1   - Required for Aux Cache in Big Sur+
        "CSR_ALLOW_UNRESTRICTED_FS",  #            0x2   - Required to mount and edit root volume, as well as load modded platform binaries
        "CSR_ALLOW_UNAUTHENTICATED_ROOT",  #       0x800 - Required to avoid KC mismatch kernel panic
    ]


    # CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE (introduced with Mojave):
    # This bit is quite strange and was originally assumed to be required for modded platform binaries
    # However after extensive testing, this doesn't seem true. In addition, this bit is never flipped via
    # 'csrutil disable'. Usage within the kernel is not present.

"""
smbios_data.py: SMBIOS Dictionary for model data
"""

"""
Terms:
  AAPL: AppleInternal Model (ie. not released to public)
  Board ID: The board ID is a unique identifier for the motherboard.
  Firmware Features: Hex bitmask denoting supported abilities of firmware. (ie. APFS, Large BaseSystem, etc.)
  Secure Boot Model: T2/Apple Silicon Model Identifier
  CPU Generation: Stock CPU supported by the board (generally lowest generation)
  Wireless Model: Driver used for wireless networking
  Bluetooth Model: Chipset model
  Screen Size: Size of the screen in inches (generally lowest size if multiple in same model)
  UGA Graphics: If model needs UGA to GOP conversion
  Ethernet Chipset: Vendor of the ethernet chipset (if multiple unique chipset within Vendor, chipset name is used)
  nForce Chipset: If model uses nForce chipset
  Switchable GPUs: If model uses a GMUX
  Stock GPUs: GPUs variations shipped

Reference:
  https://github.com/acidanthera/OpenCorePkg/blob/master/Library/OcMacInfoLib/AutoGenerated.c
"""

from ..detections import device_probe

from . import (
    cpu_data,
    os_data,
    bluetooth_data
)


smbios_dictionary = {
    "MacBook1,1": {
        "Marketing Name": "MacBook (13-inch)",
        "Board ID": "Mac-F4208CC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 13,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBook2,1": {
        "Marketing Name": "MacBook (13-inch Late 2006)",
        "Board ID": "Mac-F4208CA9",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 13,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBook3,1": {
        "Marketing Name": "MacBook (13-inch Late 2007)",
        "Board ID": "Mac-F22788C8",
        "FirmwareFeatures": "0xC0001407",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 13,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_X3100
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBook4,1": {
        "Marketing Name": "MacBook (13-inch, Early 2008)",
        "Board ID": "Mac-F22788A9",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_X3100
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBook5,1": {
        "Marketing Name": "MacBook (13-inch, Aluminum, Late 2008)",
        "Board ID": "Mac-F42D89C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBook5,1_v2": {
        "Board ID": "Mac-F42D89A9",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBook5,2": {
        "Marketing Name": "MacBook (13-inch, Mid 2009)",
        "Board ID": "Mac-F22788AA",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "Legacy iSight": True,
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBook6,1": {
        "Marketing Name": "MacBook (13-inch, Late 2009)",
        "Board ID": "Mac-F22C8AC8",
        "FirmwareFeatures": "0xFC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBook7,1": {
        "Marketing Name": "MacBook (13-inch, Mid 2010)",
        "Board ID": "Mac-F22C89C8",
        "FirmwareFeatures": "0xFC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBook8,1": {
        "Marketing Name": "MacBook (Retina, 12-inch, Early 2015)",
        "Board ID": "Mac-BE0E8AC46FE800CC",
        "FirmwareFeatures": "0xFC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 12,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBook8,1_v2": {
        "Board ID": "Mac-F305150B0C7DEEEF",
        "FirmwareFeatures": "0xFC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 12,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBook9,1": {
        "Marketing Name": "MacBook (Retina, 12-inch, Early 2016)",
        "Board ID": "Mac-9AE82516C7C6B903",
        "FirmwareFeatures": "0x8FC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 12,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBook10,1": {
        "Marketing Name": "MacBook (Retina, 12-inch, 2017)",
        "Board ID": "Mac-EE2EBD4B90B839A8",
        "FirmwareFeatures": "0x8FC0FE13F",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 12,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir1,1": {
        "Marketing Name": "MacBook Air (Original)",
        "Board ID": "Mac-F42C8CC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_X3100
        ],
        "Stock Storage": [
            "SATA 1.8",
        ],
    },
    "MacBookAir2,1": {
        "Marketing Name": "MacBook Air (Mid 2009)",
        "Board ID": "Mac-F42D88C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "nForce Chipset": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 1.8",
        ],
    },
    "MacBookAir3,1": {
        "Marketing Name": "MacBook Air (11-inch, Late 2010)",
        "Board ID": "Mac-942452F5819B1C1B",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 11,
        "nForce Chipset": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir3,2": {
        "Marketing Name": "MacBook Air (13-inch, Late 2010)",
        "Board ID": "Mac-942C5DF58193131B",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "nForce Chipset": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir4,1": {
        "Marketing Name": "MacBook Air (11-inch, Mid 2011)",
        "Board ID": "Mac-C08A6BB70A942AC2",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 11,
        "Ethernet Chipset": "Broadcom",  # Set for Apple Thunderbolt Adapter
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir4,2": {
        "Marketing Name": "MacBook Air (13-inch, Mid 2011)",
        "Board ID": "Mac-742912EFDBEE19B3",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 13,
        "Ethernet Chipset": "Broadcom",  # Set for Apple Thunderbolt Adapter
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir5,1": {
        "Marketing Name": "MacBook Air (11-inch, Mid 2012)",
        "Board ID": "Mac-66F35F19FE2A0D05",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 11,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir5,2": {
        "Marketing Name": "MacBook Air (13-inch, Mid 2012)",
        "Board ID": "Mac-2E6FAB96566FE58C",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir6,1": {
        "Marketing Name": "MacBook Air (11-inch, Mid 2013)",
        "Board ID": "Mac-35C1E88140C3E6CF",
        "FirmwareFeatures": "0xE00FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 11,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookAir6,2": {
        "Marketing Name": "MacBook Air (13-inch, Mid 2013)",
        "Board ID": "Mac-7DF21CB3ED6977E5",
        "FirmwareFeatures": "0xE00FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir7,1": {
        "Marketing Name": "MacBook Air (11-inch, Early 2015)",
        "Board ID": "Mac-9F18E312C5C2BF0B",
        "FirmwareFeatures": "0x8FF0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 11,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir7,2": {
        "Marketing Name": "MacBook Air (13-inch, Early 2015)",
        "Board ID": "Mac-937CB26E2E02BB01",
        "FirmwareFeatures": "0x8FF0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir8,1": {
        "Marketing Name": "MacBook Air (Retina, 13-inch, 2018)",
        "Board ID": "Mac-827FAC58A8FDFA22",
        "FirmwareFeatures": "0x8FD8FF42E",
        "SecureBootModel": "j140k",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.sonoma,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir8,1_v2": {
        "Board ID": "Mac-112818653D3AABFC",
        "FirmwareFeatures": "0x8FD8FF42E",
        "SecureBootModel": "j140k",  # TODO: Verify
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.sonoma,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "AAPL_MacBookAir8,1": {
        # AppleInternal MacBookAir8,1
        # True Model unknown
        "Board ID": "Mac-827FAC58A8FDFA22",
        "FirmwareFeatures": "0x8FD8FF42E",
        "SecureBootModel": "x589amlu",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.sonoma,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir8,2": {
        "Marketing Name": "MacBook Air (Retina, 13-inch, 2019)",
        "Board ID": "Mac-226CB3C6A851A671",
        "FirmwareFeatures": "0x8FD8FF42E",
        "SecureBootModel": "j140a",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.sonoma,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir9,1": {
        "Marketing Name": "MacBook Air (Retina, 13-inch, 2020)",
        "Board ID": "Mac-0CFF9C7C2B63DF8D",
        "FirmwareFeatures": "0x8FFAFF06E",
        "SecureBootModel": "j230k",
        "CPU Generation": cpu_data.CPUGen.ice_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ice_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "AAPL_MacBookAir9,1": {
        # AppleInternal MacBookAir9,1
        # True Model unknown
        "Board ID": "Mac-0CFF9C7C2B63DF8D",
        "FirmwareFeatures": "0x8FFAFF06E",
        "SecureBootModel": "x589icly",
        "CPU Generation": cpu_data.CPUGen.ice_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ice_Lake
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir10,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j313",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": None,
        "Stock GPUs": [], # TODO: Add Apple Silicon GPU
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookAir10,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j313",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro1,1": {
        "Marketing Name": "MacBook Pro (original)",
        "Board ID": "Mac-F425BEC8",
        "FirmwareFeatures": "",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 15,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro1,2": {
        "Marketing Name": "MacBook Pro (17-inch)",
        "Board ID": "Mac-F42DBEC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 17,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro2,1": {
        "Marketing Name": "MacBook Pro (15-inch Core 2 Duo)",
        "Board ID": "Mac-F42189C8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 17,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro2,2": {
        "Marketing Name": "MacBook Pro (15-inch Core 2 Duo)",
        "Board ID": "Mac-F42187C8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 15,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro3,1": {
        "Marketing Name": "MacBook Pro (15-inch,  2.4 2.2GHz)",
        "Board ID": "Mac-F4238BC8",
        "FirmwareFeatures": "0xC0001407",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 15,  # Shipped with 17 as well
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro3,1_v2": {
        "Board ID": "Mac-F42388C8",
        "FirmwareFeatures": "0xC0001407",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Screen Size": 15,  # Shipped with 17 as well
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro4,1": {
        "Marketing Name": "MacBook Pro (17-inch, Early 2008)",
        "Board ID": "Mac-F42C89C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,  # Shipped with 17 as well
        "Switchable GPUs": True,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro4,1_v2": {
        "Board ID": "Mac-F42C86C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,  # Shipped with 17 as well
        "Switchable GPUs": True,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "MacBookPro5,1": {
        "Marketing Name": "MacBook Pro (15-inch, Late 2008)",
        "Board ID": "Mac-F42D86C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro5,1_v2": {
        "Board ID": "Mac-F42D86A9",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro5,2": {
        "Marketing Name": "MacBook Pro (17-inch, Early 2009)",
        "Board ID": "Mac-F2268EC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 17,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro5,3": {
        "Marketing Name": "MacBook Pro (15-inch, 2.53GHz, Mid 2009)",
        "Board ID": "Mac-F22587C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro5,4": {
        "Marketing Name": "MacBook Pro (15-inch, 2.53GHz, Mid 2009)",
        "Board ID": "Mac-F22587A1",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro5,5": {
        "Marketing Name": "MacBook Pro (13-inch, Mid 2009)",
        "Board ID": "Mac-F2268AC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro6,1": {
        "Marketing Name": "MacBook Pro (17-inch, Mid 2010)",
        "Board ID": "Mac-F22589C8",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 17,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Iron_Lake,
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro6,2": {
        "Marketing Name": "MacBook Pro (15-inch, Mid 2010)",
        "Board ID": "Mac-F22586C8",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Iron_Lake,
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro7,1": {
        "Marketing Name": "MacBook Pro (13-inch, Mid 2010)",
        "Board ID": "Mac-F222BEC8",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Screen Size": 13,
        "Ethernet Chipset": "Broadcom",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro8,1": {
        "Marketing Name": "MacBook Pro (13-inch, Early 2011)",
        "Board ID": "Mac-94245B3640C91C81",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 13,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro8,2": {
        "Marketing Name": "MacBook Pro (15-inch, Early 2011)",
        "Board ID": "Mac-94245A3940C91C80",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro8,3": {
        "Marketing Name": "MacBook Pro (17-inch, Early 2011)",
        "Board ID": "Mac-942459F5819B171B",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 17,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "AAPL_MacBookPro8,3": {
        # AppleInternal MacBookPro8,3
        # True Model unknown
        "Board ID": "Mac-94245AF5819B141B",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Screen Size": 17,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro9,1": {
        "Marketing Name": "MacBook Pro (15-inch, Mid 2012)",
        "Board ID": "Mac-4B7AC7E43945597E",
        "FirmwareFeatures": "0xC00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
            device_probe.NVIDIA.Archs.Kepler
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro9,2": {
        "Marketing Name": "MacBook Pro (13-inch, Mid 2012)",
        "Board ID": "Mac-6F01561E16C75D06",
        "FirmwareFeatures": "0xC10DF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 13,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "MacBookPro10,1": {
        "Marketing Name": "MacBook Pro (Retina, Mid 2012)",
        "Board ID": "Mac-C3EC7CD22292981F",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
            device_probe.NVIDIA.Archs.Kepler
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookPro10,2": {
        "Marketing Name": "MacBook Pro (Retina, 13-inch, Late 2012)",
        "Board ID": "Mac-AFD8A9D944EA4843",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
        ],
        "Stock Storage": [
            "mSATA",
        ],
    },
    "MacBookPro11,1": {
        "Marketing Name": "MacBook Pro (Retina, 13-inch, Late 2013)",
        "Board ID": "Mac-189A3D4F975D5FFC",
        "FirmwareFeatures": "0xEB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro11,2": {
        "Marketing Name": "MacBook Pro (Retina, 15-inch, Mid 2014)",
        "Board ID": "Mac-3CBD00234E554E41",
        "FirmwareFeatures": "0xEB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 15,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro11,3": {
        "Marketing Name": "MacBook Pro (Retina, 15-inch, Late 2013)",
        "Board ID": "Mac-2BD1B31983FE1663",
        "FirmwareFeatures": "0xEB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.NVIDIA.Archs.Kepler,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro11,4": {
        "Marketing Name": "MacBook Pro (Retina, 15-inch, Mid 2015)",
        "Board ID": "Mac-06F11FD93F0323C5",
        "FirmwareFeatures": "0x8EB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 15,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro11,5": {
        "Marketing Name": "MacBook Pro (Retina, 15-inch, Mid 2014)",
        "Board ID": "Mac-06F11F11946D27C5",
        "FirmwareFeatures": "0x8EB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.AMD.Archs.Legacy_GCN_7000
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro12,1": {
        "Marketing Name": "MacBook Pro (Retina, 13-inch, Early 2015)",
        "Board ID": "Mac-E43C1C25D4880AD6",
        "FirmwareFeatures": "0x8FD0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro13,1": {
        "Marketing Name": "MacBook Pro (13-inch, 2016, Two Thunderbolt 3 ports)",
        "Board ID": "Mac-473D31EABEB93F9B",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro13,2": {
        "Marketing Name": "MacBook Pro (13-inch, 2016, Four Thunderbolt 3 Ports)",
        "Board ID": "Mac-66E35819EE2D0D05",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro13,3": {
        "Marketing Name": "MacBook Pro (15-inch, 2016)",
        "Board ID": "Mac-A5C67F76ED83108C",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
            device_probe.AMD.Archs.Polaris
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro14,1": {
        "Marketing Name": "MacBook Pro (13-inch, 2017, Two Thunderbolt 3 ports)",
        "Board ID": "Mac-B4831CEBD52A0C4C",
        "FirmwareFeatures": "0x8FF0FF57E",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro14,2": {
        "Marketing Name": "MacBook Pro (13-inch, 2017, Four Thunderbolt 3 Ports)",
        "Board ID": "Mac-CAD6701F7CEA0921",
        "FirmwareFeatures": "0x8FF0FF57E",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro14,3": {
        "Marketing Name": "MacBook Pro (15-inch, 2017)",
        "Board ID": "Mac-551B86E5744E2388",
        "FirmwareFeatures": "0x8FF0FF57E",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703_UART,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
            device_probe.AMD.Archs.Polaris
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro15,1": {
        "Marketing Name": "MacBook Pro (15-inch, 2018)",
        "Board ID": "Mac-937A206F2EE63C01",
        "FirmwareFeatures": "0x8FD8FF426",
        "SecureBootModel": "j680",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Polaris
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro15,2": {
        "Marketing Name": "MacBook Pro (13-inch, 2018, Four Thunderbolt 3 Ports)",
        "Board ID": "Mac-827FB448E656EC26",
        "FirmwareFeatures": "0x8FD8FF426",
        "SecureBootModel": "j132",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro15,3": {
        "Marketing Name": "MacBook Pro (15-inch, 2019)",
        "Board ID": "Mac-1E7E29AD0135F9BC",
        "FirmwareFeatures": "0x8FD8FF426",
        "SecureBootModel": "j780",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 15,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Vega
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro15,4": {
        "Marketing Name": "MacBook Pro (13-inch, 2019, Two Thunderbolt 3 ports)",
        "Board ID": "Mac-53FDB3D8DB8CA971",
        "FirmwareFeatures": "0x8FD8FF426",
        "SecureBootModel": "j213",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro16,1": {
        "Marketing Name": "MacBook Pro (16-inch, 2019)",
        "Board ID": "Mac-E1008331FDC96864",
        "FirmwareFeatures": "0x8FDAFF066",
        "SecureBootModel": "j152f",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 16,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Navi
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro16,2": {
        "Marketing Name": "MacBook Pro (13-inch, 2020, Four Thunderbolt 3 ports)",
        "Board ID": "Mac-5F9802EFE386AA28",
        "FirmwareFeatures": "0x8FFFFFF7F",
        "SecureBootModel": "j214k",
        "CPU Generation": cpu_data.CPUGen.ice_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Ice_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro16,3": {
        "Marketing Name": "MacBook Pro (13-inch, 2020, Two Thunderbolt 3 ports)",
        "Board ID": "Mac-E7203C0F68AA0004",
        "FirmwareFeatures": "0x8FDAFF066",
        "SecureBootModel": "j223",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro16,4": {
        "Marketing Name": "MacBook Pro (16-inch, 2019)",
        "Board ID": "Mac-A61BADE1FDAD7B05",
        "FirmwareFeatures": "0x8FDAFF066",
        "SecureBootModel": "j215",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Screen Size": 16,
        "Switchable GPUs": True,
        "Ethernet Chipset": None,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Navi
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro17,1": {
        "Marketing Name": "MacBook Pro (13-inch, M1, 2020)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j293",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 13,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro18,1": {
        "Marketing Name": "MacBook Pro (16-inch, 2021)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j316s",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 16,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro18,2": {
        "Marketing Name": "MacBook Pro (16-inch, 2021)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j316c",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 16,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro18,3": {
        "Marketing Name": "MacBook Pro (14-inch, 2021)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j314s",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 14,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacBookPro18,4": {
        "Marketing Name": "MacBook Pro (14-inch, 2021)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j314c",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 14,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "Mac14,7": {
        "Marketing Name": "MacBook Pro (13-inch, M2, 2022)",
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "J493AP",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Screen Size": 14,
        "Ethernet Chipset": None,
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "Macmini1,1": {
        "Marketing Name": "Mac mini (Early 2006)",
        "Board ID": "Mac-F4208EC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "Macmini2,1": {
        "Marketing Name": "Mac mini (Mid 2007)",
        "Board ID": "Mac-F4208EAA",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "Ethernet Chipset": "Marvell",
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950
        ],
        "Stock Storage": [
            "SATA 2.5",
            "PATA",
        ],
    },
    "Macmini3,1": {
        "Marketing Name": "Mac mini (Early 2009)",
        "Board ID": "Mac-F22C86C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini4,1": {
        "Marketing Name": "Mac mini (Mid 2010)",
        "Board ID": "Mac-F2208EC8",
        "FirmwareFeatures": "0xC00C9423",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2070,
        "Ethernet Chipset": "Broadcom",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini5,1": {
        "Marketing Name": "Mac mini (Mid 2011)",
        "Board ID": "Mac-8ED6AF5B48C039E1",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini5,2": {
        "Marketing Name": "Mac mini (Mid 2011)",
        "Board ID": "Mac-4BC72D62AD45599E",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini5,3": {
        "Marketing Name": "Mac mini Server (Mid 2011)",
        "Board ID": "Mac-7BA5B2794B2CDB12",
        "FirmwareFeatures": "0xD00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini6,1": {
        "Marketing Name": "Mac mini (Late 2012)",
        "Board ID": "Mac-031AEE4D24BFF0B1",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini6,2": {
        "Marketing Name": "Mac mini Server (Late 2012)",
        "Board ID": "Mac-F65AE981FFA204ED",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
        ],
        "Stock Storage": [
            "SATA 2.5",
        ],
    },
    "Macmini7,1": {
        "Marketing Name": "Mac mini (Late 2014)",
        "Board ID": "Mac-35C5E08120C7EEAF",
        "FirmwareFeatures": "0x8E00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "SATA 2.5",
            "NVMe",
        ],
    },
    "Macmini8,1": {
        "Marketing Name": "Mac mini (2018)",
        "Board ID": "Mac-7BA5B2DFE22DDD8C",
        "FirmwareFeatures": "0x8FD8FF466",
        "SecureBootModel": "j174",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "Macmini9,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j274",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "iMac4,1": {
        "Marketing Name": "iMac (20-inch, Early 2006)",
        "Board ID": "Mac-F42786C8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.AMD.Archs.R500,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac4,2": {
        "Marketing Name": "iMac (17-inch, Mid 2006)",
        "Board ID": "Mac-F4218EC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.yonah.value,
        "Max OS Supported": os_data.os_data.snow_leopard,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac5,1": {
        "Marketing Name": "iMac (17-inch, Late 2006)",
        "Board ID": "Mac-F4228EC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.AMD.Archs.R500,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac5,2": {
        "Marketing Name": "iMac (17-inch, Late 2006 CD)",
        "Board ID": "Mac-F4218EC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac6,1": {
        "Marketing Name": "iMac (24-inch, Late 2006)",
        "Board ID": "Mac-F4218FC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Legacy iSight": True,
        "Stock GPUs": [
            device_probe.AMD.Archs.R500,
            device_probe.NVIDIA.Archs.Curie
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac7,1": {
        "Marketing Name": "iMac (20-inch, Mid 2007)",
        "Board ID": "Mac-F42386C8",
        "FirmwareFeatures": "0xC0001407",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn,  # Stock models shipped with Conroe
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac7,1_v2": {
        "Board ID": "Mac-F4238CC8",
        "FirmwareFeatures": "0xC0001407",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn,  # Stock models shipped with Conroe
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac8,1": {
        "Marketing Name": "iMac (20-inch, Early 2008)",
        "Board ID": "Mac-F227BEC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac8,1_v2": {
        "Board ID": "Mac-F226BEC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "UGA Graphics": True,
        "Ethernet Chipset": "Marvell",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "iMac9,1": {
        "Marketing Name": "iMac (20-inch, Mid 2009)",
        "Board ID": "Mac-F2218FA9",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla,
            device_probe.AMD.Archs.TeraScale_1,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac9,1_v2": {
        "Board ID": "Mac-F2218EA9",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac9,1_v3": {
        "Board ID": "Mac-F2218EC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac9,1_v4": {
        "Board ID": "Mac-F2218FC8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac10,1": {
        "Marketing Name": "iMac (27-inch, Late 2009)",
        "Board ID": "Mac-F221DCC8",
        # "Board ID": "Mac-F2268CC8",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac10,1_v2": {
        "Board ID": "Mac-F2268CC8",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac10,1_v3": {
        "Board ID": "Mac-F2268DC8",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Nvidia",
        "nForce Chipset": True,
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac11,1": {
        "Marketing Name": "iMac (27-inch, Late 2009)",
        "Board ID": "Mac-F2268DAE",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac11,2": {
        "Marketing Name": "iMac (21.5-inch, Mid 2010)",
        "Board ID": "Mac-F2238AC8",
        "FirmwareFeatures": "0xC00C9423",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.AMD.Archs.TeraScale_2,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac11,3": {
        "Marketing Name": "iMac (27-inch, Mid 2010)",
        "Board ID": "Mac-F2238BAE",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.AMD.Archs.TeraScale_2,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac12,1": {
        "Marketing Name": "iMac (21.5-inch, Mid 2011)",
        "Board ID": "Mac-942B5BF58194151B",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac12,2": {
        "Marketing Name": "iMac (27-inch, Mid 2011)",
        "Board ID": "Mac-942B59F58194171B",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "AAPL_iMac12,2": {
        # AppleInternal iMac12,2
        # True Model unknown
        "Board ID": "Mac-942B5B3A40C91381",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.sandy_bridge.value,
        "Max OS Supported": os_data.os_data.high_sierra,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Broadcom",
        "Socketed GPUs": "MXM",
        "Stock GPUs": [
            device_probe.Intel.Archs.Sandy_Bridge,
            device_probe.AMD.Archs.TeraScale_2,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "iMac13,1": {
        "Marketing Name": "iMac (21.5-inch, Late 2012)",
        "Board ID": "Mac-00BE6ED71E35EB86",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
            device_probe.NVIDIA.Archs.Kepler,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "mSATA"
        ],
    },
    "iMac13,2": {
        "Marketing Name": "iMac (27-inch, Late 2012)",
        "Board ID": "Mac-FC02E91DDD3FA6A4",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
            device_probe.NVIDIA.Archs.Kepler,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "mSATA"
        ],
    },
    "iMac13,3": {
        "Marketing Name": "iMac (21.5-inch, Early 2013)",
        "Board ID": "Mac-7DF2A3B5E5D671ED",
        "FirmwareFeatures": "0xE00DE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4360,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v1,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Ivy_Bridge,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "mSATA"
        ],
    },
    "iMac14,1": {
        "Marketing Name": "iMac (21.5-inch, Late 2013)",
        "Board ID": "Mac-031B6874CF7F642A",
        "FirmwareFeatures": "0xFB0FF577",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac14,2": {
        "Marketing Name": "iMac (27-inch, Late 2013)",
        "Board ID": "Mac-27ADBB7B4CEE8E61",
        "FirmwareFeatures": "0xE00FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.NVIDIA.Archs.Kepler,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac14,3": {
        "Marketing Name": "iMac (21.5-inch, Late 2013)",
        "Board ID": "Mac-77EB7D7DAF985301",
        "FirmwareFeatures": "0xE00FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.catalina,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.NVIDIA.Archs.Kepler,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac14,4": {
        "Marketing Name": "iMac (21.5-inch, Mid 2014)",
        "Board ID": "Mac-81E3E92DD6088272",
        "FirmwareFeatures": "0xF00FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac15,1": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, Mid 2015)",
        "Board ID": "Mac-42FD25EABCABB274",
        "FirmwareFeatures": "0xF80FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.AMD.Archs.Legacy_GCN_7000,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac15,1_v2": {
        "Board ID": "Mac-FA842E06C61E91C5",
        "FirmwareFeatures": "0xF80FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
            device_probe.AMD.Archs.Legacy_GCN_7000,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac16,1": {
        "Marketing Name": "iMac (21.5-inch, Late 2015)",
        "Board ID": "Mac-A369DDC4E67F1C45",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac16,2": {
        "Marketing Name": "iMac (Retina 4K, 21.5-inch, Late 2015)",
        "Board ID": "Mac-FFE5EF870D7BA81A",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.broadwell.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Broadwell,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac17,1": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, Late 2015)",
        "Board ID": "Mac-DB15BD556843C820",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
            device_probe.AMD.Archs.Legacy_GCN_8000,
            device_probe.AMD.Archs.Legacy_GCN_9000,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac17,1_v2": {
        "Board ID": "Mac-65CE76090165799A",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
            device_probe.AMD.Archs.Legacy_GCN_8000,
            device_probe.AMD.Archs.Legacy_GCN_9000,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac17,1_v3": {
        "Board ID": "Mac-B809C3757DA9BB8D",
        "FirmwareFeatures": "0x8FC0FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Skylake,
            device_probe.AMD.Archs.Legacy_GCN_8000,
            device_probe.AMD.Archs.Legacy_GCN_9000,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac18,1": {
        "Marketing Name": "iMac (21.5-inch, 2017)",
        "Board ID": "Mac-4B682C642B45593E",
        "FirmwareFeatures": "0x8FD0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac18,2": {
        "Marketing Name": "iMac (Retina 4K, 21.5-inch, 2017)",
        "Board ID": "Mac-77F17D7DA9285301",
        "FirmwareFeatures": "0x8FD0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
            device_probe.AMD.Archs.Polaris,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac18,3": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, 2017)",
        "Board ID": "Mac-BE088AF8C5EB4FA2",
        "FirmwareFeatures": "0x8FD0FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.kaby_lake.value,
        "Max OS Supported": os_data.os_data.ventura,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20703,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Kaby_Lake,
            device_probe.AMD.Archs.Polaris,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac19,1": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, 2019)",
        "Board ID": "Mac-AA95B1DDAB278B95",
        "FirmwareFeatures": "0x8FD8FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Polaris,
            device_probe.AMD.Archs.Vega,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "AAPL_iMac19,1": {
        # AppleInternal iMac19,1 unit
        "Board ID": "Mac-CF21D135A7D34AA6",
        "FirmwareFeatures": "0x8FD8FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Polaris,
            device_probe.AMD.Archs.Vega,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac19,2": {
        "Marketing Name": "iMac (Retina 4K, 21.5-inch, 2019)",
        "Board ID": "Mac-63001698E7A34814",
        "FirmwareFeatures": "0x8FD8FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Coffee_Lake,
            device_probe.AMD.Archs.Polaris,
            device_probe.AMD.Archs.Vega,
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe"
        ],
    },
    "iMac20,1": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, 2020)",
        "Board ID": "Mac-CFF7D910A743CAAF",
        "FirmwareFeatures": "0x8FFB3F066",
        "SecureBootModel": "j185",
        "CPU Generation": cpu_data.CPUGen.comet_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Comet_Lake,
            device_probe.AMD.Archs.Navi,
        ],
        "Stock Storage": [
            "NVMe"
        ],
    },
    "iMac20,2": {
        "Marketing Name": "iMac (Retina 5K, 27-inch, 2020)",
        "Board ID": "Mac-AF89B6D9451A490B",
        "FirmwareFeatures": "0x8FFB3F066",
        "SecureBootModel": "j185f",
        "CPU Generation": cpu_data.CPUGen.comet_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Broadcom",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.Intel.Archs.Comet_Lake,
            device_probe.AMD.Archs.Navi,
        ],
        "Stock Storage": [
            "NVMe"
        ],
    },
    "iMac21,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j456",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe"
        ],
    },
    "iMac21,2": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j457",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe"
        ],
    },
    "iMacPro1,1": {
        "Marketing Name": "iMac Pro (2017)",
        "Board ID": "Mac-7BA5B2D9E42DDD94",
        "FirmwareFeatures": "0xFD8FF53E",
        "SecureBootModel": "j137",
        "CPU Generation": cpu_data.CPUGen.skylake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Aquantia",
        "Dual DisplayPort Display": True,
        "Stock GPUs": [
            device_probe.AMD.Archs.Vega,
        ],
        "Stock Storage": [
            "NVMe"
        ],
    },
    "MacPro1,1": {
        "Marketing Name": "Mac Pro",
        "Board ID": "Mac-F4208DC8",
        "FirmwareFeatures": "0x80000015",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "UGA Graphics": True,
        "Ethernet Chipset": "Intel 80003ES2LAN",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Curie
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "MacPro2,1": {
        "Marketing Name": "Mac Pro",
        "Board ID": "Mac-F4208DA9",
        "FirmwareFeatures": "0xC0000015",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "UGA Graphics": True,
        "Ethernet Chipset": "Intel 80003ES2LAN",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Curie
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "MacPro3,1": {
        "Marketing Name": "Mac Pro (Early 2008)",
        "Board ID": "Mac-F42C88C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm43224,
        "Bluetooth Model": bluetooth_data.bluetooth_data.APPLE_CSR,
        "UGA Graphics": True,
        "Ethernet Chipset": "Intel 80003ES2LAN",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_1,
            device_probe.AMD.Archs.Polaris,

        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "MacPro4,1": {
        "Marketing Name": "Mac Pro (Early 2009)",
        "Board ID": "Mac-F221BEC8",
        "FirmwareFeatures": "0xE001F537",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": device_probe.Atheros.Chipsets.AirPortAtheros40,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Intel 82574L",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla,
            device_probe.AMD.Archs.Polaris,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "MacPro5,1": {
        "Marketing Name": "Mac Pro (Mid 2010)",
        "Board ID": "Mac-F221BEC8",
        "FirmwareFeatures": "0xE80FE137",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.mojave,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirPortBrcm4331,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM2046,
        "Ethernet Chipset": "Intel 82574L",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.AMD.Archs.TeraScale_2,
            device_probe.AMD.Archs.Polaris,
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    "MacPro6,1": {
        "Marketing Name": "Mac Pro (Late 2013)",
        "Board ID": "Mac-F60DEB81FF30ACF6",
        "FirmwareFeatures": "0x8E90FF576",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.ivy_bridge.value,
        "Max OS Supported": os_data.os_data.monterey,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [
            device_probe.AMD.Archs.Legacy_GCN_7000
        ],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "MacPro7,1": {
        "Marketing Name": "Mac Pro (2019)",
        "Board ID": "Mac-27AD2F918AE68F61",
        "FirmwareFeatures": "0x8FDAFF066",
        "SecureBootModel": "j160",
        "CPU Generation": cpu_data.CPUGen.coffee_lake.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.UART,
        "Ethernet Chipset": "Aquantia",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.AMD.Archs.Polaris,
            device_probe.AMD.Archs.Vega,
            device_probe.AMD.Archs.Navi
        ],
        "Stock Storage": [
            "SATA 3.5",
            "NVMe",
        ],
    },
    "Xserve1,1": {
        "Marketing Name": "Xserve (Late 2006)",
        "Board ID": "Mac-F4208AC8",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.conroe.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "UGA Graphics": True,
        "Ethernet Chipset": "Intel 80003ES2LAN",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "Xserve2,1": {
        "Marketing Name": "Xserve (Early 2008)",
        "Board ID": "Mac-F42289C8",
        "FirmwareFeatures": "0xC0001403",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.lion,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "UGA Graphics": True,
        "Ethernet Chipset": "Intel 80003ES2LAN",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.AMD.Archs.R500
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "Xserve3,1": {
        "Marketing Name": "Xserve (Early 2009)",
        "Board ID": "Mac-F223BEC8",
        "FirmwareFeatures": "0xE001F537",
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.nehalem.value,
        "Max OS Supported": os_data.os_data.el_capitan,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Ethernet Chipset": "Intel 82574L",
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.NVIDIA.Archs.Tesla
        ],
        "Stock Storage": [
            "SATA 3.5",
        ],
    },
    # Mac Studio M1 Max
    "Mac13,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j375c",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Aquantia",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    # Mac Studio M1 Ultra
    "Mac13,2": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j375d",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Aquantia",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "ADP2,1": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.pentium_4.value,
        "Max OS Supported": os_data.os_data.leopard,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Socketed GPUs": "PCIe",
        "Stock GPUs": [
            device_probe.Intel.Archs.GMA_950
        ],
        "Stock Storage": [
            "SATA 3.5",
            "PATA",
        ],
    },
    "ADP3,2": {
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j273a",
        "CPU Generation": cpu_data.CPUGen.apple_dtk.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": device_probe.Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe,
        "Bluetooth Model": bluetooth_data.bluetooth_data.PCIe,
        "Ethernet Chipset": "Broadcom",
        "Stock GPUs": [],
        "Stock Storage": [
            "NVMe",
        ],
    },
    "AAPLJ53,1": {
        # AppleInternal MacBookPro11,4
        "Board ID": "Mac-C08A65A66A9A3BA2",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": cpu_data.CPUGen.haswell.value,
        "Max OS Supported": os_data.os_data.mavericks,
        "Wireless Model": device_probe.Broadcom.Chipsets.AirportBrcmNIC,
        "Bluetooth Model": bluetooth_data.bluetooth_data.BRCM20702_v2,
        "Stock GPUs": [
            device_probe.Intel.Archs.Haswell,
        ],
        "Stock Storage": [
            "NVMe",
        ],

    },
    "Intel Virtual Machine": {
        "Board ID": "VMM-x86_64",
        "FirmwareFeatures": None,
        "SecureBootModel": "x86legacy",
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "VirtualMac1,1": {
        # Apple Silicon Virtual Machine
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "vma1",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "VirtualMac2,1": {
        # Apple Silicon Virtual Machine
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "vma2macos",
        "CPU Generation": cpu_data.CPUGen.apple_silicon.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "VMware7,1": {
        # VMware Virtual Machine
        "Board ID": "440BX Desktop Reference Platform",
        "FirmwareFeatures": None,
        "SecureBootModel": "x86legacy",
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "Parallels17,1": {
        # Parallels Virtual Machine
        "Board ID": "Parallels Virtual Platform",
        "FirmwareFeatures": None,
        "SecureBootModel": "x86legacy",
        "CPU Generation": cpu_data.CPUGen.penryn.value,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "iBridge2,11": {
        # Unknown ID, Intel based, present in Monterey
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j230",
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "iBridge2,13": {
        # Unknown ID, Intel based, present in Monterey
        "Board ID": None,
        "FirmwareFeatures": None,
        "SecureBootModel": "j214",
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_GPU_Test_Board": {
        # AppleInternal GPU Test Board
        # System is used for testing Intel iGPUs
        # Model has been configured with the following:
        # - Broadwell iGPU (HD Graphics 5300)
        # - Skylake iGPU (HD Graphics 5xx)
        # - Kaby Lake iGPU (HD Graphics 6xx)
        # - Ice Lake iGPU (G4/G7)
        "Board ID": "Mac-50619A408DB004DA",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_1": {
        # Laptop model
        # No mentions in SLE outside X86PlatformPlugin
        "Board ID": "Mac-112B0A653D3AAB9C",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_2": {
        # Laptop model
        # Only mentioned in ApplePlatformEnabler and X86PlatformPlugin
        "Board ID": "Mac-4BFBC784B845591E",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_3": {
        # Laptop model, 15"/17" with dGPU and GMUX
        # Only mentioned in AppleGraphicsPowerManagement, AppleMuxControl2, AGDCBacklightControl, ApplePlatformEnabler and X86PlatformPlugin
        "Board ID": "Mac-564FBA6031E5946A",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
     "APPL_UNKNOWN_MODEL_4": {
        # Laptop model, iGPU only
        # Only mentioned in AppleGraphicsPowerManagement, ApplePlatformEnabler and X86PlatformPlugin
        "Board ID": "Mac-6FEBD60817C77D8A",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_5": {
        # Laptop model, iGPU only, Iris Plus Graphics G7
        # Only mentioned in AppleGraphicsPowerManagement, ApplePlatformEnabler and X86PlatformPlugin
        "Board ID": "Mac-747B1AEFF11738BE",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_6": {
        # Laptop model, iGPU only
        # Only mentioned in AppleGraphicsPowerManagement, ApplePlatformEnabler and X86PlatformPlugin
        "Board ID": "Mac-87DCB00F4AD77EEA",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_7": {
        # Laptop model
        # Only mentioned in X86PlatformPlugin, AppleGVA
        "Board ID": "Mac-90BE64C3CB5A9AEB",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_7": {
        # Laptop model, iGPU only
        # Only mentioned in AppleGraphicsPowerManagement and X86PlatformPlugin
        "Board ID": "Mac-9394BDF4BF862EE7",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.max_os,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_8": {
        # Unknown, only mentioned in supported models for IAs
        "Board ID": "Mac-C6F71043CEAA02A6",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_9": {
        # Unknown, only mentioned in supported models for IAs
        "Board ID": "Mac-90BE64C3CB5A9AEB",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_10": {
        # Unknown, only mentioned in supported models for IAs
        "Board ID": "Mac-36B6B6DA9CFCD881",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
    "APPL_UNKNOWN_MODEL_11": {
        # Unknown, only mentioned in supported models for IAs
        "Board ID": "Mac-5A49A77366F81C72",
        "FirmwareFeatures": None,
        "SecureBootModel": None,
        "CPU Generation": None,
        "Max OS Supported": os_data.os_data.big_sur,
        "Wireless Model": None,
        "Bluetooth Model": bluetooth_data.bluetooth_data.NonApplicable,
        "Stock GPUs": [],
        "Stock Storage": [],
    },
}


#The above was smbios_data.py
# below is usb_data.py:
"""
usb_data.py: USB Device IDs for different vendors and devices
"""


class AppleIDs:
    # All top case devices use Vendor ID 05ac
    Modern_AppleUSBTCKeyboard = [
        0x223,
        0x224,
        0x225,
        0x230,
        0x231,
        0x232,
        0x236,
        0x237,
        0x238,
        0x23f,
        0x240,
        0x241,
        0x242,
        0x243,
        0x244,
        0x245,
        0x246,
        0x247,
        0x249,
        0x24a,
        0x24b,
        0x259,
        0x25a,
        0x25b,
        0x262,
        0x263,
        0x264,
        0x24c,
        0x24d,
        0x24e,
        0x252,
        0x253,
        0x254
    ]

    Legacy_AppleUSBTCKeyboard = [
        0x20e,
        0x20f,
        0x210,
        0x214,
        0x215,
        0x216,
        0x20d,
        0x218,
        0x219,
        0x21a,
        0x21b,
        0x21c,
        0x229,
        0x22a,
        0x22b
    ]

    AppleUSBTrackpad = [
        0x20e,
        0x20f,
        0x210,
        0x30a,
        0x30b,
        0x214,
        0x215,
        0x216,
        0x217,
        0x218,
        0x219,
        0x21a,
        0x21b,
        0x21c,
        0x229,
        0x22a,
        0x22b
    ]

    AppleUSBMultiTouch = [
        0x223,
        0x224,
        0x225,
        0x230,
        0x231,
        0x232,
        0x236,
        0x237,
        0x238,
        0x23f,
        0x240,
        0x241,
        0x242,
        0x243,
        0x244,
        0x245,
        0x246,
        0x247,
        0x249,
        0x24a,
        0x24b,
        0x259,
        0x25a,
        0x25b,
        0x262,
        0x263,
        0x264,
        0x24c,
        0x24d,
        0x24e,
        0x252,
        0x253,
        0x254
    ]

#video_bios_data.py:

"""
vbios_bios_data.py: VBIOS data for iMac MXM
"""

"""
iMac MXM adopted legacy video BIOS for device property injection
create by Internetzel and Ausdauersportler

technical details on
https://github.com/Ausdauersportler/IMAC-EFI-BOOT-SCREEN
recipe to build a iMac compatible NAVI vBIOS
https://github.com/Ausdauersportler/IMAC-EFI-BOOT-SCREEN/wiki/ObjectInfoNavi
"""

RX5500XT_64K = "55AA70E93703000000000000000000000000000000000000E8020000000049424D70D08E000000000000000000000004203736313239353532300000000000000000000000000000C00200000000000031302F31322F32302030353A3330000032000000E9250400E92F040000008C010A000000000000000B000E81871F50000000000001000100013088791E45A879140210BDC16F1CCFF9FF1F000000000000C4AFF83F000000000000000000407338AB467344730C0005003103D031375500F8801042F0DF03002C232020024802488CE600001EA8000F8008F03EA768747871782100210001002CC04C60192000300003800C0C00003610075280180C0E0A00000004F002000000080000000000084018107001000020000000040000001C040000C800000030000000000000084000000000000000000000001C32001C5E049000000000000000000000000000000000E42709401018006400000000C098070000407A01A000280000008010900118000008008081470100F0A11F11300000000020000000000000003131332D454D32344738472D533030004E4156493134005043495F45585052455353004744445236000D0A4E41564931342047616D696E6720585458204131204B394131325143412E534C42203230323020323333332F31343937342020202020202020202020202020202020202020202020202020200D0A000D0A200D0A0028432920313938382D323031382C20416476616E636564204D6963726F20446576696365732C20496E632E0041544F4D42494F53424B2D414D44205645523031372E3030322E3030302E3030302E303030303030004B394131325143412E534C420032313834313436200035333536363420200020202020202020200054554C5F4E41564931345F454D3234475F53414D5F4744365F38475F393557323032303130313254554C5C636F6E6669672E68000000902800020241544F4D00C0370461020D03B5016A040000000087170124E8021C92C292000074C80000504349520210407300001800000000037000021100000000414D442041544F4D42494F53009C4BB41D00000000000000000000000000000000000000000000000001000000000000000000000000000000000000001E0666506651665266536655665666570E1FA314008C0E0800B220E88F2C0BC07514A20200665F665E665D665B665A66596658071FCBE8A92DE87B2B32D28D3EC002895516E83C11E8FF10E85612E8AD02E835280BC0740CE83900E88353E8FB10E8D853E8A900B480E8752B8AC766C1E0108AE3B02066A3D08EE8AC02E80E11E8A22D665F665E665D665B665A66596658071FCB2E8B1E0800833E4904007504891E47041E2E8E1E3F049CFA66C706080165F000F0C70640006A04891E4200C706B4016A04891EB601C7067C00B25C891E7E00C7060C01C560891E0E01C706A804E456891EAA042E8E1E47048BC3A3E656A3F656A308579D1FC3504D49446A041647000000A000B000B800C000000000BB0000E8611066C1E810A3EE02BB0B00E854108D3EC00266894518C300E8D02C80FCA07505E83D00EB1180FC4F7505E8BD41EB07E81247EB02B401E8D72CCFE8AE2CE82000EB02B401E8C92CCBE8A02C80FC4F7505E89741EB07E8EC46EB02B401E8B12CCB1E0666506651665266536655665666570E1F3C0475292EA11A0066C1E0102EA118008D36B2018A3C80EF30B3028BEC895E0C89460466C1E810894600E928013C057518E8262AE8F9292EA108008BEC895610894600895E04E90C013C067532E8880F66D1E08BEC894614BB0200E8920F884618E87C0F6689460CBB0900E8820F33C0668946002E8B16EE02895610E9D6003C0B75240ADB7511B98000BB02008BEC895E0C894E14E9BD008AC7E8D000E834010F84A900E9AE003C17751DE831127406E88B0DE80C17E8EE09E8FA0E33C98BC88BEC894E14E98D003C1875450AFF7510E8B8118BEC89460CE83B0A894E10EB75E8FC117568BB001CE82C2B660BC0745D23C97459E8D011BE001CE8200F744EBE001CB040E86F0FE881118BEC89460CEB443C82751A80FB0575150AFF750AE8C5108BEC894614EB2DE892107418EB263C8E751280FF01740880FF02750880C102E8EB10EB108BECC6461902EB0F8BECC6461901EB0732E48BEC886619665F665E665D665B665A66596658071FC3518AC8B80100D3E059C3E84A2BC30C01C35051B0B6E643B033E642B005E642E4618AE00C03E6618AC4B9C800E81627E6615958C3001E560E1F803E0200807605C6060200808A0E0200C1E109FCC60621000033F632E4AC02E0E2FBF6D4FEC4882621005E1FC300570BC0750FE82A0C7425E82400F6C30474F3EB118BC8E8152523C17412E81100F6C304740A5F8D5C28E84C060BF6C35FC350E8DF0BE86724E875240AC974690AED74108ACDB502E81726B1028D9C4801E89429E87602F6C3047408E8F20CE8D82274458D5C28E869005683C608E8A4225E80FD02751151E804185980FB00754D51B508E8E805598ADD33C9E8F5160AC0753BE837028AEB8D5C2880CD02E83B00740380CD04E8C6058D9CA600E894290AC0741A5683C608E85A225E8ADDB98000E8C016E8D804740533C9E8A105E8FC0158C351B94900E8B42559C351E81A007514E8B9013C01750DB92000E82700750580C901EB0233C959C353E84629663D00FFFFFF750E83C304E83829663DFFFFFF0075005BC3505232D2E8272902D002D466C1E81002D002D483C304E2EC0AD25A58C3E8DF0A8D9C4C01E83901E88D01B513F6C308750CE8070C8AEA80FD137502B50366508D9CB8026633C08AC5E843286658A9C80E7455E86201F6C308740FE80F058D5C28E804017504E87200C3B502E82301E84601F6C30474218D5C28E84901E894037405B503E80B01E86804E8210180FD007548B502E80D01C38D9C6801B80055E85111B502E8FD00C3A90200742DB504E8E000E80301F6C3087403E8B0048D9C680156E83A268BF7E868045EE8D725E8D3008D5C28E8F725E81804C3B501E8B200B502E8BF00E8D000F6C30475108D9C6801B80055E8FC10B502E81700C3E8C600B5028D5C28E86E007502B501E80400E8E003C38D9CB402B102E8B727B502E88300C38D9C4C01E83800E88C00F6C30474238D5C28E88F00E8C5258D9C6801060E07B90700E86C2407E86300E8EE0A8D5C28E8B6258D5C28E85425B80200E8BEFEC3B96100E81224C35381C30501E8BF2724063C025BC3E810003D0104750A5383C318E8AA275BA801C35383C312E89F275BC38D9CB40232C9E83827C38D9CB402E88C27C38D9CB402B101E82627C38D9CB402B101E83427C366508D9C4801E86E278AD86658C3555751B90800BD0000BB08002BD9D1E38D584EE85327E8E301E2EE8D5C4BE84827B903008BD0BF520A8555067417668B058D9AF401E891268B45048D9AF801E89F2683C50883C708E2DF8D7C5EB9040033ED8BDFE812270BC07409E85D01E8970083C51C83C712E2E95532EDE86FFF8D5C28E84EFF3D0104751083C314E8E9262470C0E8048AE8E854FF5D8D9CA600E8D7260AC074468D9CA800E8CC263C02753B66C1E8103C0472338D9CA80032E403D88BFBB904008BDFE8AE260BC07415E8F900A98000750DE82E0083C51C555883F870730883C712490BC975DA595F5DC3200358023C000100000400033C0000088002E0013C002000518D1DE86B268D9A6801E8DC258D5D02E85E268D9A6A01E889008D5D05E851268D9A6E01E87C008D5D08E844268BC88ADC66C1C8108AD080E20F8AF0C0EE048AECC0ED068AFCC0EF0480E70380E40FC0E4040AD480E23F80E4C0C0EC020AF48BC38D9A7401E881258D9A72018BC1E878258D9A760133C08AC6E86D258D9A780133C08AC2E862258D5D0CE8E4258D9A7A01E80F008D5D0FE8D7258D9A7E01E8482559C38BC88AD466C1C8108AF080E60F8AE8C0ED048BC1E82F2583C3028BC2E82725C38D5D11E8A8258AE0BA0600C0E807740380CA808AC4C0E80324033C02750380CA403C0375128AC4D0E8A801740380E2FDA802740380E2FB8BC28D9A8001E8E624C33C01743D8BD00FB6C6243F043C8D9AF801E8D1240FB6C283C01FC1E0038D9AF401E8C1240FB6DEC1EB06C1E3022EF7A7B20B2EF7B7B00B8D9AF601E8A72483C508C310000A000400030005000400100009008D9CA600E814250AC0741F8D9CA80051B103E81800590BDB7410E8FE2432C0663D00030C0075030BDBC333DBC3665052E8E8243C02753980FC03723466C1E81032E43C04762A03C38BD083C3043BDA731FE8C7248AE080E4E0C0EC05241F38CC740832E4FEC003D8EBE30BDB5A6658C333DB5A6658C3518D9CA600E89D240AC0741B8D9CA800B112E818007410E88B2466C1E81080E4077504B001EB0232C00AC059C3665052E872243C70752B66C1E81032E483C30503C38BD03BDA731AE85A2438C8740D66C1E81032E483C00303D8EBE80BDB5A6658C333DB5A6658C35766518D9C68018BFB8BDFE83D000BC9740B668BD1E8970F83C71CEBEC66595FC3505351B90700538BDAE8102483F8005B740966C1E3108BDAE86020595B58C35153B90700E86D205B59C366505383C306E8E9235B8BC866C1E1105383C302E8DB238BC85B6658C38D9C480132C9E87023C357B92000E848205FC3E88301668BCA6652E8C406E8AA1C665A7410E83A06B300E89619663BCA7303668BD18D9CD003E899230BC075448D9C540266B8483F0000E8E822B5016681FA78690000722583C30466B878690000E8D122B5026681FAF0D20000720E83C30466B8F0D20000E8BA22B503B103E8CF01EB4566B9080000006633D2538D9C54028BD35BE83D230BC074226625FFFF000066D1E0538BDAE88A225B66C1CA10FEC266C1CA1083C20483C302E2D766C1CA108AEAB103E88801E83806A801743F8D9CAE03E8FE223C007434E8CF058AEBE85C0132EDE86301E8A2058D9CBB02E8E32233C98AC8E82801663BC2740E51E84301FEC5E8440159E2ECEB03B300C38D9CBB02E8BF22FEC88AE8E82E018D9C4003B90000E85222E8C202E8D200E80F016652E8AD05E8931B665A7504B300EB58E8F60080FD017707E8FA000AED7447E81E03E8281180FB00751DE8A705A8017407B10DE83F19EB30B501E89E05E8250FB500E89605EB21E8BF0080FD017607D0EDE8BB00EBBAE87600E8B300E8B600FECDE8B700EBAAB308C38D9C2901E835226633D28AD066B88C0A000066F7E2E83105E8171B753D66508D9C2801E816223C146658722E66508D9CD003E807220BC06658741FB908008D9CD0038BC1D1E003D8E8F1210BC07502E2ED6625FFFF000066D1E0660BC07503B8483F668BD0C38D9C2A01E8CF21240F8AE80AED7502B501C3B5008D9C3101E8BB21A8017402B501C35351E81F0032E48AC5C1E002598D9C540203D8E89E215BC3B102E81D00C3B102E80D00C3B101E81100C3B101E80100C3538D9CB802E820215BC3538D9CB802E82E215BC333C9E87F1E753C66BA37F1FFFF6633C0E8E30433C0E84703741CA9C80E74F6E83CF7F6C3047505F6C31874E9E8300050E82CF858EBDFE81C007508E831008BC1E81CF8C38D5D2866C1E3108D5C28B94900E87B1DC36650E8B5048BC86658C3665266BAFFFFFFFF33D0E88A04665AC3505352E8E0FF750933C0E8E3028BC8EB1083F902740BE82F0880FB01750383E1FD5A5B58C3566633C066BA00F0FFFFE8520766C1E610E8C4020BC07403E81C00E832075EC36652668BD0E8D2158D9C1C03E8AD208AC2E80820665AC35051E871025032C0E80004E8CC01E898008D9C4003E88D2038E8740A8AC5E8E41FB002E8E50358E8CA00E8A800E88C008D9C4C01E86E208BC88BD38D9C0003E863203BC17405B002E8C003E83BFC8D9C0003E84B158D9CD802E8A91FE88AFF66C1CE108BFE66C1CE10E89500E8D100E824038AE98D9CDC0232C9E8CC1FE80D036625FF0F0000595866BAFFFFFFFF33D0E8950633D2C35366508D9CD402E805208AC4E8601F66585BC35366508D9CD402E8F21F8AE0E84D1F66585BC3E87302E82E028ADDE893168AE98D9C3C0332C9E8771F0BDBC383EC088BECE85502E81002E819168D9C4C03E8BB1F8A4600E8151F83C408C38D9CD402E8AA1F32C0E8051FC3E80A008D9CD00232C9E83C1FC3B5008D1DE8901F668BD08D9C0203E8861F0BC0741C518BC88D9C0603E8781F66C1E0108BC159663BC27504B500EB02B502C3E82B028D9C4003B103E8FD1EE8D5F78D9C4003B102E8F11EE8950180FD007514E8A6FDE88E02E888FD668BD0E87702E88E02EB21E84A02E86C02E8730180FD02B504750B81FA74407605B50866D1EAE86E02E85F02E82B00C366525232ED83C102B80600F7E16633C98BC85A51668BC28ACF66F7E166C1E0035966F7F1668BC8665AC3B500E8EA01E8CC177503E811FD8D9C480332C9E8701EC353E85F0166C1E210E84D018D9CB802E8B91E8AE88D9CB402E8B01E8AC8E8BA148AEB5BC3575353E8D6FFE82B015BE81F15746680FD00752953E8DBFC668BD0E808F78ACD51E8E7FC8AFD59E871FF5BE8791E6625FFFF0000663BC8733932DBEB3880FD027516E86F01E8621774288D1FE8581E3D7440761E32DBEB1D80FD03751553E8D300B303E82F145BE83D1E3BC2760432DBEB0380CB015B5FC3538BF0E8141923F074098BC6E8B3178BF30BDB5BC351E815FDE80F0059C35150E8F7188BC858E8020059C35753E828190BC074098B1D83C7023BC375F78B1D83FBFF740B83C70285D974F28BC3EB0233C00BC05B5FC333C0E8C3FF7413E8A0FF8BDEB9FB00E8111A83C608E85C18EBE8BBF016B85AA5E82E1DC35366508D9C4003E8AB1D8AE866585BC38D9C6903E89E1DC38D9C6403E8961D0BC0C35366508D9CD402E8891D8AC866585BC35366508D9CD502E8791D8AC866585BC3538D5C14E86C1D8BD05BC35366508D5C16E85F1D8BD066585BC35366508D9C5003E84F1D668BD066585BC35366508D9C5403E83E1D668BD066585BC35366508D5C10E82E1D8BC866585BC36650538D9C4103E81E1D5B8AD86658C3538D5C08E8111D5BC353508D9C4C03E8061D8AC8585BC353508D9C4D03E8F81C8AC8585BC35366508D5C0CE8EA1C8BD066585BC35366508D9C0003E8DA1C6633D28BD066585BC38D5C04E8CB1CC3518D5C0432C9E8651C59C38D9C5003E8B81C668BC2E8121CC3538D9C4003B101E84B1C5BC38D9C5403668BC2E8FB1BC353518AE8E8C2FF24FD0AE8E8C2FF595BC366508D9CD802E8801C668BD06658C353665051668BC8BB0000E8E11523C20BC1E8E3155966585BC3BB0000E8CF156625CA0E0000C3E85918E8E817E8C6177506E84317E8CA17C3B001C355B301E82D1A5DC3665366BB04000000E8050033C0665BC35566C1E310BB0000E8101A5DC3E81819BB0A00E88E15C3BB0A00E87E15668BC8E80519BB0A00662BC1E87815C3E829000BC97422E814FBE824076651668BC8BB0700E85615662500FE0000660BC1E8531566590C01C332C0C3E86B020BC97506E8C3FAE8710251E8BCFA66C1E61033C0E89AFD7409E8090375F633C8EBF25823C866C1EE10C3A8107563E8E30666C1E61033C0E880FD7435E85DFD50518BC8E8F90185C15958740D50E8AAFE24033C035875E0EB0C50E89DFEA8015874D5E86AFB50E8CD0758B500E892FEEBC6E8CB01E825FDE83401B100E8410766C1EE10E88706A8207542A8407503E80F0EE86E060AC0750732C9B501E8B20EE89D01E8F7FCE830FEE816147514E862020ADB740DE818FBE87C07B500E842FEEB08E85907B501E838FEE8E600C3E8E615C3E81EFDE89F0633C9E89F016633D26633C0E86CFEE85200B1FFE8840033C0E8C8FC740AE8A5FC50E8C50758EBF132C9E8C401E8B0150BC0C3E8E6FCE867066633C066BA00F0FFFFE8330151B101E88C015933C0E893FC740AE870FC50E85B0758EBF1E8A70DE87F16C3B80200E85CFC742EB107E8CA11B80200E86CF0F6C3047512E84618833D00750AE8591583E0FDE85C15C366B802000000E8E4FDE84EF2C3E8DD13742338E176048ACCEB0638C173028AC8BB0200E8B5138AE1E8B913B104E87D110C01C30C01C351E8B313740C8ACCBB0200E897138AC48AE159C3E8F105C3E8FC05C3E826177518E88100E8DBFB80F901750E51E85306B501E832FD59E8DFFFC3E8D7FF51E8B006B500E821FD59C3B80200E8B4FB7403E82411C3E8B0043BC17C3A8BC1E8F004E8BA0E8BC851E82005E8E40459E8AD0E3BC872028BC18D5C04E82D1932C9B50FE8F80CE8EC15FEC138C172F28D5C04E89F190BC0C333C0C3BB001833C08AC2C1E00203D8C353BB0300E8F9126625FF0F00005BC35366506651668BC8BB0300E8E3126623C2660BC1E8E312665966585BC36650BB0500E8CC1225FF0F8BC86658C3E8381423C86650BB0500E8B7122500F00BC1E8B8126658C3665053BB0600E8A312A8107509BBF016E825193D5AA55B6658C3665053BB0600E8891280F101C0E10424EF0AC1E885125B6658C3536650BBF816E8FB188AC1E8561866585BC353BBF816E8EB1883E0015BC3536650BB0700E85112F6C4016658B0067402B0085BC353BB0700E83D1280E4FE80FD06740380CC01E838125BC36650BB0600E825122440C0E8068AD86658C3C3506651E871FA83EC048BEC6633C06689460033D28DBC68018D1DE889180BC074228BDFB000E8120174148BDFE885F4668B4600663BC872068BD766894E0083C71CEBD50BD2740A8D9C4C01E83CF4E988006633C0668946008DBCF40133D28D1DE843180BC074586650E8A7F03C01665874053D400673436652668BD08D5D04E82418E85D008BCA665A742F568D9C4C018BF1E814F45EB000E89F00741D8D1DE804188BD98B470666C1E0108B4702663B460072068BD16689460083C708EB9F0BD27416568D9C4C018BF2E8DCF35E538D9C620133C0E846175B83C4040BD2665958C3575351E805133B5502751866C1CA108BDA66C1CA103B5D0675090AC0740E3A451B740983C71CE2DE33D2EB028BD70BD2595B5FC3516652E8D1123A651A75090AC0740E3A451B740983C71CE2ED33FFEB000BFF665A59C3C366516652535366C1CE108BDE66C1CE10E859175B668BD0E860F33BCA720A663BCA7205E89FF8750232C05B665A6659C35657E8A7FF8BF7E835F35F5EC36650536651525756518BDEB90800E86813598D5C088BC166C1E0108AC2E86F16F6C20375248BC1247FBFF71A803DFF0F840F013A05750D668B450166B900050200E9960083C705EBE3F6C20174258BC1E870010F84EB0033C98ACC8AD00AC075128D5C086625FFFF000066C1E008E81E16EBB28AE18ACA80E10CC0E90280E2F0C0EA048AEA80FC70722A80FC75732580EC708AC432E450E830028BD85838D8720533C0E99C00E82802E883160BC00F849000EB1B32C0E8E6FE0F8485008D5C168B05E8E2158B450666C1E0108B450250E8480B66C1E1108BC8588D1CE8B01566508D5C04668BC1E8A515665866C1E8106681E1FFFF000066F7E166508D5C06E82D168BC8665866D3E066C1E810408D5C14E89315BF571B83F9017411BF5F1B81F901017408BF671B83F90275158D5C0C668B05E859158D5C10668B4504E84F150BDB5E5F5A66595B6658C3004001900101400190010280029001038002900104400190010540019001068002900107D0025E010D400190010E800290010F80025E011080025E01118002E001128002E00113800290012320049001322004B002332004C002628002E001FF050A050505000000050B060505000000081008080800000056E8CF1280E4013B04740983C604E2F733C0EB058B44020BC05EC3575350E8B21283E90AE8E00083F8057603B80500D1E003C8FBA583C602E2FAB8FFFFAB585B5FC36653516652E84100E8770066C1E810660FB7D866B80000000366D3E86633D266F7F3E8F109665A59665BC3536650BB0700E86A0E0AC066585BC3536650BB0700E85B0EA80166585BC35366508D5C06E8D8148AC866585BC351B90800E82A1159C3538D5C08E8C21424035BC38D5C09E8B814C35153B1018AE88D5C08E84F145B59C3538D1CE8A2145BC3538D5C04E899145BC3538D5C16E890145BC353665233C0E8C2FC665A751BE834007416E815004083F805730DE8D11348E80F00668BC2E8C7135BC3BB001EE85F14C3BB081EC1E00303D8C3BB001EB93200E89610C351E8E2FF0BC074128BC8BB081EE83B14663BC2740783C308E2F30BDB59C3C300C300BB20DFE8E333E88DF6B501E8E507C3BB00DFE8D433E87EF6B500E8D607C380F900750AE84A108AC8B502E81D090BF6742EE862F6B50151E8C00759E8C3075633F6B500E82D075EB501E8CEF6E8FB08E8C409E841F68D9C0003E8AC07E8F50766C1CE10B501E80B07E800FFA840750732C0B501E87E0866C1CE10C3E818F6B501E84B07B500E87907E8DC07B10FE8690AE82600C3E85200E80CF6B500E82F07B500E85D07E881F6E8C60F38C1740A80F90B7405B503E89208C3B110E83B0AE8B3F580FD007406B101E8A40AC3E8A60580FD017507B502E8D505EB03E8F301B10DE8160AB103E85400C3E8D5F50BD27405B100E8420AB102E84200E85BF6A8017412E870F580FD00750AB10CE8EB09B002E89104B100E8570AB10DE81F00C3B107E84C0AE89BF50BD2750CE809F6E8EB0B7509E8F20AC3B107E8FC09C3E8F7F5E8D90B752451E8270A5980F90C751A33D25683C608E8020C5E0AC0750CB90A00E8620F4283FA1E75E8C380FB010F84C500E8A50566C1E1108D9C3501E8AB12A801740551E82B0459E868F5B004E89C0566BA50014050E87605E8B80A757E66BA5001504F8D9C2D01E87F1224063C027502B602B005E87405E854058D5C2803D8E8910A75570AFF7509B00AE85E0532DBEB4A5133C98ACFE8350503C8E83A0559B007E8470566BA5001103033DBE8640A740F518AEB8D9C4401B102E8D01159EB61E80B0566C1C9102BC166C1C1103D80000F8276FFB008E81205EB43518AEB8D9C4401B102E8A6115966BA5001103033DBE8200AEB2C8D5C2803D9538AE9B132515FE8AEF48AE9B1A0BA0080E8DA0980FF015B740AB1A2E8CF0980FF017503B000C3B001C351B10CE8D2FE59B001E8BB045683C608E8E20A5E0AC07504B310EB3FB002E8A604E838007411B003E89C04B001E810037529E82700752466BA0C0090438D9C3001E8AB0966BA200090418D9C3401E89E09E8BD03B009E86E0433DBC3E82FF466BA000090478D9C2801E88309C3B10CE866FEB100E89408B101E88F088D9CAC0366B800000000E89C10B001E8B202740AB504E8CB03B308E93F01B108E8F607E8D202B109E8EE07E8C5018D9CB8036633C0E87110E86001B99001E8980DB001E86302B502E88D03E87401E89F03E8E001B503E87F0333C9E80001F6C5017534B502E87003E82001F6C5047408B501E86F03E9CC008AFD80E703E8E80080E30338FB750DE84C017508B502E85303E9B000E86701FEC1E885F338D975BB8D9CAC03E8A2103C037405E8ED00EB9B8D9CB0036633C0E8EF0F8D9C2A01E88810A840740CB113E84F07B003E8DA01EB0AB10AE84307B002E8CE01B504E8F802E8DF00E80A03E84B01B505E8EA0233C9E86B0080FD077505E88600752E51B504E8D50259F6C5017507B503E8D602EB34E878008AD5E8E600E8700038EA750CE8B4007507B502E8BB02EB19FEC1E8F1F238D975BC8D9CAC03E80E103C047505E85900EB9CB000E86001B10BE8CB068D9CAD03E8F40FB3000AC07402B308C38D9CC003E80F008AE8C3538D9CC403E804005B8AD8C351E8D10FC0E102D3E8240F59C38D9CC203E8C10FA801C38D9CB803E8730FC38D9CB803E8530FC333C933D2E8E9FF38D576028AD5FEC1E874F238D972EE33C98AEA8D9C5C03E8310FB10BE8CE06C3E84DF28D9CB803E87D0F66BA03018083E89E07C351538D9CB003E8260FFEC5E8090F80FD067207B502E8F60133C95B59C36633C08D9CB003E8AC0EC332EDE865FF80E30CC0EB02B7032AFBC0E3038AEB80FB18720380CD20E84BFF80E30338FB72028ADF80FB03750380CD040AEBE860FFC3E8DBF18D9CC00366BA02029045E82F07C3E8CAF166BA000190428D9CB403E81E07E8BAF166BA030190458D9CB803E80E07E8EEF1E8D407753BE8A2F166BA0A0190408D9CBF03E8F6068D9C2801E8C50E3C147220E887F166BA1000904F8D9CD003E8DB06E877F166BA150190408D9CCC03E8CB06C3E866F166BA02018050E8BE06C3E848F18BC26633D2B98C0AF7F1C3E84BF166BA00068050E8A306C3E83EF166BA11018050B004E89406C3E82FF166BA000690408D9CC803E883068D9CC803E8520EC3E8BBFF3C06740E3C0A740A3C1474063C1E740233C0E811F18AE380CC8050E8F9F05866BA00018061E8500633C9E884F00BC07402B5108D9CBC03E8B80D8AC5E8D8F066BA07018050E83006E810F1E8F60675498D9C4803E8F70D0AC0740EE8B9F066BA0A018050B001E80F068D9C2801E8DE0D3C1472258D9CD003E8D30D0BC0741AE83CEC32C98D9CCC03E8670D8AC5E887F066BA15018050E8DF05C38D9CB403B90E00E8F409E8A3FEE88FFEE838FF3C01751CE8D2FD741733C9E8A8FD80FD07750DFEC1E861F038D975EFB501EB02B500E80100C38D9CAC03B102E8160DC3518D9CAC0332C9E80B0D59C3518D9CAC03B101E8FF0C59C38D9C3201E8520D24077515B964008D9CAC03E8440D3C027403B99001E8CA09C332E4B10433D2F6E18BC8E8C709C3518D5C14E8240D66C1E010E8A40159C3538D9C4401E8130D5BC35366508D9C4401E8070D8BC1E8620C66585BC353518D9C44018AE8B103E8950C595BC333C9E82D0938C17305B500E88C00B500E88000FEC1E81A0938C172E6B1148AE9E8120938C17405B503E8E301FEC1E8FB08041438C176E7C383EC0C8BEC0BF6741EE802F866C1C810668946008D5C04E89C0C668946048D5C08E8920C88460A894E088CD066C1E0108BC4BB2B00E8D80783C40CC383EC048BECB002884601884E008CD066C1E0108BC4BB2500E8B90783C404C3BB2300E80800C3BB1700E80100C383EC048BEC894E008CD066C1E0108BC4E8940783C404C3BB2200E8E3FFC3BB2700E8DCFFC3BB2C00E8D5FFC3E81E0C66A90000FFFF744083EC188BEC5551B9040083C302E8060C6689460083C50483C304E2F183C304E8F40B66C1C81066894600595D884E148CD066C1E0108BC4BB3100E8330783C418C3E83FEE8D9CD002E8CB0B8AE8BB2100E876FFC38D9C3C03E8BB0B8AF8E801EE8ADD538D9C4203E8AC0B8AE85BE813EEE8B0EEE896047502B30183EC048BEC884E00887E01885E02886E038CD066C1E0108BC4BB2A00E8D70683C404C383EC108BEC663DF0FFFF03760666B8F0FFFF03668BC86633C066894604668946006689460866B8000000D0660BC16689460C8CD066C1E0108BC4BB3500E8930683C410C383EC088BEC894E0066895602895E068CD066C1E0108BC4BB2D00E8720683C408C33DC07F7604B8C07FC383C03F24C0C351E8010B6633D2B90A00F7F18BC8E8F40A03C16625FFFF0000593D10277303B81027C332D2C380FD027525E84EEE66BB00080000E89A00E842EE66BB03080000E88E006633D266BB01080000E88200C380FD0375106633C08AC16633D266BBFF000000EB365133D2E8E5EC8AD566C1E210E81EED8AF28AD1668BC2660D00000080E859ED80FB047606660D00000008E88FEDE8DDEC6633DB8AD95983EC108BEC6689460466895E08668BC26633D266BB6400000066F7E366894600BB0C008CD066C1E0108BC4E896058BECB30183C410C383EC108BEC6689560066895E04BB2E008CD066C1E0108BC4E87305B30183C410C3C353516650B9687480FB03740BB9A08C80FB007503B978696633D28BD16658595BC36652B30066F7C20000FFFF751A80FD13741580FD147410B30180FD0E7409B30380F9037402B302665AC3B51180FA23740780FA227402B500C3B50280FA23740780FA227402B301C332C980FD007508C746000B01B101C35033C0E87301041489460058B101C3C38BDAB72280FE217402B721C30C01C3E8780966C1E8100BC0741C5383C306E869095B3DE001720F5383C318E85C095BA88075030C01C332C0C3B50CC3B502C350E82601B1030AC07404B10802C858C380FA227505C746007869C3E8EF0080FDFF743583EC0C8BEC884E01886E0080F90F7505E82400EB0F80F910750A8D9C4803E807098846028CD066C1E0108BC4BB0400E8500483C40CC3C36653E8A4EB668BC26633D266BB8C0A000066F7F3665B8AE8886E098D9C4003E8CF0888460288660366C1E810884608E866EB66895604C383EC208BEC80F904750A884E0132C0884600EB56E830EBE87F00884600884E01E8A4EB88560A80F901741880F90B753A8D9C5C03E88308884602E824EB66895604EB27E83DEB886E08E815EB66895604E83FEB885E03E8ACEA886E0251E81C008ACDB001D2E0598846098CD066C1E0108BC4BB4C00E89C0383C420C38D9C3C03E8370832ED3C03740C3C0972093C0E77052C088AE8C3B5FFC35232C080EE2180FA1E7410B00280FA207409B00480FA217402B00602C65AC3C383EC088BEC897E00895E02895604894E068CD066C1E0108BC4BB3600E83C038BEC8B5E028A7E0183C408C35633F666F7C200008000750A5033C08AC68BF032F65853BB041FE81907668BC2BB001FE810075B66F7C200001000750233DB8BD366C1E210BA001F83EC088BEC66895600884E048AC5FEC8884607C6460500C64606008CD066C1E0108BC4BB4E00E8CC028BEC8A5E058A7E0683C4080ADB743251B9900180FB20740580FB807513B90A008BC60AC0740AB990013C017403B9E803E8CF03598BC6FEC48BF080FC0676980ADB5EC38D5C04E829078BD0B502E814007411B50180FA13750AE8610080FA137502B502C380FA14C3E8F9FF740380FA0EC380FA05C380FA02740380FA04C380FA01740380FA02C380FA027503B201C380FA047503B203C3C3B508E8D8FF7402B504C38D5C09E8CA068AC80AC9750332C0C3B502E8DA028AC52402D0E8C38D5C08E8AF068AD0B60183EC108BEC8956028CD066C1E0108BC4BB4F00E8EF018BEC8A560483C410C35383C34CE853065BC35383C34CE8A5055BC356E896018B4438837D20005EC352500FBCD832FF80FB017505BB0024EB0CFECBB80004F7E30500208BD8585AC357E85600740A8B5D02E808000BDB5FC333DB5FC352510BDB741B56E8360103DE5E33C98A4F01803FFF74083A07740603D9EBF033DB0BDB595AC35651E8150132C98D7C083B5D04740C83C710FEC13A4C0672F133FF0BFF595EC35651E8F50032C98D7C083B1D740C83C710FEC13A4C0672F233FF0BFF595EC35651E8D60032C98D7C083B450C740C83C710FEC13A4C0672F133FF0BFF595EC35750E8DBFF8AC38B5D02E86EFF585FC35332C9B301E8E8FF74038A4F020AC95BC35332EDB302E8D7FF74038A6F020AED5BC350578BDAE868FF750433DBEB0DB0148B5D08E834FF74F28B5F025F58C366505351578D1C6625FFFF0000E8B5048BD8E83B0023C37431E875FF0BFF742A6650668B45048D5C0CE899046633C08B058D5C04E88E046658E885FFE893FF8D5C086633C08BC1E87B045F595B6658C356E818008B44045EC356E80F008944045EC3C3BFE0028B3D8B7D0CC3BEE0028B348B7430C31E0E1FBFE0028B3D8B7D0E83C7041FC3BEE0028B348B7410C3BFE0028B3D8B7D2683C704C3BEE0028B348B741AC3BEE0028B348B743AC3BFE0028B3D8B7D0A83C704B90700C3E80100CB83EC068BEC8946006633C0C646040089460206528AD38BC5E8CD165A0783C406C3E880FF66F7451001000000C350E873FFB8010009451058C3E868FF884510C3665383EC488BEC66895E0066894E048CD066C1E0108BC4BB0000E8A3FF83C448665BE86A01E8A40183EC1C8BECC64601078CD066C1E0108BC4BB0D00E881FF83C41CE80E00BB0400E88FFD66C1E810E8A7FFC383EC1C8BECC64601088CD066C1E0108BC4BB0D00E856FF83C41CC3E8F3FE668B5D08668B4D0CC356E826FF668B44085EC383EC048BEC894E008CD066C1E0108BC4BB3800E826FF8BEC8A6E0283C404C3C3B006C3B001C3B005C3B008C35366506633C0E80D0383C304E2F866585BC332C0C3FCE89D0366C1CB10E8F60266C1CB106681C304000400E2E9C3FC66ADE8E20283C304E2F6C3FCE8780366AB83C304E2F6C36650B86400E810006658C36650B850C3D1E1E803006658C352F7E18BCAE8690166538BD966C1E3108BD866B804B10300B20066EFB2046633C066EF66B808B10300B20066EFB20466ED33C96603D8730A66ED66A90000008075F666ED663BC3730C66C1E8103BC172048BC8EBED665B5AC3BB42ECE8C7026633D266BB6400000066F7F3C3665053BB0700E857FC2500023500020BC05B6658C36651B301E8C400E802FE6633C98B4C0866C1E00A0BC97503B92000662BC1E8EBFD66894404894C086659C3561E0E1FE8DAFD668B440466C1E00A1F5EC3C3BEE0028B348B741E83C604B91C00C356E8A6FD8A6C335EC356E89DFD5381C30901E875028AE85B5381C30001E86A025B8AC5668944345EC356E87DFD668B44345381C30801B1018AE8E8F1015B5381C30001B1018AECE8E4015B5381C3020166C1E810E8AB015B5EC356E84CFD8BFE83C7045EC356E841FD8A442480FD007405886C330C028844245EC332C0C3665383EC048BEC8CD066C1E0108BC466895E00BB0600E84DFD8BEC668B460083C404665BC366508CC83D00C0750CBAC303EC8AF00AF67402EB0E532E8B1E1400B220E8D6008AF45B32D266ED6658C32E8B1E1400C30BC9751A4B7416433BDA77098BC88BC22BD2F7F391F7F38BDA8BD12BC9C33BCA721A75103BD8770C2BC38BD82BC92BD2B80100C32BC92BDB9387CAC355562BF68BEE03DB13C97211453BCA72F577043BD876EFF813F64D7820D1D9D1DB2BC31BD1F572F003F64D780CD1E9D1DB03C313D173F1EBDF03C313D18BD88BCA8BC633D25E5DC39350920BC07402F7E2910BC07404F7E303C858F7E303D1C3526650B4808AC766C1E0108AE38AC224FCBAF80C66EF66585AC352BAFC0C66ED5AC352BAFC0C66EF5AC3E831FF9CFAE8CEFFE8E5FF9DC3E824FF9CFAE8C1FFE8E0FF9DC35266536650E806006658665B5AC366C1E31066C1EB0EE8D7FEE89301C3665066C1E31066C1EB10E801FE6603D86681CB000000806658C3526653E80400665B5AC36650E8AAFEE8D4FFE863016658C35251665366508ACB80E3FC80E103C0E103E88DFEE8B7FFE82D0166D3C8585066D3C0E83B016658665B595AC3665051C0E103E8530066D3C88AC566D3C0E8A8FF596658C3665051C0E103E83B0066D3C8598AE86658C3E85F00C3E844FE66C1E31066C1EB0EE8DF00C3E835FE66C1E302E8D400C3526653E80400665B5AC3E820FEE84AFFE8C000C35166528AEB8ACB80E103C0E10380E3FCE8D9FF80F9007414668BD083C304E8CBFF83EB046692660FADD08ADD665A59C3526653E89CFF665B5AC3526653E8A1FF665B5AC36650555266508BEC8B560C895608E8C4FDB20066ED6689460A66585A5DC36650555266508BEC8B560C895608E8A6FD2EA12D03B218EFB20066ED6689460A66585A5DC3665055528BECE889FDB200668B460A66EF8B560889560C668B4604668946085A5D66586658C3665052E866FDB21866ED2EA32D035A6658C36681FBFF00000077048AD3EB09668BC3B20066EFB20466EDC36681FBFF00000077048AD3EB0A6693B20066EF6693B20466EFC3C3C3558BEC53518BF0268B5C14268B4C16E828008D66FC595B5DC353518BF0268B5C2433C9E81400595BC3558BEC53518BF0268B5C08268B4C0AEBD5525657C80600008BF0894EFE8CD08EC0268B7C268A450132E4B920002BC8B8FFFF8BD0E306D1EAD1D8E2FA8A4D0332ED8BFAE306D1E0D1D7E2FAF7D0F7D72621441C26217C1E8CD08EC0268B7C268A4D0132EDB820002BC18BC866C746FAFFFFFFFFE308D16EFCD15EFAE2F88A4D0232ED8BC38B56FEE306D1EAD1D8E2FA2346FA2356FC8A4D0332EDE306D1E0D1D2E2FA2609441C2609541EC95F5E5AC3558BEC53515257508BD8268B7F268A450132E4B920002BC8B8FFFF8BD0E306D1EAD1D8E2FA8A4D02884EF6C646F7008BFA8B4EF6E306D1E0D1D7E2FA2609471C26097F1E8D66F85F5AE9F1FE535152578BD88CD08EC0268B77268A4C0132EDB820002BC18BC8BEFFFF8BD6E306D1EAD1DEE2FA268B7F268A4D0232ED8BC6E306D1E0D1D2E2FAF7D0F7D22621471C2621571E5FE9CC0553568BD88CD28EC2268B7726803C007473803C0175588A440132E426837F1E00754C263B471C75468A046BF0038A840490260147268CD08EC0268B7726803C0974178A0432E46BF0038BC3FF940290268B77268A0432E4EBD18B44012629472626FF4726268B471C268B771EEB1A268B77268A0432E46BF0038A84049026014726E980FF33C033F68BD65E5BC3535152568BD88D7735268B54022689571426C7471600008BF0268B472033D226014714261154168CD18EC126F6472F060F850A0526807F34007522268B7716260B7714751026D1670826D1570A26D1670826D1570A8BC3E87911E9E104268A473432E4058000992689471C2689571E8BC3E8FFFEE9C70453568BD88D7735268A440232E4C1E002268B37268B3403F0268B4708268B5F0A26890426895C025E5BC35352568BD88CD08D77358EC0268A540280FA407321268B770232F6C1E202268B740403F2268B5708268B470A26891426894402E97F0080FA417512268B4708268B570A2689471026895712EB6880FA407512268B4708268B570A2689470C2689570EEB5180FA42750A268B470826894722EB4280FA43750A268A470826884733EB3380FA467512268B5708268B470A268957182689471AEB1C80FA47750A268B470826894724EB0D80FA487508268B4708268947205E5A5BC353568BD88D7735268A440232E42689471426C7471600005E5BC353568BD8268B7702268B74028A0432E42689471426C747160000268B5F0226FF47025E5BC353568BD8268B7702268B74028B342689771426C747160000268B5F0226834702025E5BC353568BD8268B7702268B74028B048B74022689471426897716268B5F0226834702045E5BC35352568BD8E870FF8BF3268B4718268B571AD1EAD1D8D1EAD1D826014714261154168BC3E82B10E94AFF538BD8268B5F0226FF47025BC3538BD8268B5F0226834702025BC353568BD8E86BFF8BF3268B572033C026015714261144168CD28EC2268B472E32C080E4063D0002750732E433D25E5BC3268B472E32C080E4063D000474EB26807F340075088BC3E82F0F5E5BC3268A473432E42689471C26C7471E00008BC3E8EAFC5E5BC3538BD8E8E2FE268B4714C1E002268B1F268B1F03D8268B07268B57025BC3E236D736ED363C37F3360B372537303736375351568BD8E8B0FE8CD28EC226837F1600752226837F1440731B268B7702268B5F14C1E302268B440403D8268B07268B5702E97B05268B7714268B471683C6C083D0FF757183FE08776C03F62EFFA47436268B4710268B5712E95405268B470C268B570EE94905268B4722EB4B268A4F3332EDBB010033D2E306D1E3D1D2E2FA8BC3E92B05268A4F3332EDB8010033D2E306D1E0D1D2E2FAF7D0F7D2E91105268B4718268B571AE90605268B4724EB08268B4720EB0233C033D2E9F30453568BD8E8F4FD8BF3268B4718268B571AD1EAD1D8D1EAD1D826014714261154168BC3E8160E5E5BC333C033D2C353568BD8E8EBFD268B7714260377228B048B54025E5BC3538BD826C6472B04E8ABFD268B4714268B57165BC3538BD826C6472B01E8BBFDEBE9538BD826C6472B00E8D2FDEBDC538BD883C335268A5F01C0EB0380E30732FF03DBFF97928F5BC35352568BD8268A472C32E48BF003F08BC3FF94AE8F268947082689570A268A472D32E48BF003F08BC3FF94C68F2689470426895706E917FD5351568BD8268A4F2B32ED8BF18A8CF68FE30A26D16F0626D15F04E2F6268A4F2B32ED8BF1C1E6028B8CD68F8BB4D88F26214F0426217706268A4F2A32ED8BF18A8CFE8FE30A26D1670426D15706E2F6268B4F08268B770A26894F1426897716E9CA0353515256578BD88CD08EC0268A472B32E48BF0C1E602268A472A8BF88A8DFE8F32ED8B84D68F8B94D88FE306D1E0D1D2E2FAF7D0F7D22621471426215716268A472A32E48BF08A8CFE8F32EDE30A26D16F0A26D15F08E2F6268A472B8BF0C1E6028B84D68F8B94D88F262147082621570A268A472A32E48BF08A8CFE8F32EDE30A26D1670826D1570AE2F6268B4714268B5716260947082609570A5F5E5A595BC35351568BD8268A4F2B32ED8BF18A8CF68FE30A26D16F0626D15F04E2F6268A4F2B32ED8BF1C1E6028B8CD68F8BB4D88F26214F0426217706268A4F2A32ED8BF18A8CFE8FE30A26D16F0A26D15F08E2F6268A4F2B32ED8BF1C1E6028B8CD68F8BB4D88F26214F082621770AE9BB025152578BD88CD08EC026807F2B00741A268A472C32E48BF003F08BC3FF94AE8F268947082689570AEB10268A472C32E48BF003F08BC3FF94BA8F268A472D32E48BF003F08BC3FF94C68F26894704268957068CD28EC226807F2B00744A268A472B32E48BF0C1E602268A472A8BF88A8DFE8F32ED8B84D68F8B94D88FE306D1E0D1D2E2FAF7D0F7D2262147082621570A8BC3E8F9FD268B4704268B5706260947082609570AEB10268B5704268B4706268957082689470A268A472C32E48BF003F08BC3FF94A28F5F5A59C353515256578BD8268A472A32E48BF08A8CFE8F32EDE30A26D1670426D15706E2F68CD08EC0268A472B32E48BF0C1E602268A472A8BF88A8DFE8F32ED8B84D68F8B94D88FE306D1E0D1D2E2FAF7D0F7D22609470426095706268B4704268B5706262147082621570AE956FE558BEC5152508BD8268A472C32E48BF003F08BC3FF94AE8F268947082689570A268A472B8846FA8BC3E8DAFC2689470426895706268A4F2D32ED8BF103F18BC3FF94C68F26894714268957168BC3E844FF8A46FA32E48BF08A8CF68FE30A26D16F1626D15F14E2F6268A572B32F68BF2C1E6028B84D68F8B94D88F2621471426215716268A472A32E48BF08A8CFE8F32EDE30A26D1671426D15716E2F6268B4714268B5716260947082609570A268A472C32E48BF003F08BC3FF94A28F8D66FC5A595DC3518BD8E856FC268A4F2B32ED8BF18A8CF68FE30A26D16F0626D15F04E2F68BC3E8AEFE268A4F2C32ED8BF103F18BC3FF94A28F59C38BD8E822FC8BC3E855FC268B4704268B7706260947082609770A268A472C32E48BF003F08BC3FF94A28FC353568BD8E8F5FB8BC3E828FC268B4704268B7706263147082631770A268A472C32E48BF003F08BC3FF94A28F5E5BC35351568BD8E8C5FB8BC3E8F8FB268B4F04E30A26D1670826D1570AE2F68BC3E846FC268A4F2C32ED8BF103F18BC3FF94A28F5E595BC35351568BD8E88FFB8BC3E8C2FB268B4F04E30A26D16F0A26D15F08E2F6EBC8528BD8E872FB8BC3E8A5FB8BF3268B4704268B5706260147082611540A8BC3E8F1FB268A472C32E48BF003F08BC3FF94A28F5AC3528BD8E83EFB8BC3E871FB8BF3268B4704268B5706262947082619540AEBCA51528BF0E81EFB8BC6E855FC268B4408268B540A268B5C04268B4C06E8DDF22689440C2689540E5A59C3528BD0E8F5FA8BC2E82CFC8BC2E85C085AC35152578BF0E8E1FA8BC6E818FC268B4408268B540A268B5C04268B4C06E81CF22689440C2689540E8CD78EC7268B4408268B540A268B5C04268B4C06E8FDF126895C1026894C12E910FD528BD0E899FA8BC2E8D0FB8BC2E8D3075AC351528BD8E886FA8BC3E8BDFB8CD18EC1268B4708268B570A263B5706750E263B4704750826C64730015A59C38BD0268B470A263B47067208750A263B5704730433C0EB03B80200268847305A59C35152578BD8268A472C32E48BF003F08BC3FF94AE8F268947082689570A8CD08EC0268A472B32E48BF0C1E6028BF88A8DF68F32ED8B84D68F8B94D88FE306D1E0D1D2E2FAF7D0F7D2262147082621570AE94DFC558BEC51525783EC068BD8268A472B32E48BF0C1E6028BF88A8DF68F32ED8B84D68F8946F48B84D88F8946F6E308D166F4D156F6E2F88B7EF48B46F68946F8268A472C32E48BF003F08BC3FF94AE8F268947082689570A8BC3E847F926894704268957068BC7F7D08B56F6F7D2262347082623570A268947142689571626217F088B46F62621470A8CD18D77358EC126803C197312268B4F04E30A26D1670826D1570AE2F6EB10268B4F04E30A26D16F0A26D15F08E2F626217F088B46F82621470A268B5714268B4716260957082609470A268A472C32E48BF003F08BC3FF94A28F8D66FA5FE9A3FC528BD8E8FDF88BC3E834FA268B4708268B570A268557067506268547047405B80300EB03B80100268847305AC3535152568BD8268A4F2D32ED8BF103F1FF94C68F2689470426895706268A472B32E48BF08A8CF68FE30A26D16F0626D15F04E2F6268A472B8BF0C1E6028B84D68F8B94D88F2621470426215706E9BDF9528BD8E8AAFF268B4704268B5706268947182689571A5AC351528BD8E891FF8CD08EC0268B7702268B7402813C5A5A745B268B7702268B7402803C6375E1268B770226FF44028BC3E821F8268947082689570A8BC3E8FAF726894714268957168CD18EC1268B5704268B4706263B470A75AD263B570875A7268B7702268B04260347148BDE268947025A59C3268B5F0226834702025A59C352578BD88CD08EC0268B7702268B74028A540184D2750826C747220000EB2F80FAFF7514268B7702268B3F268B34262B750226897722EB16268B07E8E3028BF08AC232E403C003F08B0426894722268B5F0226834702025F5AC38BD82680672FF9268B7702268B74028A440126884734268B5F022683470203C38BD8268B7702268B74028B740126897720EBE3538BD8268A472C32E424032680672FF9C1E0092609472EE94FF58BD8268B7702268B74028A440132E42689470426C7470600008BC3E84004268B5F022683470202C38BD8268B7702268B74028A440132E42689470426C7470600008BC3E80804EBD653568BD8268B7702268B74028A440132E42689470426C7470600008BC3E80604E986F453568BD8268B7702268B74028A440132E42689470426C7470600008BC3E8F003E963F453568BD8268B77028BDE268B5F028B5F0183C30326015C025E5BC351528BD8268B77022683440202268B07E8A0018BC8268B77288A440132E403C08BF103F0833C00744F268B77288A540132F68BC3E8B00126884731268B7702268B348B4404C1E80832E4247FC1E80232E4241F2680672F07C1E00B2609472E268B37268B472EC1E80BC1E00226010426C647320126894F285A59C3538BD826C64732825BC3578BD88CD68EC626807F2C05740A268A472C263A4730751E268B7702268B7402268B7F02268B3D8B740103F7268B5F02268977025FC3268B5F0226834702035FC35356578BD88CD68EC626807F3001740A268A4730263A472C7520268B7702268B7402268B7F02268B3D8B740103F7268B5F02268977025F5E5BC3268B5F022683470203EBF15356578BD88CD08EC026807F300174E5EBC3558BEC535152578BD8268B7702268B74028A0426C6473D008CD18EC126807F3D087320268B7702268A573D32F6268B7C0203FA8BF303F28A152688543526FE473DEBD5268B7F028AD032F68BF2C1E6028A94239026015502268B7F288A550180E2072688572D268B7F288A5501C0EA0380E2072688572B268B7F288A5501C0EA062688572A8A9422902688572C8D66F85F5A595B5DC353568BD8268B77028BC68B744803F08BD88B741E8BC603C383C0045E5BC353568BD8268B77028BC68B744803F08BD88B7420EBE08AC2C31607558BEC5351565783EC408BF88946B8E8D3FF8BD88946E0268B45028B5F2E03D8895EDE8346DE048BC7E89BFF8946E032F68D46B8E8C4FF8AD032F603D28B5EE003DA833F000F8465018846E98066E7F9C646EC00C746D8000066C746D000000000C746F60000C646EA01EB063C010F858C008A56E98AC232E403C08B5EE003D8833F007475268B45028B1F03D88B470432E48BC883C10932ED80E1FE83F9007407D1E933C050E2FD8BC48BD88946BA85C0744183C008268947048AC232E403C08B5EE003D8268B450203078B5EBA2689078B5EBA268B0783C006268947028B5EBA8B76F6268977068B5EBA895EF6C646EA00EB0AC646EA87EB04C646EA838A46EA32E483F8100F8F99008866EA8A46EA32E485C00F8F83008CD08B5EBA8EC0268B5F02895EE08B5EBA268B5F02803F5B754AC646EA108B5EBA268B5F06895EF68B5EBA268B1F8B470432E48BC883C10932ED80E1FE03E18B5EF6895EBA85DB74AC268B1F8B4704C1E80832E4247FC1E802C1E0028B5EB8262907EB918D46B8E8AFFD8AD08D46B8E82E008ADA32FFC1E3028D46B8FF972090E972FF837EF6000F85C9FE807EEA1074058A46EAEB0232C08D66F85F5EE90BFEC353518BD8268A4F0432EDE886E8595BC353518BD8268A4F0432EDE881E8595BC3538BD8268A470432E4E6805BC353518BD8268A4F0432EDE89ED7595BC3538BD866506652665166268B470866268B571066268B4F0466F7F1662689470C66268957106659665A66585BC3538BD866506652665166268B470866268B4F0466F7E1662689470C66268957106659665A66585BC353578BD8268B5F14E838EB8BD066C1E810925F5BC353578BD8268B4714268B57168BD887D366C1E3108BDAC1E302E836EBEBD85352578BD8268B4708268B570A9266C1E0108BC2268B5F14E85AEA5F5A5BC353528BD8268B471C268B571E9266C1E0108BC2268B5F268B5F01E839EA5A5BC35352568BF0268B5C268B5F01E8C2EA8BD066C1E810922689441C2689541E5E5A5BC3535152578BD8268B4708268B570A9266C1E0108BC28BC8268B4714268B57168BD887D366C1E3108BDAC1E3028BC1E816EA5F5A595BC38BD066C1E81092C31E0666506651665266536655665666570E1F0AC07506E80701E9A8003C017506E83701E99E003C027506E85F02E994003C03750BE891038BEC895E0CE985003C047502EB7D3C05750AE80E048BEC895610EB713C067510E88C038BEC895E0C894E14895610EB5D3C077502EB553C08750AE8D0038BEC887E0DEB493C097502EB413C0A7510E865048BEC894E14897E008C461CEB2F3C0B7502EB273C10750AE85A048BEC895E0CEB1B3C117502EB133C15750FE880048BEC895E0CEB07B84F01EB0232C08BEC894618665F665E665D665B665A66596658071FC3501E2E8E1E47048CD8A3E656A3F656A308572E8E1E3F04A3AA041F58CB0030312E303000564553410003000300000100000000000000000302110C0200009C01000034470000B93F008BDF83C704FC6633C0F366AB8BFBBE3A47B92200F3A4061F8C4F088C47108C4F188C4F1C8C4F2083C722897F0E0E1FE8F9D3B04F32E4C3565157B910006633C0F366AB5F598CDB061FC705BB00C6450207C745044000C745064000C6451B06C6451801C6451A01C6451E0166C7453E0084D7178EDBE8CDCC660BC00F84E100061F668945288CC866C1E010B8F34A6689450C81F9FF810F84C20080E503B201538EDBBE801CE8A5D15B061F0F84B10053E821D466894512C7451608108D5C0CE8BAE86689451F668945368D5C10E8ACE8668945236689453A8D5C08E89EE80AC075035BEB7BE8ECD366C1E8103D5802740D3D5E017408770AC6451708EB04C645170E2EA141048945088D5C04E86DE8668BC866C1E910D3E0894510894532B008D2E08845198D5C14E851E85B3D0003772F538BD8B8000333D2F7F35BFEC888451D8845358845348EDB5753BE801CE85DCC5B5F0BC97505061F8325FE32E4EB02B403B04F8EDB5EC30081FBFF8174680AFF75048BC3EB21F6C70875618BCBB201BE201CE8C7D07455E828D30AC0750E66C1E81080E7800AC7E8D502EB3AE8A4CE7406E815CDE864C6BE201CE8D4CB742DE8A500E82C0066BB201C001CE8EBD2BE001CE8EED266C1E8108BD832C0F6C7807402B040E804CCB04F32E4EB04B04FB403C3560633C08EC0BE201CE8E6D28BC866C1E8108BD0C1E90326890E4A04C1EA04FECA268816840426C60651040026C60650040026C60649046226C7064C0400A026C60685041026C7060C01C5608CC826A30E01075EC3010F000A000000000040050FFF000102030405060708090A0B0C0D0E0F01000F00FCBAC403B80001EFB90400B401BE9649AC86E0EF8AE0FEC4E2F6B80003EFB90900BACE0332E4BE9A498AC4EEAC42EE4AFEC4E2F5BADA03ECB91400BAC00332E4BEA3498AC4EEACEEFEC4E2F7C3BE001CE808D266C1E8108BD8E8D8D17505E8C4D17504B84F00C3B84F03C3E8C6D17453BE001C80FB00741880FB017505E804D2EB1D80FB0275108BC1E8B7D1D3E88BC8E8B4CC742EEB0880FB037524E85BD1E8A1D18BD8D3E35033C0BA00033BDA7705BAFFFFEB04F7F38BD0588BC8B84F00C332C0C3B04FB403C3000ADB75078AEFE882CDEB05E867CD8AF8B04F32E4C300E852D1742CBE001CE871D166C1E810F6C440751D0AFF7505E81E00EB0F80FF017514BB1300E8EBE5D1E88BD0B04F32E4C3B04FB403C332C0C35253665081E2FF02D1E28BC24066C1E0108BC2BB1300E81CE5BB1200E816E566585B5AC39C1E0666506651665266536655665666570E1FE834E6E88AFFE853E68BEC895610894618665F665E665D665B665A66596658071F9DCB0E07BFC88E2E8B0EC68EB84F00C3000ADB7506B704B310EB2680FB017514E859CC752153B1010AFF7402B100E86ECB5BEB0D80FB02750DE886CC8AF8C0E702B04F32E4C3B84F03C30080E3010ADB7505BB0201EB0EE822CC750E33C053E80FBB5B7405B04F32E4C3B04FB403C380FC1D7203CD42C31E0666506651665266536655665666570E1F500FB6C4D1E08BF0582EFF94E04B665F665E665D665B665A66596658071FC30E1F500FB6C4D1E08BF0582EFF94E04BC31A4C3085498566850D4D697C9B7C0E7D917D1F7F237F2C82FD828083E7838285E4858D88264FD48CCE4BCE4BCE4BCE4BCE4BCE4BA48DA771FB722E8E1E3F0480268704F3508AE080E47FE8C4013BD3750258C3BACC03ECB2B4B13026F6470901740CB2D4B120A8017549B509EB06A8017441B50B53E870410AFF5B750B80268804F0082E8804EB2B58800E87040880261004CF080E100489166304C70685040800C606840418C7060C01B2588C0E0E01CD42C380261004CF080E10045853500E1F33C98AC8E8FBCA7406E86CC9E8BBC2B208BE401CE8F4CCBE401CE823C8585B0F846EFF2E8E1E3F040E07E819290E1F5366BB401C001CE82FCFBE001CB020E858C85B2E8E1E3F040E07E8222EE82400E82E3DE8D101E88E01E8B43E0E1FBE001CB010E834C8E8FD2DE8F52DC38BECC6461B00C3E82F00E80A00E8BD00E85200E8620AC35383C30A8B166304B91900B81130EF32C0268A27EF43FEC0E2F75B80C20632C0EEC353BAC40383C305B90400B001268A273C01750380CC20EF43FEC0E2F05B268A4709BAC203EEB2C4B80003EFC38BF383C623BADA0326F64709017502B2BAF606890408741D83C610ECB90400B410B2C080FC1174078AC4EE268A04EE46FEC4E2EFC353EC8BDEB9140032E4B2C08AC4EEFEC4268A07EE43E2F48AC4EE32C0EE1E06E84F2D0BED74091F1EB91000F3A446A4071F5BC35383C337B9090032C0BACE03268A27EF43FEC0E2F75BC3BBE4500E078BD30AE47D01C3E80100C333F680FC037F3C4AF6068904107520A08804240F3C027E243C0874203C06741C3C077418B040F6E403D881C30004C3B040D0ECF6E403D881C38004C3B040F6E403D8C380FC077511F606890410750581C30001C381C30005C3BF664EBE874E33C9E84E00C304800005800006C0000D80020EC0020F800310C00311400512800513C005624001538A1E490480FB077F1032FFD1E32E8B87A34EA26504882666045BC32C3028302D3029302A302E301E3F29302E382575072E035D0133F6C383C7033BFE75EDC31E062E8E1E3F04F6068704807549833E4C04007442A04904B900202E8B3E450426F6473301750E26F6470901751B2E8B3E4304EB143C067E0B2E8B3E4104268A6737B5406633C0EB0666B8200720078EC76633FFF366AB802687047F071FC32E8E1E3F0480FB107503E97A0180FB207503E99B0180FB32751FBACC030AC07509EC0C02B2C2EEE9F300FEC80F85F300EC24FDB2C2EEE9E40080FB3575283C807508800E890440E9D300F6068904400F84D0000AC00F84CA00FEC87506E89807E9BA00E9BD0080FB307403E9960050E8303E8AEFBACC03EC8AC8580AC07530B708F6C10175120AED750BA0100424303C307510B702E98B00A0100424303C307502B702802689046F800E890480EB363C017541802689046FB709F6C1017515B70BA0100424303C30741BB7090AED7415B705EB11A0100424303C307508B70B0AED7402B7038A1E880480E3F00ADF881E8804EB293C02752B802689046F800E890410EBB480FB31751B0AC0740B3C01750C800E890408EB0580268904F78BECC6461A12C380FB3375163C00740B3C0175EC80268904FDEBE5800E890402EBDE80FB3475173C00750780268704FEEBCE3C017507800E870401EBC3C380FB367526BB20FF3C017409BB00DF3C007402EBADE80200EBA89CFABAC403B001EE42EC22C70AC3EE9DC3C3B303B700BACC03ECA8017502B701A088048AE0B104D2EC250F0F8BC88BEC895E0E894E16C6461A12C39CFAC706140094768C0E16009DC3281808000809030002632D2728902BA0BF1F00C70607000000009C8E8F141F96B9A3FF0001020304050607101112131415161708000F000000000000100E00FF501808001001030002635F4F50825581BF1F00C70607000000009C8E8F281F96B9A3FF0001020304050607101112131415161708000F000000000000100E00FF281808004009030002632D2728902B80BF1F00C10000000000009C8E8F140096B9A2FF00131517020406071011121314151617010003000000000000300F00FF501808004001010006635F4F50825480BF1F00C10000000000009C8E8F280096B9C2FF00171717171717171717171717171717010001000000000000000D00FF50180E001000030003A65F4F50825581BF1F004D0B0C0000000083855D280D63BAA3FF000808080808080810181818181818180E000F080000000000100A00FF501D1000A0010F000AE35F4F508254800B3E0040000000000000EA8CDF5000E704E3FF000102030405060708090A0B0C0D0E0F01000F00100000000040050FFF0005111C080B14280E182D322024383F0005080B0E1114181C2024282D32383F070C10151A181615131C252F38332E2A2527292A2C2319102325272A2C2B2A29292D32373B3937343233343535312C272F303233343433333235383A3D3C3A39383839393A373431030507090B0B0A09080D11151917151311111213140F0B071010121314131313121416181A191817161717171815141115151617171717171618191A1B1B1A19191919191A181716020304050706060505070A0C0E0D0C0B090A0A0B0B09060409090A0B0B0B0B0B0A0C0D0E0F0F0E0D0D0D0D0D0E0C0B0A0C0C0C0D0D0D0D0D0C0D0E0F0F0F0F0E0E0E0E0E0E0E0D0C00000000000000002818080020090F0006632D2728902B80BF1F00C00000000000009C8E8F140096B9E3FF0001020304050607101112131415161701000F00000000000000050FFF5018080040010F0006635F4F50825480BF1F00C00000000000009C8E8F280096B9E3FF0001020304050607101112131415161701000F00000000000000050FFF0005111C080B252802071B200F14282C0C11252A141E32360F13272C1B203439060B1F2413182C30090D2126151A2E3313172B301F24383D0E182D322024383F0005111C080B14180005111C080B14180E182D322024383F0E182D322024383F0005111C080B14180005111C080B14180E182D322024383F0E182D322024383F50180E0080010F0006A25F4F50825480BF1F004000000000000083855D280F63BAE3FF000800001818000000080000001800000B0005000000000000000505FF50180E0080010F0006A35F4F50825480BF1F004000000000000083855D280F63BAE3FF000102030405140738393A3B3C3D3E3F01000F00000000000000050FFF28180E000809030002A32D2728902BA0BF1F004D0B0C0000000083855D141F63BAA3FF000102030405140738393A3B3C3D3E3F08000F000000000000100E00FF50180E001001030002A35F4F50825581BF1F004D0B0C0000000083855D281F63BAA3FF000102030405140738393A3B3C3D3E3F08000F000000000000100E00FF281810000808030002672D2728902BA0BF1F004F0D0E000000009C8E8F141F96B9A3FF000102030405140738393A3B3C3D3E3F0C000F080000000000100E00FF501810001000030002675F4F50825581BF1F004F0D0E000000009C8E8F281F96B9A3FF000102030405140738393A3B3C3D3E3F0C000F080000000000100E00FF501810001000030002665F4F50825581BF1F004F0D0E000000009C8E8F280F96B9A3FF000808080808080810181818181818180E000F080000000000100A00FF501D1000A0010F0006E35F4F508254800B3E0040000000000000EA8CDF2800E704C3FF003F3F3F3F3F3F3F3F3F3F3F3F3F3F3F01000F000000000000000501FF501D1000A0010F0006E35F4F508254800B3E0040000000000000EA8CDF2800E704E3FF000102030405140738393A3B3C3D3E3F01000F00000000000000050FFF2818080020010F000E635F4F50825480BF1F00410000000000009C8E8F284096B9A3FF000102030405060708090A0B0C0D0E0F41000F00000000000040050FFFE45000C0000000000000000000000000045700C00000000000000000000000001A00A28E00C000000000000000000000000000000000000000001EE810002E8E1E3F04E8FE36E8D536E8761A1FC32E8E1E3F04C706870460F9C6068A040BA089040C112417A28904B401E8731EA0890480261004CF800E100420C7066304D4030E1FE871B8F7C102007503E8F9B7B80300E857F4C31E2E8E1E3F040E07EB001FC3F6068904087401C353BAC803ECB0FFB2C6EEB2C8803E6304B4752FBE6658B9400033DB9CFA8AC3EE8BFBC1EF0383E70303FE2E8A0542EE2E8A4504EE2E8A4508EEFEC34AE2DF9DE98500268A472BF6068904067431B9F800BF64523C087411B94000BFE4533C3874073C3F7403BF245433DB9CFA8AC3EE2E8A0142EEEEEEFEC34AE2F19DEB493C0874253C38742E3C3F742AB9080033DB51E8CBD3B90800F7C31000740383C718E8670059E2EAEB20E8B4D3B9100033DBE85700EB13B9400033DB51E828008AC3E8B72FFEC359E2F25BC3002A002A002A002A153F153F153F153F002A003F002A003F002A003F8BFBC1EF0283E70F2E8AB556588BFBD1EF83E70F2E8AAD56588BFB83E70F2E8A8D5658C39C8AC3FAEE2E8A0542EE472E8A05EE472E8A05EE47FEC34AE2E79DC300000000000000007E81A581BD99817E7CFED6BAC6FE7C00C6EEFEFE7C38100010387CFE7C381000103810EEEE103800387CFEFE6C10380000183C7E3C180000FFE7C381C3E7FFFF00183C66663C1800FFE7C39999C3E7FF1E0E1E3678CCCC787EC3C37E187E18181E1A1E181870F0603E3E3636F6661E0CDB3C66E7663CDB0080C0F0F8F0C0800002061E3E1E060200183C7E187E3C180066666666660066007FDB7B3B1B1B1B003C66386C6C38CC7800000000FEFEFE00183C7E187E3C187E183C7E1818181800181818187E3C180000181CFE1C180000003070FE703000000000C0C0C0FE0000002466FF662400000010387C7CFE000000FE7C7C381000000000000000000000183C3C18180018006C6C6C00000000006C6CFE6CFE6C6C00187EC07C06FC180000C60C183060C600386C3876CCCC760018183000000000001830606060301800603018181830600000EE7CFE7CEE00000018187E181800000000000018183000000000FE000000000000000000383800060C183060C080007CC6CEDEF6E67C001878181818187E007CC60C183066FE007CC6063C06C67C000C1C3C6CFE0C0C00FEC0FC0606C67C007CC6C0FCC6C67C00FEC6060C181818007CC6C67CC6C67C007CC6C67E06C67C00001C1C00001C1C0000181800001818300C18306030180C000000FE0000FE00006030180C183060007CC6060C180018007CC6C6DEDCC07E00386CC6C6FEC6C600FC66667C6666FC003C66C0C0C0663C00F86C6666666CF800FEC2C0F8C0C2FE00FE62607C6060F0007CC6C0C0DEC67C00C6C6C6FEC6C6C6003C18181818183C003C181818D8D87000C6CCD8F0D8CCC600F06060606062FE00C6EEFED6D6C6C600C6E6E6F6DECEC6007CC6C6C6C6C67C00FC66667C6060F0007CC6C6C6C6D67C06FCC6C6FCD8CCC6007CC6C07C06C67C007E5A181818183C00C6C6C6C6C6C67C00C6C6C6C66C381000C6C6D6D6FEEEC600C66C3838386CC6006666663C18183C00FE860C183062FE007C60606060607C00C06030180C0602007C0C0C0C0C0C7C0010386CC60000000000000000000000FF30301800000000000000780C7CCC7E00E0607C666666FC0000007CC6C0C67C001C0C7CCCCCCC7E0000007CC6FEC07C001C3630FC30307800000076CEC67E067CE0607C666666E6001800381818183C000C001C0C0C0CCC78E060666C786CE6001818181818181C0000006CFED6D6C6000000DC666666660000007CC6C6C67C000000DC66667C60F0000076CCCC7C0C1E0000DC666060F00000007CC07C067C003030FC3030361C000000CCCCCCCC76000000C6C66C3810000000C6C6D6FE6C000000C66C386CC6000000C6C6CE76067C0000FC983064FC000E18187018180E0018181800181818007018180E1818700076DC000000000000001038386C6CFE003C66C0663C18CC7800C600C6C6CE76000E007CC6FEC07C007CC6780C7CCC7E00C600780C7CCC7E00E000780C7CCC7E003838780C7CCC7E0000007CC07C186C387CC67CC6FEC07C00C6007CC6FEC07C00E0007CC6FEC07C006600381818183C007CC6381818183C000000381818183C00C6386CC6FEC6C6003838007CC6FEC6000E00FEC0F8C0FE0000006C9A7ED86E007ED8D8FED8D8DE007CC6007CC6C67C0000C6007CC6C67C0000E0007CC6C67C007CC600C6C6CE760000E000C6C6CE760018003C1818183C00C6386CC6C66C3800C600C6C6C6C67C0000187ED8D87E1800386C60F066F66C00C3663C7E183C18003E63380E633E001C003E613C867C001C0E00780C7CCC7E001C00381818183C00000E007CC6C67C00000E00CCCCDC760000FC00BC6666E600FE00C6E6F6CEC6003E003E6067633D003E0076CEC67E067C1800183060663C000000007C606000000000007C0C0C0000C0CCD8307C360C3EC0CCD8306C3C7E0C180018183C3C180000366CD86C36000000D86C366CD80000228822882288228855AA55AA55AA55AADD77DD77DD77DD77181818181818181818181818F81818181818F818F818181836363636F636363600000000FE3636360000F818F81818183636F606F636363636363636363636360000FE06F63636363636F606FE00000036363636FE0000001818F818F800000000000000F8181818181818181F00000018181818FF00000000000000FF181818181818181F18181800000000FF00000018181818FF18181818181F181F1818183636363637363636363637303F00000000003F30373636363636F700FF0000000000FF00F736363636363730373636360000FF00FF0000003636F700F73636361818FF00FF00000036363636FF0000000000FF00FF18181800000000FF363636363636363F00000018181F181F00000000001F181F181818000000003F36363636363636FF3636361818FF18FF18181818181818F8000000000000001F181818FFFFFFFFFFFFFFFF00000000FFFFFFFFF0F0F0F0F0F0F0F00F0F0F0F0F0F0F0FFFFFFFFF00000000000066DCD8DC66000078CCF8CCC6CC0000FE62606060E00000FE6C6C6C6C6C00FEC6603060C6FE00007ED8CCCCD8700000666666667CC0000076DC1818183800FE386CC66C38FE00386CC6FEC66C3800386CC6C66C6CEE003E603866C6CC780000007EDBDB7E0000067CDEF6E67CC0003860C0F8C06038007CC6C6C6C6C6C60000FE00FE00FE000018187E1818007E0030180C1830007E000C1830180C007E000C1E1818181818181818181818783000000018007E0018000076DC0076DC00007CC6C67C00000000000000181800000000000000180000001F181818F8381800D86C6C6C0000000070D830F80000000000007C7C7C7C000000000000000000001D000000002466FF66240000000000000010000000000000000000000000000000000000007E81A58181BD9981817E0000000000007CFEFED6FEFEBAC6FE7C000000000000006CEEFEFEFEFE7C38100000000000000010387CFE7C3810000000000000000000103838106CEE6C103800000000000010387C7CFEFEFE6C1038000000000000000000183C3C3C18000000000000FFFFFFFFFFE7C3C3C3E7FFFFFFFFFFFF00000000183C6666663C180000000000FFFFFFFFE7C3999999C3E7FFFFFFFFFF00001E0E1E3678CCCCCCCC780000000000003C6666663C187E1818180000000000001E1A1E1818181878F8700000000000003E363E363676F6660E1E0C000000000018DB7E3C66663C7EDB180000000000000080E0F0FCFEFCF0E08000000000000000020E3E7EFE7E3E0E02000000000000183C7E181818187E3C18000000000000666666666666660066660000000000007FDBDBDBDB7B1B1B1B1B0000000000007CC6C6607CF6DE7C0CC6C67C00000000000000000000FEFEFEFE000000000000183C7E1818187E3C187E000000000000183C7E18181818181818000000000000181818181818187E3C180000000000000000000C0EFF0E0C00000000000000000000003070FE7030000000000000000000000000C0C0C0FE00000000000000000000002466FF6624000000000000000000103838387C7CFEFE0000000000000000FEFE7C7C7C3838100000000000000000000000000000000000000000000000183C3C3C3C1818001818000000000036363636140000000000000000000000006C6C6CFE6C6CFE6C6C6C00000000000018187CC6C0783C06C67C18180000000000000062660C183066C6000000000000386C3830767ECCCCCC7600000000000C0C0C18000000000000000000000000000C18303030303030180C00000000000030180C0C0C0C0C0C18300000000000000000006C38FE386C000000000000000000000018187E18180000000000000000000000000000000C0C0C1800000000000000000000FE0000000000000000000000000000000000001818000000000000000002060C183060C0800000000000007CC6C6CEDEF6E6C6C67C0000000000001878181818181818187E0000000000007CC6C6060C183060C6FE0000000000007CC606063C060606C67C0000000000000C1C3C6CCCCCFE0C0C1E000000000000FEC0C0C0FC060606C67C0000000000007CC6C0C0FCC6C6C6C67C000000000000FEC6060C1830303030300000000000007CC6C6C67CC6C6C6C67C0000000000007CC6C6C6C67E0606C67C0000000000000000000C0C00000C0C000000000000000000000C0C00000C0C0C180000000000000C183060C06030180C00000000000000000000FE00FE000000000000000000006030180C060C1830600000000000007CC6C60C1818180018180000000000007CC6C6C6DEDEDEDCC07E000000000000386CC6C6C6FEC6C6C6C6000000000000FC6666667C66666666FC0000000000003C66C2C0C0C0C0C2663C000000000000F86C6666666666666CF8000000000000FE6660647C64606066FE000000000000FE6660647C64606060F00000000000007CC6C6C0C0C0CEC6C67C000000000000C6C6C6C6FEC6C6C6C6C60000000000003C18181818181818183C0000000000003C181818181818D8D870000000000000C6C6CCD8F0F0D8CCC6C6000000000000F06060606060606266FE000000000000C6C6EEEEFED6D6D6C6C6000000000000C6C6E6E6F6DECECEC6C60000000000007CC6C6C6C6C6C6C6C67C000000000000FC666666667C606060F00000000000007CC6C6C6C6C6C6D6D67C060000000000FC6666667C786C6666E60000000000007CC6C0C0701C0606C67C0000000000007E5A181818181818183C000000000000C6C6C6C6C6C6C6C6C67C000000000000C6C6C6C6C6C6C66C3810000000000000C6C6C6D6D6D6FEEEC6C6000000000000C6C6C66C38386CC6C6C600000000000066666666663C1818183C000000000000FEC6860C183060C2C6FE0000000000007C60606060606060607C000000000000000080C06030180C06020000000000007C0C0C0C0C0C0C0C0C7C000000000010386CC6000000000000000000000000000000000000000000000000FF0000001818180C00000000000000000000000000000000780C7CCCCCDC76000000000000E060607C6666666666FC0000000000000000007CC6C0C0C0C67C0000000000001C0C0C7CCCCCCCCCCC7E0000000000000000007CC6C6FEC0C67C0000000000001C363030FC303030307800000000000000000076CEC6C6CE7606C67C00000000E060607C6666666666E60000000000001818003818181818183C0000000000000C0C001C0C0C0C0C0CCCCC7800000000E0606066666C786C66E60000000000001818181818181818181C0000000000000000006CFED6D6C6C6C6000000000000000000DC6666666666660000000000000000007CC6C6C6C6C67C000000000000000000DC666666667C6060F00000000000000076CCCCCCCC7C0C0C1E00000000000000DC6660606060F00000000000000000007CC6C07C06C67C000000000000303030FC30303030361C000000000000000000CCCCCCCCCCCC76000000000000000000C6C6C6C66C3810000000000000000000C6C6D6D6D6FE6C000000000000000000C6C66C386CC6C6000000000000000000C6C6C6C6CE7606C67C00000000000000FE860C183062FE0000000000000E18181870181818180E00000000000018181818001818181818000000000000701818180E181818187000000000000076DC00000000000000000000000000000000001038386C6CFE000000000000003C66C0C0C0C6663C180CCC3800000000C60000C6C6C6C6C6CE7600000000000C1830007CC6C6FEC0C67C00000000003078CC00780C7CCCCCDC76000000000000CC0000780C7CCCCCDC76000000000060301800780C7CCCCCDC760000000000386C3800780C7CCCCCDC7600000000000000007CC6C0C0C67C180C6C380000003078CC007CC6C6FEC0C67C000000000000CC00007CC6C6FEC0C67C000000000030180C007CC6C6FEC0C67C0000000000006600003818181818183C0000000000183C66003818181818183C0000000000000000003818181818183C0000000000C600386CC6C6C6FEC6C6C600000000386C3800386CC6C6FEC6C6C6000000000C183000FE60607C606060FE000000000000000066DB1B7FD8D8DF760000000000007ED8D8D8D8FED8D8D8DE00000000003078CC007CC6C6C6C6C67C000000000000C600007CC6C6C6C6C67C000000000030180C007CC6C6C6C6C67C00000000003078CC00C6C6C6C6C6CE76000000000060301800C6C6C6C6C6CE76000000000018003C181818181818183C0000000000C6007CC6C6C6C6C6C6C67C0000000000C600C6C6C6C6C6C6C6C67C00000000000018187CC6C0C0C67C18180000000000386C6060F060606066F66C0000000000666666663C187E183C18180000000000003E6363301C0663633E001C00000000000000003E63380E633E001C000000000C183000780C7CCCCCDC7600000000000C1830003818181818183C00000000000C1830007CC6C6C6C6C67C000000000018306000CCCCCCCCCCDC7600000000000076DC00BC6666666666E6000000000076DC00C6C6E6F6DECEC6C60000000000211E001E3360606763331D0000000000423C003B6666663E06663C00000000000030300030303060C6C67C00000000000000000000007E6060600000000000000000000000007E060606000000000000606062666C183060DC360C183E000000606062666C18366EDE367E06060000000018180018183C3C3C3C18000000000000000000366CD86C360000000000000000000000D86C366CD800000000000011441144114411441144114411441144AA55AA55AA55AA55AA55AA55AA55AA55DD77DD77DD77DD77DD77DD77DD77DD771818181818181818181818181818181818181818181818F818181818181818181818181818F818F8181818181818181836363636363636F6363636363636363600000000000000FE36363636363636360000000000F818F818181818181818183636363636F606F63636363636363636363636363636363636363636363636360000000000FE06F636363636363636363636363636F606FE000000000000000036363636363636FE00000000000000001818181818F818F8000000000000000000000000000000F81818181818181818181818181818181F000000000000000018181818181818FF000000000000000000000000000000FF1818181818181818181818181818181F181818181818181800000000000000FF000000000000000018181818181818FF181818181818181818181818181F181F181818181818181836363636363636373636363636363636363636363637303F000000000000000000000000003F303736363636363636363636363636F700FF00000000000000000000000000FF00F73636363636363636363636363637303736363636363636360000000000FF00FF00000000000000003636363636F700F736363636363636361818181818FF00FF000000000000000036363636363636FF00000000000000000000000000FF00FF181818181818181800000000000000FF3636363636363636363636363636363F000000000000000018181818181F181F000000000000000000000000001F181F1818181818181818000000000000003F363636363636363636363636363636FF36363636363636361818181818FF18FF181818181818181818181818181818F80000000000000000000000000000001F1818181818181818FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFFF0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F00F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0FFFFFFFFFFFFFFFFF00000000000000000000000076DCD8D8D8D8DC7600000000000078CCCCD8FCC6C6C6C6CC000000000000FE666260606060606060000000000000000000FE6C6C6C6C6C6C000000000000FEC6623018183062C6FE0000000000000000007ED8CCCCCCD870000000000000000066666666667C60C080000000000000000076DC1818181818000000000000FE38386CC6C66C3838FE00000000000000386CC6C6FEC6C66C38000000000000386CC6C6C6C66C6C6CEE0000000000003E60603C66C6C6C6CC780000000000000000007EDBDBDB7E000000000000000002067CCEDEF6F67C60C0000000000000001C3060607C6060301C0000000000007CC6C6C6C6C6C6C6C6C60000000000000000FE0000FE0000FE00000000000000000018187E181800007E00000000000030180C060C183000007E0000000000000C18306030180C00007E00000000000000000C1E1A18181818181818181818181818181818181818587830000000000000001818007E001818000000000000000000000076DC0076DC0000000000000078CCCC7800000000000000000000000000000000001818000000000000000000000000000000180000000000000000001F1818181818D8D87838180000000000D86C6C6C6C6C0000000000000000000070D8183060F8000000000000000000000000007E7E7E7E7E7E0000000000000000000000000000000000000000001D00000000002466FF66240000000000002F0000000103060C183060C080000000003000007EC3C3C3DBDBC3C3C37E000000004D0000C3C3E7FFFFDBDBC3C3C300000000540000FF99181818181818183C00000000560000C3C3C3C3C3C3C3663C1800000000570000C3C3C3C3DBDBDBDBFF6600000000580000C3C3C3663C3C66C3C3C300000000590000C3C3C3C3663C1818183C000000005C00000080C06030180C060301000000006D000000000066FFDBDBDBC3C300000000760000000000C3C3C3C3663C1800000000770000000000C3C3DBDBDBFF66000000000000C560C30BDB7403E946015732C0B94000F3AA5FBB928E26891D268C4D022E8E1E3F0457BE4904B91E0083C704FC8A042688054647E2F75FA08404FEC026884522A185042689452357E8D91B5F26885D2526887D268A1E4904E8FC05740580FB137F1D32FFD1E32E8A876A8E32E40AC0740140268945272E8A876B8E26884529A185048A168404FEC2F6E2B2003DC8007E15B2013D5E017E0EB2023D90017E07B2033DE0017E002688552A8A2687048AC42401C0E00480E402D0E40AE080F410A08904240A0AE0E89408B2C0B030EE42EC2408C0E0020AC40C012688452DB00326884531E877081E0632D2C41EA8048CC18CCE3BCE743426C577048CD90BF1740380CA1026C5770C8CD90BF1740380CA0826C577088CD90BF1740380CA0426C577108CD90BF1740380CA01071F26885532B003BAC403E8E4048AE0C0EC028AD48AF2D0EE81E204042503030BC22689452B8BECC6461A1BC30AC0740FFEC87436FEC874568BECC6461A00C3B82000F6C101740383C060F6C102740383C03AF6C104740305030383C03FC1E8068BEC89460EC6461A1CC38BFB83C720F6C1017403E88500F6C1027403E8EF00F6C1047403E8F8018BECC6461A1CC3F6C1017406E81615E82501F6C1027403E88501F6C1047403E81202EBDC8AC4EE42ECAAFEC44AE2F5C3E86B04BDC003B9150032E4EC87EA8AC4EE42ECAAFEC44A87EAE2F0EC87EAB020EEC3268A0588044746E2F7C3268A25EF47FEC0E2F7C3B2C08AC4EE268A0547FEC4EEE2F4C39CFA51578BC72BC32689078BF7E80A04EC2688440126895441B2CEEC26884402B2CCEC26884409B2CAEC26884404B2C4EC26880483C705B90400B401E870FF268A04EE8BFE83C70A268B544132E4B91900E85BFF268A4401EEE85FFFB2CE32E4B90900E849FF268A4402EE5F5983C7609DC39CFA8BC72BC32689470251572E8E1E3F04A010042430AABE4904B91E00F3A4BE8404B107F3A4BEA804B104F3A4BE1400B104F3A4BE7400B104F3A4BE7C00B104F3A4BE0C01B104F3A45F5983C73A9DC39CFA268B3F03FB8BF7518BFE83C705BAC403B80001EFB001B90400E807FF47B2C2268A4409EEB2C4B80003EF268A04EE268B5441B81100EFB11932C0E8E6FE268A4401EE80C206268A4404EEECB11532E4E8DBFEB020EEB10932C0B2CEE8C5FE268A4402EE599DC39CFA268B7F0203FB06512E8E1E3F04268A0580261004CF0806100447BE4904B91E00E88EFEBE8404B107E886FEBEA804B104E87EFEBE1400B104E876FEBE7400B104E86EFEBE7C00B104E866FEBE0C01B104E85EFE59079DC39CFA8BC72BC326894704E8A605B2C0B034EE42EC268805BAC803EC26884501504A4AEC2688450283C703B900034232C0EE4242ECAAE2FC584AEE9DC39CFA268B770403F3E86C05B2C0B034EE268A04EEBAC603268A4402EE56424283C60332C0EE42B90003268A04EE46E2F95EFECA268A4401EE9DC3BACC03EC24FE0AC4B2C2EEC3E8A812B2C086C4EEEB00EB0086C4EEEB00EB00B020EEC3508AE080E480802687047F08268704247F8AE03C077E1E26F647330175173C2374133C32740F3C33740BB40326F64709017502B40788264904BAB403800E87040226F64709017407B2D480268704FD89166304C7064E040000C606620400B90800BF5004FC061E0733C0F3AB07268A0732E4A34A04268A4701A28404268A4702A38504268B4703A34C04268B471486C4A3600458C35232E433D2B00DCD17F6C429750832E433D2B00ACD175AC3061E602E8E1E3F042E830E490400756E803E0005017467C6060005018A1E620432FFD1E38BFB8B8550048A3E62045032F68A0E840432ED41518B0E4A0432D2E8A6FFF6C429753D515289955004B408E8B0D40AC07502B02033D232E4CD17F6C429751F5AFEC259E2DEFEC659E2CAE877FF32C0A200055889855004E8AF03611F07CF5A5959B0FFEBEA522AF538C67D0232C02E8E0641045AC3A08504F6E38AF78BD88BCABAC403B8020FEFB402E86D008BD132ED8AE68AC6F3AA03FD8ACA4B75F732E4E85700C3538A1E62040BC075040ADB7403E835035B8BF82BD181C201018AC332E4C38AC632F62BEA0ADB742A2AC3F62685048BC852B401E82000B2C4B8020FEF5A1E061F8BC18BCAF3A403F503FD4875F51FE881FFC38AD8EBF8BACE03B005EE42EC24FC0AC4EE4AC39CFAEE42EB00EC4A9DC31E2E8E1E3F048B16630480C2061FC31E2E8E1E3F048B1663041FC350BACC03ECB2D4A8017502B2B458C3E8EEFF80C206C31E2E8E1E3F04803E4904037413803E490402740C803E4904017405803E4904001FC3502E8E064304A0100424303C3074052E8E064504580BC07403E8E10103064E0481C201012BD132ED8B2E4A048BF88BF08BC5F6E3D1E0D1E50ADB75028ADE38F37E028ADEC3FC8AD88BC1E8B3FF03F03A164A047406061FE81B00C3061FE84000C3FC8AD88AC18AE6E895FFF7DD2BF0061FE80100C3538ACE2ACB32ED32F62BEA2BEAE30E8AE18BCAF3A503F503FDFECC75F458B0208ACAF3AB03FDFECB75F6C3538AC62AC37406F6E28BC8F3A5588BC8F6E291B020F3ABC38BD8E82E002E8E1E45048AC322DFD3E3A8807403301CC3F6D78A3422F70ADE881CC38AFCE80C002E8E1E45048A04D2E822C7C3B028F6E2F6C201740305D81F8BF1C1EE0280FF057F0C03F0F6D180E103D0E1B703C3D1EE03F0F6D180E107B701C3FC8AD82E8E0645048BC1E8860075028ADE03F0E82400C3FC8AD82E8E0645048AC18AE6E86D0075028ADEF7DD81C6F00081C7F0002BF0E80100C38ACE2ACBE32C518ACA5657D1E9F3A513C9F3A48ACA2BF12BF981C6002081C70020D1E9F3A513C9F3A45F5E03F503FD59E2D48AC78AE78ACA57D1E9F3AB13C9F3AA8ACA2BF981C70020D1E9F3AB13C9F3AA5F03FDFECB75DEC3E8B00081C201012BD138F3760232DB51B102D2E6D2E35932EDBD5000803E4904067404D0E2D1E0061F8BF88BF0B050F6E30ADBC352538ADF32FFD1E38B875004E80E0050D1EBA14C04F7E35B03C35B5AC3528BD0A04A04F6E432F603C2D1E05AC38BE883E50F2E8AA6427A8BE8C1ED0483E50F2E8A86427AC300030C0F30333C3FC0C3CCCFF0F3FCFF268B0486E0BA0080F6C4C074020AD6D0EEC1E00275F288560045C38B1663048AC586E0EF8AE1FEC0EFC3528BD08AC4F6264A04C1E00232F603C25AC3538ADF32FFD1E38B875004D1EBE802005BC3528BD032F6528AC4F6268504F7264A045A03C20ADB740803064C04FECB75F85AC3528BD0A04A04F6E432F603C2D1E003064E04D1F88BC8B40EE891FF5AC38BC2F7264A048BF9C1EF0303F80AFF740A8AC732E4F7264C0403F880E107B480D2ECC3E8F0FCECC3E8F8FFB2C0B020EEC3E8EFFFB2C032C0EEC3C43EA80426C47D048CC50BEFC353B00EE895FC8AE0B00FE88EFC8BD8B80EAAEFB80F55EFB00EE87FFC3CAA740DB00FE876FC3C55740432C05BC3B00E8AE7EFFEC08AE3EFB0010AC05BC38AEE8A368504061F0ADB74258AC52AC3F6E68BC85232F6C1E2028BC2D1E22BD5518BC8F3A52BFA2BF259E2F45AE80500C38ADDEBF88AC6F6E38BC88AC78AE032F6C1E2028BDAD1E28BF12BD58BCBF3AB2BFA4E75F7C32E8E1E3F04890E60048AC52460A8207406B9001EE99400F6068704010F858B00803E4904077406E819FC7401C3F6068704087403CD42C38A3685048AD6FECA38CD7E1F0AC974648AE98ACEFEC9EB5C38D174588ACE80FD037C048AE9D0EDFEC9EB4980F9037E448AE12AE50AE4750A38CA7438FECA38CA74328AC50AC138F07E0A80FC027E1280FD027FC880FC037DBF8AD6FECA38D174138ACEFEC9FEC98AE92AEC80FE087F04FEC1FEC5B40AE805FEC32E8E1E3F04A2620432E48BF0F7264C04A34E048BC8E87AFB7407803E4904077702D1F9B40CE8DCFDD1E68B845004E827FEC32E8E1E3F048A264904E8359F7407C70650040000C3E848FB740B80FC0774067708E877FCC3E89FFBC380FC137C03741FC3E84EFA8AD88BC1E885FA8B2E4A0452F6268504F7E58BF703F05AE890FAC3E830FA8AD88BC1E867FAC1E703528B2E4A04C1E503F7268504F7E58BF703F05AE855FEC32E8E1E3F048A264904E8E1FA740C80FC077407774080FC037F04E853FBC3E81EFCC3E8EAF98AD88AC18AE6FEC4E81DFA2B3E4A04C1E70352F7268504F7264A04C1E0038BF72BF05A8B2E4A04C1E503F7DDE800FEC380FC137C0374C6C3E8AFF98AD88AC18AE6FEC4E8E2F9528B2E4A04F7268504F7E52BFD8BF72BF05AF7DDE8E9F9C32E8E1E3F042E8E064504E85DFA7411803E4904077C182E8E0643047403E9B100E849FC8BD8268B078BEC89461AC3A15004E8B7FC8BF0BB08002BE38BEC803E490406751FB90400268A0488460045268A8400208846004583C650E2EBB80002B280EB17D1E6B90400E856FC81C60020E84FFC81EEB01FE2F0EBE22BEBC43E0C0132F680FB0E750926837DFE107502B680161F8BF58BCBF6C6807401475657F3A65F5E7423FEC003FBF6C680740147FECA75E2FECC740F2E8E1E3F04C43E7C00B080B280EBCB32C08BE503E38BEC89461AC3803E4904137C057502EB5AC32E8E064104E818FC8BF08B1E85042BE38BECB80508B90500BACE03803E49040F721AF6068704607513B40AF7C601007502B405B007EFB80518B90501EF518BCB268A04F6D08846004503364A04E2F158EFB8000132D2E944FF2E8E064104A150048BD032F6528AC432E4F7264A04F72685045A03C28BF08B1E85042BE38BEC538B3E4A044FC1E703C1E603B9080032E4268A04D0E40AC0740380CC0146E2F18866004503F74B75E35BB8000132D2E9ECFE33EDEB03BD01002E8E1E3F042E8E0645048A264904E8C4F8740F2E8E06430480FC0774057C3DE90B028AE38BF08ADF32FFD1E38B8750048BD0A04A04F6E432F603C28BF8D1E70ADB740BD0EBA14C0403F8FECB75FA8BC60BED7503F3ABC3AA47E2FCC3502E8E064504A15004E8EEFA8BF8A050048A264A048BE858A8807408247FC5367C00EB04C5360C018AFC32E4C1E00303F080FF067469D1E78AF3B05580E303F6E38AD88AF88BC550B204F6C6807527ACE855FA23C3ABACE84EFA23C3268985FE1F83C74EFECA75E783EE0881EF3E0158E87200E2D2C3ACE82EFA23C3263105ACE825FA23C3263185002083C750FECA75E583EE0881EF3E0158E84900E2A9C38BC550B204F6C380741FAC263005AC263085002083C750FECA7FEF83EE0881EF3F0158E82000E2DAC3ACAAAC268885FF1F83C74FFECA7FF183EE0881EF3F0158E80300E2BDC3FEC038E0720632C081C7F000C38A168504F6E28BF032F68BEA660FB6065104F6E2660FB7164A0483FA647503BA680083FA5A7503BA600081FAAF007503BAB00052F7E2660FB7F8660FB60650046603F866C1CF1003FA66C1C70381CF00FF66C1C7105A8AE24AC1E203A0500450C5060C0103F02E8E064104585751509CFC8BCDE83B00B508AC8AE08AC7D0E473028AC32688056647FECD75EF6603FAE2E29D58595F83C708FEC038E0720E5132C08BCD4903FA83C708E2F9592BF5E2BCC3065233C08EC066C1C7108BC766C1C710E8A49A741638E074120FB6D0E88BC98AE066C1C7108BF866C1C7105A07C380FC137C0B0F8418FF80FC620F8411FFE80100C380FC11750680E38080CB0F50538ADF32FFD1E38B9750045B2E8E064104E807F98BF88B2E85045832F6528B364A04568A268504C5360C0180FC0E7509837CFE107503B41046F6E403F0B603F6C380756DB2C4B8020FEF5A5850524A8AE0575151578BCD32C0AA03FAE2FB5F47FEC438D4760A32E48BCD4903FA47E2FB59E2E0595FBAC403B0028AE3EF5B4B5A51578BCDAC268A25AA03FBE2F75F472BF5423BD3760A33D28BCD4903FB47E2FB59E2DDBACE03B80300EFB2C4B8020FEFC3B2CEB80318EFEBBC2E8E1E3F04803E6304B4740BBACC03ECA8017504CD42C3C3E8D1F80AFF751C8AE380E41F80266604E008266604E82D008A1E660480E320B105D2EBE891F57419A0660424DF80E30174020C20A2660424100C020AD8E85300C3E87EF8C3535080E30F8AFBD0E381E310070ADFE860F5740EB4008AC3E82CF30BED740326881D8AC3E80B000BED740426885D10585BC38AE01E2E8E1E3F04803E4904331F7F088AC4B411E8FEF2C3E830F8C39CFAE89F05B2C0B90300B4018AC4EE8AC3EE0BED74044726881DFEC480C302E2EBB020EE9DC32E8E1E3F048A264904E8F2F4740A80FC0777067403E8C0F5C380FC137C03744CC38AD8E8BBF7BACE03B008EF2E8E1E4104F6C380751CB2C4B802FFEF8A25C605008AE3EF8A25B4FF8825EFB2CEB808FFEFC3B80318EFB2C4B0028AE3EF8A25B4FF8825EFB2CEB80300EFEBE1502E8E064104A14A04C1E003F7E203C18BF858268805C32E8E1E3F048A264904E86FF4740F80FC07770B7408E85FF58BEC89461AC380FC137C037429C3E835F78ACC2E8E1E4104BACE0332FFB80403EFD0E78A1D22D9740380CF01FECC7DF08BEC887E1AC3A14A04C1E003F7E203C18BF82E8E1E41048A058BEC88461AC32E8E1E3F048A3E62048ACFD0E132EDBE500403F18B148A0E49043C0D764A2E8E064504E8EEF375338A1E4A048AF88AC6F6E38ACA03C8D1E1030E4E048BF98AC7AAD1E941FEC238DA735989148B166304B00E8AE5EF8AE1FEC0EFC32E8E06430480F90774C3E98300750432D2EB0F3C0A751D3A3684047503E99300FEC68914E892F3750580F9077F058BC2E84CF6C33C077504E8C581C33C0875830AD274DEFECAEBDA32FF32D22BCB3A3684047406FEC603CBEB9589148B166304B00E8AE5EF8AE1FEC0EF2BFB2BFB268A6502508B3E4E048BF3D1E603F7A08404F6E38BC8061FF3A58BCB58B020F3ABC3B90100B40AE8BCC6FEC23A164A0474038914C332FF32D289143A368404742EFEC6EBED89142E8E064504E8FCF2740E2E8E06430480F907740432FFEB108BC2E8ADF58BF9D1E74F8B1E4A04EB9133C98A3684048A164A04FECAB001E970F72E8E1E3F04F6068704087403CD42C3E876F68BECC6461B00C32E8E1E3F048ADF32FFD1E389975004D0EB381E620475058BC2E85CF5C32E8E1E3F048ADF32FFD1E38B9750048B0E60048BEC894E16895612C32E8E1E3F04A0870424800A0649048A264A04F606870408752DE85DF27407803E4904077F21518ACC8A2E8404BEDB8581FEE48574102E3B0C740583C603EBF024802E0A4402598A3E62048BEC89461A895E0E894E16895612C3841823842B33842A322E8E1E3F043C047F1B5052BACC03ECA8015A587408803E6304D47408C3803E6304B475F83C1C73F432E48BE8D1E52EFFA617864F866F868186B686008600860086DB86F386F78600860086008600860086008625870086298744870086838700869187AC87B387BF87E387803E4904137415E8BFF48BC386E0E870EF0BED74078AC732FF268801E893F4C3E8A6F48AC7E844FC0BED74F026887D11EBEA803E49041374E306E88CF41F0BED74078BF2B91100F3A48BF2E8DE0132E4B91000B2C09CFA8AC4EEACEE9DFEC4E2F4ACE807FCEBB580FB0177B0E843F4B2C0B030E8FBF024F780266504DF80FB0074070C08800E650420EEEB90E89D018AC3B2C0E8DBF08BC8EEB020EE8BEC884E0FE978FFB311EBE48BFAE805F4B9100032E4B2C08AC49CFAEE42EC268805FEC44AEE9D47E2EE9CFAB011EE42EC9D268805E8E3F3EB5AE8CE00C38BFA518BC3268A35268A6D01268A4D02E8CA0083C7034359E2E8C30ADB751AE8B6F3B2C0B030E86EF0247FF6C70174020C80B430E870EEEB1DFECB751CE898F3B2C0B030E850F0EEA8807503C0E702B4348AC7E851EEE87FF3C38AC3E8D1008BEC894E16887613C38BFA518BC3E8C30026883526886D0126884D0283C7034359E2E8C3BAC6038AC3EEC3BAC603EC32E48BEC89460EC3E83FF3B2C0B034E8F7EF8AF8EEB030E8EFEFB301A8807505B300C0EF028BEC895E0EEB9C518BC3E87300E82A008AC3E852004359E2EEC3F6068904027403E816008AC3E83900C3F6068904027403E806008AC3E82E00C350B01EF6E650B03BF6E550B00BF6E15903C15903C1B164F6F180FC327C02FEC08AF08AE88AC858C352E839005A538BDABAC8039CFAEE428AC7EE8AC5EE8AC1EE9D5BC3E81F00539CFABAC703EE4242EC8AF8EB00EB00EC8AE8EB00EB00EC8AC88AF79D5BC35051E881F2B9FF7FECA8087502E2F95958C32E8E1E3F048BF8240F81E7F000C1EF0383FF067F182EFFA5A788AF88C4886289BE893C0374083C047F03E8CF01C3BAC403B0038AE3EFC33C0477F2505350528B166304B007E8EBEE8AE0D0EC80E401A840740380CC02B012E8D8EE40A38504B009E8CFEEA8807404D12E8504A185048BD03DF401731BBAE0013DC2017313BA90013D7C01730BBA5E013D4A017303BAC800891685045A58C6068404FFE85D015B588ADF32FF0AC0740EB30E3C017408B3083C027402B3108ACB8AE981E9010280F9087E0481E90101871E850453E85BF25BE88502C30AC07411FEC8741AFEC87438FEC8743CFEC87440C3892E7C008C067E00C38CC88EC0FECA0ADB740732FF2E8A97A289890E850488168404892E0C018C060E01C3000D182AE80903B90E00EBD6BDB258B90800EBCABDC560B91000EBC20AC075BD8B0E85048A16840480FF07773580FF0177100AFF7506C42E7C00EB26C42E0C01EB2080FF02750B8CCD8EC52E8B2EA471EB100E078ADF32FF80EB02D1E32E8BAF158A8BC58BEC894E1689561289460A8C461EC3C560B258B25CB260C560C57053068A264904E8C7C3268A4702268A6733F6C4017422BDC5603C107D0EE871028C060E013C0E7D07BDB2588C0E0E01892E0C01E81001EB2DB4843C107D13B4813C0E740D7F15B4023C08740580CC80EB0A26F6470501740380E47F86C432DBE80600E8C901075BC38BF88BF2BACE03ECB80500EFB80604EFB2C4ECB80204EFB80407EF8BD68BC750247F0AC074220E0733D2B900013C047507B710BDC560EB10FEC87507B70EE8E801EB05B708BDB258E82D0058A8807400BAC403B80203EFB80402EFB2CCECA801B8060E7502B40AB2CE50EC58EFB004EE32C0EEB80510EFC3FC0BC97501C380FF0E750A26837EFE10750380CD801E061F2E8E0641048BFAC1E705B0405380E303F6E35BF6C3047402042086E08BD003FA8BF5E32832C086FB32FF51F6C5807401468BCBF3A483FB207407B920002BCBF3AA59F6C580740146FEC975DE1FC38A264904500657C43EA80426C47D0C8CC50BEF74308BEF83C707268A053CFF742438E0740347EBF28BFD268A05FEC8A28404268B4501A3850426C47D03893E0C018C060E015F0758C326F64733017401C3C41EA80426C45F088CC00BC3741FBF0B00268A013CFF7415473806490475F2268A0732E4870685048BD8E80100C38B1663048A268504FECC80E41F9CFA80FAD4740BB014EE42EC24E00AC4EE4AB009EE42EC24E00AC4EE9D8AC88BC38A168504F6F2803E8404FF7507A28404FE0E8404F6E2F6C1807402D1E0488AE0B0128B166304EFA04A048A268404FEC4F6E4D1E0050001A34C04C38A264904500657C43EA80426C47D088CC50BEF744A8BEF83C70B268A053CFF743E38E0740347EBF28BFD268A3D268A5D01268B4D02268B5504268A450A3CFF7402FEC850A08404FEC0F6268504A3850458A2840426C47D068BEF32C0E8DBFD5F0758C3505351522EA149040BC074092E8B2EA4710E07EB08B83011B702E8C7BE5A595B58C33C047C01C3E3FD532E8E1E3F0486FB32FFD1E38BFB81C750048B355B8915568BF05153268A4600453C0D7F1F750432D2EB403C0A74323C077505E83179EB623C0875080AD2745AFECAEB27F7C602007405268A5E0045B90100B409E864BEFEC23A164A04720C32D289153A3684047306FEC68915EB2B50E8ADEA7508B80008E840BEEB09803E49040774F132E4863E6204538AFC55E825005D5B863E6204588B155B59E2155AF7C60100750289158B053A3E62047503E834EDC3E964FF33C98A3684048A164A04FECAB80106E8F3BDC32E8E1E3F040AC0750DE818008BEC895E0EC6461A1AC33C017509E841008BECC6461A1AC3A08A04BFA28E2E3A057204BBFFFFC332E4D1E003F82E8B5D040ADB74050AFF7504C386FBC3A0100424303C307406F6C30175EFC3F6C30174E9C3BFA28E2E8A0D32C083C7042E3B1D741286FB2E3B1D740B83C702FEC038C87EEBB0FFA28A04C3BB0800F606890402740EBB0700BACC03ECA8017418BB0800BAB403E8DFEC7421B701E88CE980FAD4741786FBC3BAD403E8CAEC740CB702E877E980FAB4740286FBC30F080F080F080F08030103010101000801010101010101010F010F080F0400020F0201010F01FF01FFE00F00000000070208FF0E00003F00100108000000000100020201000404010005020500060106050600080108000702070607CA003400900096000000000000005F57C390506652E8F4FFFFFF81EF100000002E8B0766BAF80CEF66BAFC0CED32C0668BF8665A58C366B84F03665266565357500AFF7544E8C8FFFFFF6633F666BB5300E848000000C1E810F6C440752B6681E2FF0266D1E2668BC26640C1E010668BC266BB1300E83000000066BB1200E827000000665832E46650585F5B665E665AC39066B84F03C39066B84F03C3906652E811000000ED665AC3906652E805000000EF665AC390668BD75033C0668BC36603C6C1E002EF6683C20458C3AA379D379D379D378837883788378837CA3341346B34AC35AB35AB35F1355636863643376C376C37E335D635D635D635D635D635F1355636863643377137B7376C376C37FFFFFFFFFFFF0000FFFF0000FFFF0000FF000000FF000000FF000000FF000000000008100008101800081018CE3101CE3102DC4503BC4503F33203A73203CF3104E83104F83104CE3103000000007B3900027B3901027B3902027B3903027B3904027B390502753B0002753B0102753B0202753B0302753B0402753B0502AA3B0002AA3B0102AA3B0202AA3B0302AA3B0402AA3B0502E53D0002E53D0102E53D0202E53D0302E53D0402E53D0502E53D0002E53D0102E53D0202E53D0302E53D0402E53D0502AC3C0002AC3C0102AC3C0202AC3C0302AC3C0402AC3C0502E83C0002E83C0102E83C0202E83C0302E83C0402E83C0502593C0002593C0102593C0202593C0302593C0402593C05028D3C00028D3C01028D3C02028D3C03028D3C04028D3C05023D40000070400100704002005D4000004B3F0002443D0002443D0102443D0202443D0302443D0402443D0502633F0002B8410500B8410100B8410000B8410200F9410000F94102003E420000CE3E0002CE3E0102CE3E0202CE3E0302CE3E0402CE3E05028A400000B240000033410000AE410000923D0002923D0102923D0202923D0302923D0402923D0502AD410001AD410001B13A0002B13A0102B13A0202B13A0302B13A0402B13A0502D2400000AE410000AE410000AE410000E33F0000D53B0002D53B0102D53B0202D53B0302D53B0402D53B0502043C0002043C0102043C0202043C0302043C0402043C05023A3C00023A3C01023A3C02023A3C03023A3C04023A3C0502F540000018410000D63C0102D63C0202323D0102323D0202A60002010C930000000000000CAB00003293000000004294000000000C95449900000000000000000000000028A07E93EC93D0981494000020C3000000000000000000000000E4A056A1CAA100000EA2000054C20000DEA2B4A474A5D2A614A7BABF0000000028A70000DEBC00000ABFEEA80000C6AA0000000000006CC13ABE0000000000000000000000000000000000000000000000000000000020AE2CAF62BA82BC00004A000201000000004CD144C314D20CC440C448C668DD92C800009CC456CAA8C43AC8C2CA00001CC548DD000034DD000030C50AC678DC0000000010C680D2000000000000C8DC000000002500020100083700004BE50004491900020502060000005215523D5218521A0D655300025B004B000101000037000042210063001F006301390063033F00630245005A5A5B030540000005042D1940001505400201020C00400200000D005B020000E30D5B020000E70D5B020000E80D5B006E0002010C083700003D2500004422003D250006445D003D2500044458005538005B01050000616001003CE5010080492A000105000062600100010101000156004003A940000105000061600100010201004002E500015B02E500015B01050000616001003CE50100804965005B280002010000370000010500006CA80100020000010002010100010500006DA8010002000201005B2E0002010000370000521603014100150541100102600F41030140001B0540100102620F400105F30FE10A602D5BCA0002010404370000660C030C4100002D0A41422D0D4204003D240006004431002D0D4208003E0A42414519005520005B5600430324430500030446000033054601000000010200004603000001000D020100442D054602000000010200004603244304004BE5000149AA0007020100452D05460100000001020000464A02010044449000032943000EA200444398000329430008A2004533054603000000010200004601020100005B0D020100440104000000003DA5000144C400070201004543C9000D020100445BC303010710083700003D2501FF44A1033D250119469D033D250102479D033D25011445A1033D05000000000044FD01661B5600023DA501024941005608404353003DA50103494E00560840435300030C4018003E0D400000446200030A02404366000EE501804BE5010249740002A9020255280203010000030546A86100003DA50100448D0003054650C300005CA50F5EF3085528013E0500404B4C0047A7001B05000143BC002C6501013E0500A025260048BC001505000143A700142D01044BE5018049EB00210502800000007C0240007E0240467C0540100000007E0540350C00000302024043EE00560002270200462105410000010027024046030A42403E054100000000491601030D40010056080143400103024046030201410302034127024041030240033E054100000000491E0127020103030A014027024603030A0301030A0140038A0142270200463305401000000015054005038A034066FF2D0D42AB035600400321400133254014152540012D0A4240030C4800004A25065E044423025600404BE50130449B014A25F15D0144DC0143A3014A25F15D0149DC010300400B5E090D40F0FF3E1A400349DC013C02075E0149DC013C0A0A5E0349DC010300400C5E092540703E29400149DC013C02085E0244E0010EE501013A00004BE501014475034BE5010249FD013D25020446FD0155280252233A000002010302020502000003040221020132250214524D020102033D050000000000449D033DA50100444E0202010302020502000F030002210201322502144BE501304448020EE50201524D0201020366FF2D0D42AB035600400321400133254014152540012D0A4240030C480000030540000038003E0500C0C62D0047A0025EA540CF203E0500E067350047A0025EA540CF103E050000093D0047A00209A540CF5CB20F5EC34003054020001C243DA5010044BB0203054010000C125C9A105E0300405C1A0B5E0F00035CA20B5E8F40560040032940010F2540014BE5018049E5020F6540015C0A0C5E8BFE40078D0D5E0FE03E8D010000490A033E0D030000490A0307E50E5EFE430F030DE50E5E014AE50E5E014927034A650C5E0149270307E50E5EEF432C030DE50E5E100102075E010102085E027C050200EC04007E0240462705400A0000000102095E40010A0A5E033A00003DA50100449D0303010002020502000103040221020132250214524D020202003A00003D250204469D030225030202E103020261030102B9030108A503040EB1030202010200522E3A00005B0225010B4375037A18000000D800B001880260033804000000010002000300040005007300020100003700003D65000144720056004003214000212540DC030A48400105B63A000100005C052D3BCFFFFFFF200000005C05403BCFFFFFFF200000005600400321400021254080030A48405C050150FFFCFFFF0003000056004003214000150540195C025050FFFFFFF1403A00005B5B00E4060201080437000042290063071302630817005A5A5B0D25C839025C253447FC010125320100010542350000000001054035000000000105463500000000010544350000000001054A3500000000010548350000000001054E350000000001054C3500000000010552350000000001055035000000000105613500000000010563350000000001056535000000000105673500000000010569350000000001057235010000000105DF39021000000105B33A000000000105B13A001B5D050105063B350013000105073B361100000105083B41E601000105093B0000000001050A3B0000082C01050C3B0204000001051F3B5E4E010001050A3B0000082C01050D3BA401000001050F3BA40100000105143B000200000105153B49D200000105183B200000000105193B240D000001051C3B0000000001051D3B000000000105ED3A000092060105EE3AAA0800E00105C939FE0100000105CA391E0500000105CB39BA0400000105CC39240400000105CD39A20800000105CE39FE0100000105CF391E0500000105D039BA0400000105D139240400000105D239A20800000105D339FE0100000105D4391E0500000105D539BA0400000105D639240400000105D739A20800000105D839FE0100000105D9391E0500000105DA39BA0400000105DB39240400000105DC39A20800000D25C839020D25DA4101012533470001253147000125324700012545480001658B4FF05B01051F35FFFFFFFF010520351F00000001053B016402120001053001A0861100010531013C000108018D8338640001258238010125320100010542350000000001054035000000000105463500000000010544350000000001054A3500000000010548350000000001054E350000000001054C3500000000010552350000000001055035000000000105613500000000010563350000000001056535000000000105673500000000010569350000000001057235010000000105DF39021000000105B33A0000000001058F3B1000000001056B3C200000000105473D300000000105233E40000000550001200D01DC00030A48400105B13A001B5D050105063B350013000105073B361100000105083B41E601000105093B0000000001050A3B0000082C01050C3B0204000001051F3B5E4E010001050A3B0000082C01050D3BA401000001050F3BA40100000105143B000200000105153B49D200000105183B200000000105193B240D000001051C3B0000000001051D3B000000000105ED3A000092060105EE3AAA0800E02C0501010000003D0D01050045FE025608480105C939FE0100000105CA391E0500000105CB39BA0400000105CC39240400000105CD39A20800000105CE39FE0100000105CF391E0500000105D039BA0400000105D139240400000105D239A20800000105D339FE0100000105D4391E0500000105D539BA0400000105D639240400000105D739A20800000105D839FE0100000105D9391E0500000105DA39BA0400000105DB39240400000105DC39A20800000D25C8390255000166FF2D0D42DA06030C4800000D25DA4101200D011B00030A4840012133470101213147010121324701200D010400030A48400121454801200D011000030A4840030D4000F00F614001016A8B4F402C0D0101002D0D4202003D25010545600456084855000152172C2501013D25010545BE040205010502000052296608030C410C003E0D41000044020501A5150103010513011027000001011401010D251501014A6515010244FA040101420101010146010101014A010101014E01010101520101550001524E5C05DD5D00F0FFFFAA0A00005C056353FFFFFF00000000305C056553FFFFFF00000000305C056753FFFFFF00000000305C056953FFFFFF00000000305C056B53FFFFFF00000000305C056D53FFFFFF00000000305C053155EEFFC0FF110001005C053156EEFFC0FF110001005C053157EEFFC0FF110001005C053159EEFFC0FF110001005C05315AEEFFC0FF1100010001059A550100000001059A560100000001059A570100000001059A590100000001059A5A0100000002250107523302050100070000550002524D2C2501013D25010645E805661603A40006002D0D420800030A00423EA50000447906030A4200030C0104003E0D0121214425063E0D012122496D06030C40080066162D0A424003244000003E2540FF446D063E25401449650603044002004C054000010000446D063E0D01212244620601A5596101436D06436D062D0C4201004330062D0D00100033A500014305066616030C4104004C0D410200448D060DA54C0002521601015339020101543903010555390000000003014101150541180102C40041030141011B0541080102C900410300415539010259394103014003330140022D02404101025A39405B7A0A0000006B01D60241040B29BC000201000466FF5608472D0D42740003214700092547F042224763005B00636056006320360063904E0063A03E0063B046005A5A5B2D0D423000435B002D0D422400435B002D0D423C00435B002D0D421800435B002D0D420C0003214700092547072D0A42472D0A4247030C4800005B7ABC000000800000018001000280020000000100020003000400050000DC00B801940270034C0400006B01D60241040B29762A0000D800B00188026003380400005A00B4000E016801C20172000101000037000056004003214000210D406B01030248400125AC41013D650002494C00010DBD4101005400BB410D25AE41010105AD411100000007A5AC41FE0105AF4111011101436E000105B141000000010105B541000000010105AF41110111015400AD41010DBD4100013A00005B7300010100003700005214030041C041331A4141038A4041030041C141331A4141030A40413E0540000000004936000305407008000F0E2500B052143D650000446D000102164D400105174D000000000105184D000000000105194D000000005C05144D8FFF0FFF310000005B0725144DFE5B0043000101000037000052143D650001443A000D65015003542001504AA5015001491B0054200F5056004020250001030A484007E5E8397F433F000D250150013A00005B00CF000201000037000042290063001B0063011B006302AA005A5A5B66FF5608402D0D42C30003214000152540012D0A4240030C4800003D6500004472000D25CC00013A0000018DC000000251020105C600000010000105C80000005000010DC30002005420CA000105C20000010000431A000725CC00FE3A00000D25CA00010125C2000107A5C100FE0D25D500010D65D500014A65D500014493005408D5005400C6005400C800431A005C65D400FC0201A1C000002BA5C000010DA5C100015B7A0C00000002002C002D002E002F0000D501030104003700006608030546102700003DA50002491E00020200465B0305400C0000002121400066FF2D0D4281012D0A4240030440000003044104000304000800010200004003884001000318400100098D40FF013E8D40000049990001020000410300400100090540FF0100003E0D4000004982000305460071020043BC00210240460300410100090541001E00001B05410943B4007C0240467E054000000100030041010009054100F000001B05410C75024041030246403DA5000149C800020200465B3DE50000490B0156004003294000210D400A00030241002D024041010200004003004101000905410000F0071B05411402E200413DE50000490B01020500102700005B5600400339400055380066FF2D0D4259013E0C400200472C012D0D420800431C01330C400400210C4006002D0C40000003094200550000020A00407C054640420F007E014000020200405B7A7C00FFFF070000000000C8003F000800190040065F0040003200800C7E006000640000327F007F006400116C0100006C01004C6C01000D6E0100006E0100486E01000D70010000700100487001000D6E0100006E0100486E01000D7E0100007E0100487E01000E72010000720100497201000EB0010000B0010049B0010000BF0002030400370000560046560000032100005520003D650003442C003D65000D46B40002290000322500080E25006052145C222855F80002220000030D41010066FF2D0D42BB002D0A424103240000003DE2000048A0003E250004446F000322460033254601152546040F254601333900003E250001448C003E250002448500032546210365002F439000036500130379460033654601152D46030F65460152140102014D460152004D005400054D5400FF4C3A00005B7A040003020104005E01010404083700003D6502014927014BA50203492A0052250205000000000002050100050200432F005528025225033800C400034800C9000E2502905214082502070D05B43A111101005C25B33A0B0103214102152541040D22B33A410D65B63A015C25DB3AFD01030241001B054108010ACB3A41010ACF3A41150500180102CA3A000102CE3A004BA5020349A0002B05CA3A000010002B05CE3A00005000010DA73A8000010DB13A0003010D0C3B010301050A3B0000082801050B3B0000080001E5EF3A0801E5EE3AE05400A93A0119AA3A000189AA3A000119AE3A000189AE3A00070DA53AFFF866FF2D0D424F01030C4000003E0D40FFFF440E013D8C010000440E012D0D42030043F1000124A53A02000109C73A010725B33AFE0725DB3AFE3A00005B0E25029052143D650200493C010D25B33A014348013D6502104448010109C73A013A00005B7A0F00010001010103010502020008FFFF0842000101000037000052143D65000144210054204B504A654B5001491600433E005C4D1B50FEFF00014AA5015001443E000D254B50014A654B50014436003A00005B1300010300003700000E2500A052143A00005B00C6010101001856004003214005210D408000030A4840370000010D47500D003D8D010D00462C000119475001018D48504001010D49502C01030941002D194100038A41412D8D4101001B1D4102011A485041330D410100010AEA4F415408EC4F0199EC4F02031941003309410256184103B14104331A4141018AEB4F4103194100330941022D1A41412D0941004B2504104498002D094100010AEB4F4103214104092541021B2541010122ED4F41030941012D194101330D410100010AEF4F415408F74F0199F74F03031941013309410356184103B94104331A4141018AF64F4103194101330941032D1A41412D0941014B25042044FC002D094101010AF64F4103214104092541041B2541020122F84F413D65050044210107650150EF4326010D65015010030046EB4F020002F64F56004003214005210D400100030A4840560040030940023D650500495301330D4002001505400F5600413D8D020D00486B01030D410D00331941020F0240410FE540800102E8394056004003214005210D406B01030A48400109C341000189C341010109C441000189C441010102C041460101C141025400BE410131BE410401B1BE41045400BF410139BF410401B9BF41043A00005BD80101010000370000560041033941010925410F3E254107491C005B560040036240410102585340030A464266FF2D0D42C001152541022D0A4241030C4800000705905D00000100030C48020003054050C300005600410321410027024041150540100325400201026253400105635340000030030A42465608480D255A530154005953560041037141010FE5418001027253410369410003A5410101027253414B25010144D5000371410003A5410201027253410379410003A541030102725341030540003101002DA9400101026E5340430801037141010F65410103A5410201027253410305400011010001026E53400305400130000003A9400101026F53405CA55853CF100D2558530102650002560040032940012D254004210540C80000005600410321410027024041030A4140330D4101003E0D41000044AC0151644A255B53044432014A655B533149AC01026500014B25010149AC0101057253010003803D65010149730102A800725343AC0156004103194100560040030A40413B02400328407253036840725303A840725303E8407253040200402DA541042D0D4104003EA94101457A010D255A530201255853025101540058535B7A18000000000004000200080004000C0006001000080014000A004600020200043700005530003225000120250008560848032248400DA5D5530102A000D45308A500034A25D45302443C005C0DD553FFFE01004342000D0DD55301013A00005B1403010500003700000E25006052140825000F422900630F530063110902631266026301CC026300F5026308D8016309B901630AC0016313C8016314D001630BE001630CBC02630DE801631001025A5A43B50154009A55010D2B551F003DA500004472003DA5000244A2013DA5000549A2015400C9553D250200498100022502023225020101E1C955024A25CC550149B5017B0501008000007E05408C0A000056004603294602270240460765D055FE0105D155008000000102D255400DE5D355100D65285504510107652855FB5101032140021525400501E2CA55405420CE5502A0022855030A464808A5020756004003314002210D408000038A4640030A4840038840EA4F030840EF4F2D054001000100039841EB4F031841F64F030A484601020C564001020D5641031A4846030040EB4F331A4040330840BE41330840BE41030041F64F331A4141330841BF41330841BF41030A4846010A0F5641018A0F5640031A4846030040EC4F338A4040030041F74F338A41414A25ED4F014485010FE540804A25F84F014491010FE54180030A4846011A0E5641019A0E564043B50107E528552F0D65285504510107652855FB51013A00005B5420D85543B5010125D8550143B5010125D8550243B5010125D8550343B5010725C855EF43B5010D25C8551043B5010D65D05501510A0725CD55FE510A010DCC55010251C843B5010D25DE551043B50101696F55023DA500034925024A2535551049250201A56F5502432A0201B16F55003D250200443F0232250201142502045CE16F558F023DA50005444D023DA50000495E0202A5000003394000332540010122CB554002E002705543B50102E00270554BE5020144B50102B0006F553DA50000448C023DA50005448C0202E5000443950202E000CB552CE500013DA5000244A3023DA5000349AC0254007055500243B50102A50000033143004A626F554444B5015408CC5551C80D25CD5501513243B5010D257055013DA5000044E102010DA1550F0143B501033943000302404433254001010AA1554043B5015400A15507257055FE070D6F55FF8007253555EF5420C8555420D85543B5010C01010604003700004229006307EA00630125006300C000630BED006304F2005A5A43050102650010524D3D65000044E6000265001152044BE5020149E6003DA50000495700030100000265000F553800524D020200000265000A550802524D3DA500004970000265000B524D4379000265000E524D43AD0020050164000000020501141E00022C2101000301000002020040520C26050064000000020201400202000002650001550802524D5105026500015204510A02650009524D43E6000265001252044BE5020144E60002650008524D0265000052043DA5000049E60002650000524D3A00005B43E600524D43E6006606022900000268004E00028C00200052335B0229000052335B350B020208003700003D25000344220B66FF2D0D42290B56004003214000152540012D0A4240030C4800003D650010497400026500013D25000445220B4AA5F95D0144220B026500004AA5155E0249220B0D25165E010705155EFFFFFBFF3DE50004456D004AA5155E0144220B0265000143220B3D2500044885000305000101010143C5004AA5F95D01447B004AA5155E0249220B0D25165E010705155EFFFFFBFF030500010100003DE5000144C500030500010100003DE5000244C500030500010101014229006307EF00630ADD0463014D056300DA0663097C086308EC09630B9F0A630E4D0A630F0E015A5A5B0105FD5D000000000105EE5D004000005C05F05DFFFF0FFF0000400043220B4AA5F95D0149220B4A25005E014942013C25F95D004942013C71F95D0049420108E50001030040F15D092540013E39400044220B5420F95D074DF15DDFFE4A65F15D40494C010D05035E010101010D25005E010DA5005E200D25005E010D05035E0101010103394000092540015C22F15DFE405C65005EC1060D25025E080DE5005EA05C05065EBBBBFFFF333300005C05035EF7F7F7F70202020266072D0C420A005600402025000C2D0A4240032440090003624040038A40405C02045EF8F8F8F8400321430003A246443DA500004415020305400400000066072D0C42040003044100003E054100000000444C024CA4460600490D022D0D420C0043EE010324400700434C020305400500000066072D0C42080003044100003E054100000000444C024CA44604004942022D0D4244004323022D0D42080003244005001505400E5C02005EFF3FFEFF400765005EFE3DA500004900035C050B5EFFFF8FFF000020000D050C5E010100005C050B5E0F00FFFF401600000D050E5E000000010105075E0500666601050A5E020000000105095EF32001000105085EF3DF000001050D5E000000005C050B5EFFFFF8FF000000005C050C5E8FFFFFFF200000000D050E5E0000001007050C5EFBFFFFFF01050F5E3E0008000105105E3E0018240105115E3E0000000105125E3E0034004390035C050B5EFFFF8FFF000010000D050C5E010100005C050B5E0F00FFFF600A00000D050E5E000000010105075E010052F854000A5E0105095EE90900000105085E5C0F000001050D5E000000005C050B5EFFFFF8FF0000040007050C5E8FFFFFFF0D050E5E000000100D050C5E0400000001050F5E3E000C000105105E3E0080880105115E3E0000000105125E3E0034000DA5065E080D25F35D010D65F15D204A65F15D40499F030DA5F15D010725005EFE0705035EFEFEFEFE4AE5005E1044B90366072D0C420C0003044000003E0540FFFFFFFF44EB030104F45D00000104F55D04002D0D42080043C8030105F45D382000000105F55D0C0000005600014A05035E2020202044240451022D0501010000003E0501A086010049FE030125F95D0343220B0D05005E00010000030040045E0905400700000021054003000000030541212000002D0241400102F45D41030041F55D0105F45D840000000102F55D41030541222000002D0241400102F45D41030041F55D0105F45D850000000102F55D413D25000445C004030040005E09054000C001001B05400A0105F45D21000000030041F55D0925410F0F2241400F2541800105F45D210000000102F55D415600413DA5000044CF04030D4101015CA20B5EF8410D65005E0143220B030A464866072D0C420A005600402025000C2D0A424020250002030A484001042E5D000007E52D5DFC030A4846030540010101013D250004452F054AA5F95D01442F054AA5065E01492F05090540FFFFFEFE0D02035E40510503024000690540FFFFFFFF0702035E4051C851C843220B4A25FC5D0149220B3C25F95D0049220B4C250001446C050D05065E040000004C650001447B050D05065E400000004CA50001448A050D05065E000400004CE500014499050D05065E0040000003024000150540040D02035E405600014A25FC5D0149220B0302400015054005030041035E09024140090540202020203E02414044EB0551022D0501010000003E0501A086010049A9050125F95D0443220B0302400015054004690540FFFFFFFF0702035E405600014A25FC5D0149220B0302400015054005030041035E090241403E05410000000044400651022D0501010000003E0501A08601004902060125F95D0543220B5600014A25FC5D0149220B4A250C5E80496E0651022D0501010000003E0501A08601004943060125F95D0643220B030A414856004003214000030A48400D25600101510A030A48410D25E85D034A25E85D04448D060D65F15D124A65F15D04449A064C25000144AE060D65F05D104C65000144BA060D65F05D204CA5000144C6060D65F05D404CE5000144D2060D65F05D800171F95D0043220B4A05065E4444000044220B0765F15DFD0725E85DFD030A414856004003214000030A484007256001FE030A48414C2500014416070705065EFBFFFFFF4C6500014425070705065EBFFFFFFF4CA500014434070705065EFFFBFFFF4CE500014443070705065EFFBFFFFF07650C5EFE5400085E5400095E030040065E4C2500014467075E0540FCFFFFFF030000004C6500014479075E0540CFFFFFFF300000004CA50001448B075E0540FFFCFFFF000300004CE50001449D075E0540FFCFFFFF003000003C02065E404451080102065E4003024000150540040D02035E405600014A25FC5D0149FC070302400015054005030041035E09024140090540202020203E02414044FC0751022D0501010000003E0501A086010049BA070125F95D0743220B0302400015054004690540FFFFFFFF0702035E405600014A25FC5D014951080302400015054005030041035E090241403E05410000000044510851022D0501010000003E0501A08601004913080125F95D0843220B0302400015054002690540FFFFFFFF0702035E400302400015054001090540020202020D02035E4043220B4A25FC5D0149220B56004020250002030A4148030248400DE52E5D10030A48413DA5000044A8080D65F05DF00DA5F05D010DA5E95D013DA5000044C4084A05065E3333000044D5090302400015054001690540FFFFFFFF0702035E400302400015054002090540040404040D02035E40030040065E4C25000144FF08090540FCFFFFFF4C650001440D09090540CFFFFFFF4CA50001441B09090540FFFCFFFF4CE50001442909090540FFCFFFFF0102065E4003024000150540040D02035E405600014A25FC5D0149220B0302400015054005030041035E09024140090540202020203E02414044800951022D0501010000003E0501A0860100493E090125F95D0943220B0302400015054004690540FFFFFFFF0702035E405600014A25FC5D0149220B0302400015054005030041035E090241403E05410000000044D50951022D0501010000003E0501A08601004997090125F95D0A43220B0302400015054003090540080808080D02035E4043220B0302400015054003690540FFFFFFFF0702035E4007A5F05DFE4C25000144110A0765F05DEF4C650001441D0A0765F05DDF4CA5000144290A0765F05DBF4CE5000144350A0765F05D7F07A5E95DFE56004020250002030A484007E52E5DEF43220B0321430003A2464466072D0C4204003DA5000344710A66072D0C4206003DA5000249220B03044100003E05410000000044220B3D020141468F0A4CA446060049970A2D0D420C0043710A030441080043FE0A08A5001B66072D0C4208000321430003A2464403044100003E05410000000044220B3D02014146D00A4CA446040049D80A2D0D42440043B20A2D0D4208003DA400000044F90A03244100003E25411844F90A2D0D42060043DD0A03044101005C020F5E0000FCFF415C02105E0000FCFF415C02115E0000FCFF415C02125E0000FCFF413A00005B7A0C000000D800B001880260033804001F02010200003700003D0D00000044CE01560041032141010925410F150D4102030A404266FF2D0D4207022D0A4241030C4802000DA5905D015408905D030C48000003F94101153D41045CBA10548F41030A42404A251054014981000D0D105401010D251054104A2510542044670007251054EF4A251054204974000D25135440560041030941003B0241033B41001B25410401A211544103694101152D4104012A1154415600400FE54080037340000102165440560040036B40000102165440036340000102165440037B40000965400F01021654403E254104471001332541042D054604000000036340000102165440036B40000102165440037340000102165440037B4000010216544043D7000D251354020D25115401032940012125400A2D2540644A251454014942015114332540013E2540004926010265010143CA014A051454F08FFF004454010265010243CA0101051654010000800300401654026A014002B801145408A5011F3DA50100467C010265010343CA0132A501013D8D00000044CA013DA5010044CA0103314101031940005618403B02400328401654036840165403A840165403E8401654040200403E25410447CA01332541042D054604000000439D013A00005B66FF2D0D420702030C480000018D18543200010519547A1C020001051A5410113D102D0D4204002C2500013D25000649D5015608485B7A1800000000001C0004003800080054000C00700010008C001400005C00010200040225010403314100090D410F00150D410166FF2D0D4250002D0A4241030C48000007A5905DFE010D905D111150024A0D935D0100494100022501135408905D5400925D3A00005B7A0C000000040008000C00100014005B01020104043700004221006307290063034E006302600063048400630C1201630D1B015A5A435A01010D455D9F0F66060124475D3000014C475D31000324463B003E254600445A015420475D5B0DE5475D015C05435DFFFFFFFD110003005B0DE5475D014A25445D024472000DA5435D010DA5435D025C05435DEFFFFFFD010000005B4A055300000200004494000D254B5D013D8D00000044110103054680F0FA0256004103194100210541FF0F0000270246403E05410000000044C4002D0D400100018A455D4056004103194100210240412702464001A54A5D0C010A4A5D4015054004560041032941002D0D410100210240411B054008010A485D400DE5485DC007254B5DFE4A654B5D014909015B0105435D000003005B0DE5475D014A05435D010000004441014A05435D10000000494E014A05445D010000004936015C05435DFFFFFEFF000002005B5C05435DEFFFFDFD010000005B00D00002010000010500C2000000E001053E26430000005C057E1238FFFFFF430000005C057E18F8FFFFFF030000005C057F12F8FFFFFF030000005C057F18F8FFFFFF03000000010517742D0B150003004026743E0540F900000049700001050BF000001200010525CE3021210343CF003E0540F6000000498D0001050BF000002100010525CE2301102343CF003E0540F000000049AA0001050BF000003300010525CE3120312043CF003E05400F00000049C70001050BF00000CC00010525CE2031203143CF00010525CE203120135BAF0003020C003700000301000003010101030102025216030146001B0546080202000002020101020202023D6502004936002C2202463DE502004941002CA202463D65020249480003014003090540000000FC3E0540000000D0496E00010563C000000040550000552002437200540063C0010164C00056004003214002010265C040010166C00103314002010267C0400101E8C0033D65020144A6003DE5020144A60051024AE5A0218049A6005B00B201020200003700003D250101448D003D250102448E003D2501034433003D2501004993013D050000000000495E003A00005B523C03004024013EF94000445A004AA524011044410003F9400001022401404AA52401104452005538005B5420A453523C03004024013E3940004489004AA52401084470000339400001022401404AA52401084481005538005B5B66FF2D0D429A0156004103394101152541022D0A42413D65010B49010120050064000000030C48020003004140010F254110090D41DFFF030C4800004A0501500100000044EA00030C4802003C0241014049EA003C02400141449301030C48020007254001EF0102410140010A400141439301560040038D400C003D650118442401038D403E003D65011944240103A9400133A540140331400109254003152540040F0D4001015600410329410133254114030C4800004A05015001000000447101030C4802004A254001104971013C22430141497101031A48403C0A000140449301031A484007250001FE030C4802000122430141070D4001EFFF031A4840010A0001403A00005B7A180000000000800004000001080080010C000002100080021400E700010808000301000002050005000100522920050064000000030246400202000003010000553800030540003200003D05000000000044640003024046270140003E05409C180000475300030540003200003E0540C8000000466400030540C800000066FF2D0D42C7003E0C400200477B002D0D420800436B00330C400000030C0106003E0D011900499A00270D403200210D400200439F00270C4006002D0C40040002E20040330C400400210C4006002D0C40000027024640020A004002B200405B7A2000C8004006080019004006800C40003200800C381860006400003200327F00640000CB00010100003700003D65000144610056004020250010030A484007258F4FFD4A258F4F04492000521407254650FE4A65465001492F0003214000210D40DC00030A48400725B43AFE56004003214000210D406B01030A484007258541EF43C70056004020250010030A48400D258F4F024A258F4F0444710052140D254650014A6546500144800056004003214000210D40DC00030A48400D25B43A0156004003214000210D406B01030A48400D2585411056004003214000210D405A00030A48400D254C4D013A00005B00240001010000370000030041E30D330541010000001B05410B01020600410D251F0E035BC8000201D6098002A000E0012D00100060000A0002000000000008080600123CA00F2003000158021C00280080000100040000000000000000006A3C6419000440010003260018008800030006000000000000000600553C302A00050802C003280060007000010003000000000000000000E93C302A0005980100042A0030007000010003000000000000000000EA3C8F2F7805D0011A04270058009000030004000000000000000200EB3C483F40063002B00432004000C000010003000000000000000000EC3C3400020100000000002A002A00002A2A2A00002A002A2A15002A2A2A15151515153F153F15153F3F3F15153F153F3F3F153F3F3F5C00020100000000000000000000000000000000000000000000000006000000C8320000000034210000B80B000000007D0000010000000000FFFF0000000000000000000000000000000000000000000000000000000000000000000C00020100000000800000007400010110010612110116121301066A1401166A1601065517011655190106EA1A0116EA650116E966010AE921010A1222010A6A23010A5524010AEA450116EB46010AEB750116EC76010AECD2011670D4010A70D8011671D9010A71E2011672E4010A72E8011673E9010A73F5011674F6010A74140002010200080080000002000400084000FFFFDA0001048A0E05001331580021220000B70000000800000014326B001E210000BE0000000200000013337E001E220000C5000000000200001334910020210000CC000000000400001335A40021210000D300000000080000010491000204020003040200230602000000FF010492000204030003040200230602000000FF010493000204040003040200230602000000FF010494000204050003040200230602000000FF010490000204010003040200230602000000FF14060F000000FF14060F000000FF14060F000000FF14060F000000FF14060F000000FF050001010000380004030400000024F40000102788130000000000000000C2014E0C01010000550000001027000000020501000606000000000000000000F20105030E00360046005A01A201307500000C003F053A400000409C00000C003F053E000000FFFFFF000C003F05F380000000000000FFFFFF000C003F053E00000000000000483F00003F004400001600000004011F00000004022C00000004033E00000004081B500000040925600000040A35900000041021B0000004112FF0000004182A40010004786900003F004400001600000004011F00000004022C00000004033E00000004081B500000040925600000040A35900000041021B0000004112FF0000004182A40010004F0D200003F004400001E00000004012600000004023000000004033E00000004082240000004092C600000040A37700000041027900000041132C0000004182E00010004683C01003F004400001E00000004012600000004023000000004033E00000004082240000004092C600000040A37700000041027900000041132C0000004182E0001000400000000000102030203000100070500000102030203000100070500000102030203000100070500000102030203000100070500000102030203000100070500000102030203000100070500083000009B0000000730000046250000083100009B0000000731000046250000083200009B0000000732000046250000083300009B00000007330000462500005600000005000000FFFFFFFF0000000058000205010A01000C02040264C0000065C0000066C0000067C00000E8C00000A021000042EC0000102700000C04000000000000000000000000000000000000000000000000000000000000000000000000000000000000C401020500000000000000000000000000000000245053505B4809DF160000000000000000000000400400000000030000000000010000000060000000300400000000000400000000E0000000000000000000000500000000010000000A0300000000000700000040040000400B0300000000000900000008000000E4C90000000000001100000000100100001005000000000012000000005000000020060000000000140000000030000000100300000000002100000010000000000B030000000000230000000050000000000200000000002D00000000F0000000400300000000002E0000000080000000900400000000003500000038000000ECC900000000000036000000004000000070060000000000370000000010000000B0060000000000380000004004000000050300000000003A0000000062000000C00600000000003B0000000003000000220700000000003D00000000400000002507000000000003000000006000000065070000000000420000000008000000C5070000000000010000000000000004010000000000000000000001012C0000C540736900550069000000900100007C99050000000000000000000000000000000000000000006C000201B55D000000000100B55D000008080200B55D000010100300B55D000018140400B55D00001A180500B55D00001C1C0600915D000008089000955D000008089100995D0000080892009D5D000008089300A15D000008089400A55D000008089500A95D0000080897008A060C0001E2011D0900007E3A00007D00080000001B000000000000000000007100000000000000000000000000010000000A0000006C070000F30400003E040000F3040000F30400006B030000F304000004050000040500002A0300000000000000000000000000000000000000000000000000002C010000300100003001000030010000300100006400000030010000340100002C0100002C010000000000000000000000000000000000000000000000000000800000000E0000001E00000001010101010101010100010101010000000000000000000000000000000000009808000098080000980800007E040000980800007E040000980800007E040000A203000014000000AC0D0000AC0D00006400000069000000020000000000000001000000010000000100000064000000640000006400000064000000640000006400000064000000640000006400000064000000000000000000000000000000200300002003000020030000BC02000020030000BC02000020030000BC02000071020000320000002003000020030000190000003200000000000000000000000000000000000000000000001900000023000000190000002300000019000000230000001900000023000000190000002300000000000000000000000000000008000000FBEFFFA7230600005F000000000000000000000000000000790000000000000000000000000000000F000000660000006E006900690073007300730073000000000000000000000000000000FC700000FF0100004B004B000000000000000000A50AA50AF00AF00AF8116810800000000000020000000000000000000DE04D3EFCDEA6BD7498273F000002000000803F000000000CE5243E8CDB083EE145073F010104000000803F000000000CE5243E8CDB083EE145073F010002002289923FBD35B03CF77520BE2731803F1D38E73D01000200331B643FC8EF0D3E000000004A7B033FDAACBA3E01000200BADA5A3F9CE1463E764FAE3FE86A03C03199C23F010002007BA05D3FBB0F003E3945C73D780BA43E0000C03E0200020000000000000000000000000000000000000000000200020000000000000000000000000000000000000000002C016C07E803E803E803E803E803E803E803E803E803E803E803E803E803E8033001F304E803E803E803E803E803E80330013E04B004B004B004B004B004B0043001F304E803E803E803E803E803E8036400F40171026B033001F304E803E803E803E803E803E80334010405E803E803E803E803E803E8032C010405E803E803E803E803E803E8032C012A03200320032003200320032003D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D001D0016C07F3046B033E04F304F304040504052A03D001000303033001FB01F00AF00A280A480D480D480D8813181518151815F401F401F40100000000D0010000010200005B00000800000003040451006B02000000000000000032003C0000009001900190019001900190019001900190011E00DC05800CAC0D5500DC0501000102000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000EC4CA13C6EC0E73C81785D3D73637A3D583934BC1361C33C000000000000000000000000000000000000000000000000000000000000000000000000000000000C010C0101010000000000000C010C0100020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000001E0046000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000CB00000000000000000000000000000000000000190019006F060000C5060000350700006F060000C5060000350700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C8000405000000000000000000000100000000000000000000010200000000000000000000020301000000000000000000030401000000000000000000040504000000000000000000050604000000000000000000060704000000000000000000070000E718E7180002010300000000960000002A000000160000001B000000FF0005000500FF00FFFFFF0001201F0001201F00011421000000000090010000008001000000000000000000000000000000000000000000000000000000000000000000000000006C0003030000021130750000CC55010000200000312C00004C000000200352034605BC0200000000800000000000000000000000000000000000000000000000DC05000084038403460584030000000000000000000000000000000000000000000000000000000000000000F70902044B0057003F061F072B090000000000000100080400200000FF00000000000000000000000000000033000070080472008108000000040400C00000004B345A4146333235424D0000000000FFFFFF00000000001C000000514C01005F4C01005E4C0100604C0100614C01008140010082400100834001008440010085400100864001008740010088400100894001008A4001008C4001008D4001008E400100904001009140010094400100954001009640010097400100A3400100A440010098400100A1400100A8610000000000002501000000000000BA08000040000000090905030D0005000202000208000000050303000500000011040500000001010100010100111800DB0100000A0A00001E0000001E00000043512A020F0000000C000A0A080300011F2A0C001E00000009F1130F1E0000000000000050C30000000000002D04000000000000BA080000400000000A0F0905170008000202000208000000050404000800000011040500000001010100010100121800B60300000A0A00003C0000003C000000455136021E0000000C000A0A090300011F2A0C003C000000C9F1130F3C00000000000000F82401000000000045080000000000003A090000400000000D170D0723000C00040400020C000000050505000C00000021060500000001010100010100151800910500000A0A00005A0000005A000000485146022D0000000C000A0A0C0300011F2A0C005A00000089F2130F5A00000000000000CC55010000000000550A0000000000004A090000400000000F1B0F0929000E000404000210000000050606000E000000218805000000010101000101001718007F0600000A0A0000690000006900000049515002350000000C000A0A0E0300011F2A0C00690000000AF3130F6900000000000000A0860100000000005D0C0000000000005A09000040000000101E0F092D000F0004040002100000000506060010000000210806000000010101000101001818006C0700000A0A000078000000780000004A5156023C0000000C000A0A0F0300011F2A0C00780000004AF3130F780000000000000048E80100000000007E00000000000000EA090000400200001426130D3900130006060002140000000607070014000000318A06000000010101000101001B1800470900000D0D000096000000960000004D5166024B0000000C000A0D130400011F2A0C00960000000AF4130F960000000000000040130200000000000704000000000000FA09000040030000152D170F4400170006060002180000000708080018000000310C07000000010101000101001B1800180A00000F0F0000B4000000B40000004F5178025A0000000C000A0F140500011F2A0C00B4000000CBF4130FB400000000000000785D0200000000000F04000000000000FA09000040030000162D170F4400170006060002180000000708080018000000310C07000000010101000101001C1800810B00000F0F0000B4000000B40000004F5178025A0000000C000A0F150500011F2A0C00B4000000CBF4130FB40000000000000020BF0200000000001F080000000000008A0900004003000018341B114E001A000808000220000000070909001C000000318E07000000010101000101001E18005C0D000012120000D2000000D200000052518602690000000C000A12170500011F2A0C00D20000008BF5130FD200000000000000B024030000000000280B0000000000009A090000400300001A3C1F135A001E000808000220000000080A0A001F000000311008000000010101000101001F18004A0F000014140000F0000000F000000054519802780000000C000A14190600011F2A0C00F00000004CF6130FF000000000000000143E030000000000300B000000000000AA090000400300001B412315610021000808000220000000080B0B001F00000031920800000001010100010100201800C60F000016160000FF000000FF00000056519C02800000000C000A161A0600011F2A0C00FF000000CCF6130FFF00000000000000E86E030000000000400B000000000000AA090000400300001D442515660022000A0A000224000000080C0C001F00000031920800000001010100010100221800B3100000171700000E0100000E0100005751A802870000000C000A171C0600011F2A0C000E0100000CF7130F0E01000000000000000000000A000000554C01007CFE000180FE000184FE000188FE0001A0FE0001A4FE0001091C0003C91A0003091B0003FFFFFF0000280000A8498840000004B08002000000000401C0C0C0C0C0C0C0C0C00000008000000080000000FFFFFF0100280000A8498840000004B08002000000000401C0C0C0C0C0C0C0C0D00000008000000090000000FFFFFF0200280000A8498840000004B08002000000000401C0C0C0C0C0C0C0C0D00000008000000090000000FFFFFF0300280000A8498840000004B08002000000000401C0C0C0C0C0C0C0C0C0000000800000008000000000000000400000004F4C0100504C0100514C0100524C0100534C0100544C0100564C0100574C0100584C01005E4C0100604C010000FE000104FE000108FE00010CFE000110FE000114FE000118FE00011CFE000120FE000124FE000128FE00012CFE000130FE000134FE000138FE00013CFE000140FE000144FE000148FE00014CFE000150FE000154FE000158FE000178FE00018CFE000190FE000198FE00019CFE0001A8FE0001B4FE0001B8FE0001BCFE000184FF000188FF00018CFF000190FF000194FF000198FF00019CFF0001A0FF0001A4FF0001A8FF0001ACFF0001ECFF0001F0FF0001F4FF0001F8FF0001021D0003031D00038C1C0003A10400051804000555020005FFFFFF001AA720000500000000002A000000060600040000F425E50F0000000000000000000000000000000000000000060003000000030400000305000000009C000408480448040000080000000800171000000F300000220A4C56500501000F0FDE00204004001042000000000000040000000000000038383043080810696600001B2A8C480000000000C0E03886000000000300000000142F2F22222B2B000000000000000000000000000000001C038E03AA028E03E300AA02E3007100E3007100550171001C0355011C038E03CF0030FFFF0C00F30080019000088001050000000E1000403FFF3F0F2B0000002200000010000000120000000000000016000000000000001800000024400100254001002640010024480100254801002648010024400500254005002640050024480500254805002648050024400900254009002640090024480900254809002648090024400D0025400D0026400D0024480D0025480D0026480D00FFFFFF00100000006754130220314576100000001023754664573201100000001023754664573201100000006754130220314576010000001023754664573201010000006754130220314576010000006754130220314576010000001023754664573201000000000050000303000000000010050000020100000000007D00E40C0008700010270000CC55010024F4000050C3000010270000000000006B0000008000000000000000000000000000000000000000000000006C00040205030E002106400000000000FF0005070C000E0000000000000001030E002106400000000000FF0001070C000E0002020000000004030E001006440000000000FF0004070C000E0000030000000002030E001006440000000000FF0002070C000E0000010000000014000202000000000000000000001000000000002000020114001A00000000000800000004000000000000000000000000000000F4000304010B0000D0074E0C00004E0C10270000FF000500FF000001FF00000060CC050070C600001873010070C60000B0CC0000CCF100000ED40000A4000000E8DF0500203005000000000000000000020000000000F00070110100D084000000000000333381017D1A09963014C902600060004788730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF55AA5700F10E00000B0064860100000000000000000058001C000000504349520210407300001800000000035700000003800000474F5020414D44205245563A20782E782E782E782E780078787878007878787800000000B3AC0000A02301002698876FBF7D624A5B78E666660E000701444AA5B25C68A698516B03176CE2731798B82923534B48C262944841CE2952D60E02E7338E6CDB555DABBB5555B6D5BB3B54982AB002802AA88CB14D32ECEDBC1C2A5AA156A33FBFBFFCE6705A6DDEF7DB77DDEF7F6EFBE2F77EEF7C3EFDEFB3DFBDFE09FBBBB592471B6E7BB32BFF5FA115FFFFD3EE4A2B41A963F859F18AC3B48F5F1A53DF9CA2A86514B395C18535F7F8368AFDFCBF385EB8987CBF78B8A8FFFA00E4FFE2EF85C628A978D5757E8C7735C54BAFFFF703E2CFA3AA3C3DE8BE750677BF3FE237AA39E8B174FA0CF9F9F5013106DA2BEFF0E0328AC962EA94C3B18C0B0E5861D5F7FD30F51474B4D4451053116DA2BEFF2C3E43CF529B1FCFDEE3CEFEFEEB15F790FCFDF27CDFEFEEEBD053DF95F9FBA1FF1EE4D5F761E7FF6F67FF8F7EB6E94F7ACFCFD9FFE3DE8B6EAF266E152CF57DEAD5F7ADE77BB857DD2EE55C3ABEE415D3F1DCEF7B4571F0BFEBDFFE35F76AFBB6FCF6F884FC3ED5FA57E3F4A299C987C971FA249BED7C0A65D745A0BE5FD1528309F8B43C3DB2B429E2D0D15BAA4CB611684BAB74C62E8EC3F234969BB5682F8B4572D457AD4582D458AD4592F85711737168AE5A8AF5A8B05A8B15A8B25ED7791737168AE5A8AF5A8B05A8B15A8B25F75BF8B9B8B4572D457AD4582D458AD47FF79BD37BB1737168AE5A8AF5A8B05A8B15A8B25EDB7D1737168AE5A8AF5A8B05A8B15A8B25F8EDEC5CDC5A2B96A2BD6A2C16A2C56A2037AD9BBA5B3774B66EE96CDDD2D9BBA5B36E3DF8A44B54AD15CB515E550AD7B3375176390DFFE54572D457AD4582D458AD4592F76B68B60A956322A2D15CB51296A2BCABC5ACEF16B397E045B37BEF45D3E2D15CB515EB5160B5162B5164BFCA585BB8BF1956DB612D46A961BEA961BEA961BEA961BEA961BEA961BE29C95F9F214BB88B1C6F11638DE22C71BC458E3788B1C6F11638D2BFD01FFF5A3791799CA7EB1C1BF58E0DFAC706FD63837EB1C1BF58E0EF16CDDE2D9BBC5B3778B66EF16CDDE2D9BD65CC5CDC5A2B96A2BD6A2C16A2C56A3CD1965D6A374B1C6DD2C71BE82C6CBE82C6CBCC630D750E8BBFD149AFF3293D7A49361E63CF5DE4A2EB8C1FD183C0AE93A9EAAA702BDC54E7AA702C35B49ADA4C0B0A1A9A6A9C12EEAE5BAB96C12E6D2CD83CBB96772CA68FF1771C28980CFFA593EF7D8ECFCAEFB6BD2E77AFFF389C0AE47E0C9ECBE3D0E9F2360D70BDD27A27FC7E26F653638729EDAE41FD5E37C9F3FB4D95A6EDD789E927C4C5EE7BBFD9A2CA29A3F98AFB3556573EE3BF1AF3396549BDDFFE7DFCB7AF39191F6B7395F4364F627551DF66E28B4741F658712472F59EEA7C3CCFF0D7D1C5D5EC0BFECCAFC5BFA7FF17ED3FC5F95F9DFFD78353DE6E5D4F79AC32B7125FD9A2C661F70C07BB927598A0CF3A3735932BE8D9FEEE0DFDF993C6E7B2485252E80ADC48F372E36F3A4E13A292E8F996FE4FDBF07A7D363F5597ADACBCE076F9CAAD77E5D4FF957CFEAB9ECEFA72D4997F1BA8477FDDE6B9385E0FEDC96B3E1C436CAF8BF6F79C1B87BD776F7B8E90E85EEF7966798EA05C52F3EF3D4EC24F57B2EAFCBBC37F57A7E94D77F57DDEA7C1D1F631BD6F737329FA66CAF32DE92A1B95EC7D8EE168BD177FAEF3D8FD1D6CFAFF2319ED5E1D51F6D839FDB87FAF377CC63F7DA1EF2D753E347CD64FCDD53A939E8CADB5F5719E64BCEFB5CFCF7A361211BD261BCBEEA2677BCEDFDF4E9F31AFF810F566713BA95E8D84D4F6797FAD95D65D76BEF95846F45E6E33A0CE76DE206DFD6A9B7FA7825597F57DD52BEE855F6E15F730AFB9757D94AFBE360556F7D5F76CAFB84AFBF4D5F7E3ABEDEABEE9D5F742AFB9F57DB857DCCABEDA2BEE4D5F652BEF8CAB99FC257DDC2BEED95F7095F7E9ABEFC757DBD57DE895F79B57D9CAFB6CAFB9857DCBABECA57DA7F9B9C8D0AC511D4774565CAEC0A30A76144D12EF2B2654F958C2B3D14BFC95F1BCEAF35CEAF8EE757C7F3ABF56B577654E859F375FEC15DE5515C29CF05894B63FB00B1A057173EB5BD1AB55DFF4FFF90CFFFCFFFFDD3FF1D4CC01B4D0B3CA1598013DA159B0E2BC707BCC80C34A1F73E55487968183A82A90AD2053A856F748562C3A5F161C978E0F3324A3D613C8D3A00C0D3936BC693ECC93E8E1F1E54E060F181E71E5365392F4717A5DA15920E7BA02B3414680A3C37DA80F346568399D1FF961E74AA62BB90DAC42DBFC5F60E7324F78926F3A00DE7FAD11FDF88CE3C1FDC85C9855106A3481DF62008FE9DA6EE69EA29BB9A4A9A3D034348F70A9F9D68F499FA5A4D034779FD1E850CFE868E2DBB9D1E81A533C6993A4A552CB3347534751A40CE4C4D4CF4DF857C6CDF4D7F8F9EA3D052135B9DCCCEB47351514D50AE9F414744854521FDDB4EC2929A973E7D25368E2EFF4400C85876D4B46D3B0A3A8A956E67EA298FA6A2A6A58BA266B279A9FE6EA0EA767BF0AE676D4D507D180F34B51479FD0776D2A4FCF92BE5E98F5A9914BF49DCD1B4A640F8A33E5E99A7739FA7A7A4D1E856AE02D53D368EA541DCCA2A2A3A9A9686D1E8E909A08E9F93A6434717B4483834A2D1071F2B7F7FC064EC7A6A540371C9A14B4BCDAF3B4D5150853800B9840F1E370DCE990A80DAA2E5FB10E2CA3683C0B474421D9B47A4A4A2A3BF1C4407CC88D2AE3F2483C794750D3354D4CD283B9CFABB60DBE7F40D15BBA0A4EF28CAEBF4752853D3D32DC1F17BFE7F3F519FEE68CFA38BD5EEE98331CCE5FEC73F51A30E2469407E7C3AA2FC9062DBFFB6FF16FD413F279FA4A542A28F996E6D1D2D1F36E22DBF5FA3EE3474DA5D1B4CA52F774FA2123F409D1054CE331B358EC7F57D6369B33253A6B9C9E43461CB21DC350194FD03045C95F42852683F42867F32DAABA9C4CCE396F18DAA1FAB50FCBEC50DD4D1CF022D8BA3E3741D52BE31DA068D0694E0F85363CD8E4E46383E87BEFE25FC3977697C34073EBC70725EF9D37238BE444885D6C014D3BEC8E885CA040F74FA8B8C51D05961C2EDDC191C5726244748CEA6163AC258B2F7EF4963C20B1DFFD91221D0707C8E412C6E8E4997D61A244D64F8402A7B91DBFD010144F9B0B5E085A8667DC531C98639CCD5B9C96DD4C4C3963A12ACC73D871C742559697A73EDA38CE59EE370E04319976965684E4B259B391C1EA89A71AD5C0699EA88288C8E982C8E45969C7D00B48C8E70289913C1F1C45B48714FB40D66032B85E5DF1057A0504C90BD1CF66F3602646A80EF4E1707226B56801BF483A741912EF46CB3AD4E391C2FDA385470BF707A89AC3970F1C8EB019FE1FD77F98F9BE0108646FAF49B27BCA6B33E3A34176D4E8B98DA4C88BDB81D6999C8D2B5937619E97EC3B13334755DE3D2072CB6E0EF3399AE21C972CE4AECC81F5BA6FB43E54E6F7079674256099BDBB601C64EE6F13FB03167F68ED291FD2141D4DF5CCD030E83AB6BAD160DF43D0869D5EB72D37B13F12725E192EDDC1AC6A318EDD256E9D873E1C6D39B43D9BA4BE1BBFDA212EC16D97C85C247EEA6001591017F602C450075307239A6AD07A3E64064D808D696EE26B0611700585EADE0E8A3D5B0683E97696DD5E220C6B99AB0392B6893F32186392BA2F571838949D868EB6E8EE6FCD1EC22EB3D7270722350D4A47C60E6BABEED8F1E486EBC31B32EB8C9785D7FA8514F26D7175B56292AABC8339F9D7599434A179D91CE92F74C2EB8D8F00A734CD8CF37F74F2DE399BEDBA83D985B667A83986F1EF78C18D44A3C366FB662E0BD75EC2185DE59BC6265648D6F20CD06464E7D67D01957CA16F910E89C85CB38C2EBB34D5C175CEDAE493EDA6D4E3D261F14ED265F783F713C1D63D50688E25EFF13930CC95189E355C7C9ADD4C3CFE1C161CC5EA5D0F36B9980E53D080DAED2DD93959A13A130BED7BC3CBBF0BB2CDF8DDA385F4BDE1CAD9BB83E5357A4EC8CE3474977130E92F90CCEE7BB52131A5B4391CD81303897EBC4980CEBCCEC0CEC5435775316AE2C07B30E467E11C97D2E66AF5DC170D0D469D9BB469C4B3B0D743AFDDBB83D4EE3EA1EDEDD3A4B7D17B86D0E4B92ED2E169F04742958BD68DF845D6D2B21EF6D590104EEF9EE713EA18B74DEFB4DCF86B765EF2833BB26AA1ADA8319DEE2C4EF870D24CF707A35DCDE3ECC20531F98392C2FA9BF104F624D7CD2B60311603522EB3E61C9F5BDF975BC41203AFF1C23AC190819530C66F410E4E92BE4FC007770C4B769E50192FBBDA024735E385AF1492A7D2EF09D0002B9F2D086D87278AB535FE31D30DD85AE97E974DF82874C01C46FFB0711B1438A40D44EB5600EF5E90E46A599C956357E52A046E4D7FECA64E739D93B59D9718FAD6B3A0A59625277005AA291EE4A7E9758A0A90704086D10C6DFAC8B9E4FB50E15BBC03113BE7DD090CE3DE00A93892C24A5688362736A7E3F582501F297ABF5811ED3572381E9A496D0E4A316A458E9DAA0C206DE7F52913529B7D2A1E50E8BFB722BAC20647521D4A6CDFB326387905372E3F5609D2DC175C90DA27EAF431796653B60E13AA5EC2A591895A43909AB74FBD095D98988589E8F9E3B4975D606A3EC8D145F092E18DED0BAD18DC15EC0825F56389F24419721D071A9F5B8521FC5D18404CD47C9D683F1C9BA915854C5894182395F915F366365A5C0094B6C1F895DA57A6B6F664828E93B72EBB287D6BE1CF9E701B3A7B1C210B6F4CDC35FD529D69E36B0501F5D983D37DD61398CF961CA905C8D205E9DEE3C07A6639F3433E5EB9F0EB8E98720EABB522A21BF1AA3C510A66FD91C71EED365A550980868BA7949AB94D29028A8395629FC63A56452F089ABE902D12489C2588DC18DF708350D089D37D01A8938EA1E066AE47A51D933D189D2E3C9D2FC911427CD81E484B861E2AF0BEE0B0AF184469EA2847A3811E318F1270C61B00E94F4D79ED5E396FBF3F0D5E251E9E7A849C087961D6CBEA235E1A8CFB435FE6DB407C546A9C02CCBD75B269F62B7386C83AA0ED9C53B93362C8A200C40AA3628ECDB9DD25C464A15934312DC27FCC098D42A7AB8F5B56783AB257DFD4A1D3DA4A90C874F831A90C393540E7CD2606F8D6C440BA120741CD35A70271C4CD072410B6C096CFC13721701F1E3BC4E2992136ED58A62AF5F095FAF4058BFC36F46EE4627CC45E7726F08BCEE8FE82318CA31865EBA47E2F944CF2D0C2E7B74FE46E02A1ADB1F850883C8519C950508308CD02A27E5E2C9CA6ED2BAD34D859E806CFA5C62D660B9465ADB912A2CB330DABFCD4DAB53F3ABB51C44FEDD17AE6567BC13D8E09859B6AFD96B888B4B5392CEB5AA16158CCF19DA99DA0A7EFB4B3E6B0BE7227B597227F413F2D26B813C95DBA4B8C725C576970CE9BC2E87782B4EE090BB723950A800227870E323A6E999975BB521617D484D0F4FEED3E191239EF3A4B708F963C8C9D81110BBB4F41A48B709D7864AEFC62775700335A4AACB246FC41A26A8525284BA9A40F6A29A123E5891043CA9D07C013A081BD6DE590E7A58E9B5C7CADF591D5762268F39E30DAD47143BCCE6FB73FA005FD9FC8B8E8F54A210D4A63A43FECBBA7512CDDB7E0D43F540FC28EBD1D7EC2F1C952833AA91ED67CE128BCE8B44FB4684E3AB3538DC5646D0E7DDE34016BE0392E51EE1EEBD324C119706A35A3B4B51C2179BA6ADCC83D72E2319D54725960401B2BBB811DB282BC0F4AF057816EAA881F627ECDD957FEDEE46F47D1E2A53F6EE078E89DF5E77149DF495E730996D196DC99953607F7FB063F9BB00303D077628DECB66CEADB73E38315DA062A24F80D2CA809B0EDC6A3EC4D1A9A6E74197101DB3DFEE4560CD5FCC0D4101133B9BF5264799AB2B80084B503CE537A8AC258FA24EE780418D265C50D6CD47D4AC202060346998660147950C5B3757056BBB1BBD54C92AF8040EA0E7A601B37EAE1907BCF4316E7295ACC3B0E8968A7013B47D79953D0E3CC82E4D022C703A0C4B635FF4C744B174DF6BA5FA434F982313DB93E5047FDD907F0CACC11A8DF2C4978C81F61ADBD7124A2F5394126E9DEE8C9CDA975BB7230D3DC499759B151B83E88813C7CF035691447F778B1447768F712E18D38FE94313F66E87211EEE093A569B8BCCEBB005B4CC431871ADBB8D31ECC515FD01153CCAC3743AF4EC98660E83DC0353F239353BEF3DC5547F1E9068B68C5EAF50A1024C08BC3DBDDF6E9517BB806787141EA60D47B92A1F6A0271FD908947D010229A2EBA74F9B2193902EC9FE017585DFFDC2E951CC5693308103AA1057AB8BEB43AAECC4E41C4E571391B515F7C2D0F6744D3A95AE6C4D6284888F21A828D41812EE8A5CE1695D19F93FC1A899ABD7497267A0EB47A6DCC07B244239E538F6D71B03E53672D349D39A978043E2D710FFDD41CB9E5D72E32B6C4F6065F6D1540D9CFB8AB904DD25C13607CE1942F52D45D1B0023441DBCE02C2B3EC12019BA9932EB6908417400E75EE9C3FA9A74F2D6E2CC7CD0B324180984317AF097BEAB17A5DA8A3F017E75E510ABAE0E896EE1FE34E8964737DD0137A33A043541305D7658F0735D39FC58EB552D118CADB043041CD5C0DC29D644378A2981EF7B6DC2BDEEABD3523984C9DEDA21F42E941E3DE829F29ABD388A1ED3B3B49DA75C015F757FD1E7CA386D53DD1F1E3D2BD3B05143C0024D938A9030978DC36DECC40083A51EE8F7BF98A0B6D22BF06AA950EADB0EEE426AF62EC30E301AB3381C0A6FC12F57EC109C184F259821805A81843323578A3DDD7DB713BA9D97177FFF9898C0A5F4032D3E9C34D5E4D36A439ECFD38F3B9FA510F079C1428943F410169BA938FC68697EC6DC427C1CD7F32146004CB047F9840030E990E6150286B7D1077B05CD39F1AE207CE8D70DC197DB554ABCD9C50FDB509FDE2BD1AE22035EFDCB8BD491EAC9BAE1412975BD9079489A9985EBBE12103C4DBA3AA14691D45BD3A0CAF883C089B5058C3C7D66BC5FA6475439AB42979C92945C2E60AD27963F22F788E6D7B881C135B7EC22B5E8E7A0F6A7B96D45F79E703C40C150FF20AA2F0C4A77C72F5DBD44DF0589939F09F828A8E883839202214FAEF6C4C0E83E156D93302BDF5981CA3AFC0E52A3CB06AEA6157D67449E86D0741CC0254B402857225F1DA40FC4329BDB0F683B17F2A47DBFE44289E093D11332A74103F53A600788BBEFF620CE3DB89066A9B28157ABFCA2907866F4F1C6A3FB09C9F02F0504D422821AA71036A282EA7FC18B9BF5459ED64D45C224CBC5B7241DE7704C993928D0D77A9FE5CC4590368410145BF274D81219ECEB6467665FCEE993851F155C81B6B61649D45767357BF5EFC922B52F7C129EFABC5BE9290709EB8999E4813C5562C1B3D7CA3811E128E04658F4FBCC51455658203B7A7998FE6BD68756C413F67DAC51DE26C913370C0E94104E35E74399A74609876FC420846222812F6ED945CEAC5DF1C25DB693BDD150D8DA4EE9977E0BAB3607903DC0E71B726A56EEE0EA08937ACE01E625BCABFE220256DC9ED00AE4EA80F16312DDF708B07DE254C4AC6C5366D4B3271C54C362E5B9D547E04CBEB2755760246AE6737B516B356166E92B01806EE66AE5CC0DB1ADBC12157E39DC1ABB621875738C756D91F1CE916665A38C62E87809E464DCBF9FC6197D62AE906CE22427EDEFD43A3B8A08B01D87B2C143CCB6D6A24F1C3392CAB39E0299042BFD2EE0E49A0708D57C9122092A290249D8A410509E0C41115F9855166BE75A11548802F7B260436FC89FC472F430D89C8E4E846D1DC1FD2A33363099A6AE41999267FE217E542F879D21140E173983DD81D75B5A6A459D75C625EF45C4FB218935B7EF901394C04D585DF9EAE64E471FD429BE97595A47E0756D7D3536916B46DA26B1E9190AF2896A30413584832B3B8635FEC54A6C2764AD353F0851606A3FBF9240EB53C6212E80768E927C0433A6AC1E2358D7C10B57F58D7C20F5067E301D83F59AFEA143AF4F402F86F944D38D47B5D12722117D2BE385995B84E8C27CB27A6C4866753B61820C2C6B22487D585F238408F29BEA7C20F47F76009B3878E0E7337E515095B3C7DCACCA1CFBC3018579274C2D5D30F78BAE66F1BC71F7810C5BA73E583CCC1F38EA098BDE24CC70C859CF25B99E0C76242280F7E1D713C96D473112C071487D61AD5205A8C45AED01D5574FACE4E7A6F1486A947A0EFBAEFC9E83DA84003475326476836A29C9DD279160B72CEE93CD11E78DA9FDB9B37FBE10BDB99F2F5FE90D0E8AA648E83FA468FB1189E5C0E2EBC6698A7E575C286CDC990823450748DC17AEDE043F53732C4F98366FD6F149A160CBAEAC251BEB178622176F7951951BF033278E513724C4DACD9C991ADF72A17CEECD4766480D076107ABF7E7722EBA0B77DC3393A5FB860D204185DD042404EC82A876D8A3B4197B9843A8F71661301C8C4FDCD9909005A9DB63A26EE2B575F7A8C254D5C83D58F48FABA8C2999AD5C9FDD891AFD84982C4C5CCBFDD7A46099394C028CD6E27FD514375D2138BD466D3D78C1E0361AF5C4C26E93C03353932983930900A5E2A359FDA40D4C78C03181E2C713D7EB9227AFD3224F5A9900F503C58D1F3FA59C68ED5B39727AFD72C1E9F845DB35FE69ACC1AFC1BB64FB9EC8901EACCBAEF7BF84627EF015B27F4B92480FF1ACC91D7A7FE20E290838C28FFB317FF4D47F5C9914E4457725234D6641842FFC4B32661E0D816EF7204268C8F5CA68BCFFC42A685323837366AC8210CB06237C120D31A3864B2E0860F0DAF982435D963D4E1AE946D5DCDFAC4B543009F9A30AFC13A4116AC638C9317D7B650E68BAE3B46730B67496D4D6DD31F1A744B035B750CD0E406D6B97013FBB01FA1C817B303B95C310BE25819009B25E01E61A8F4C280B145409EC7F9287B1E4A87B169A914332EB4AC25FAE21F3F903BD64B3007A2A5AC4B63AC7852A082951A82C982C7197B3620FB0D0FDA0414B480E056F4F82D1D47FFC2430849F3748E719BA07075D2352ABBA757782BC3B4505F6066C457820EF1C165B6F8E244B435AE1D8078C42E15EA4C181C9354008E81AB4788923F332F694C2E3580E01B4228196D0AD926037E1265997A0A5FCE92FCE84113586FF324BF9F0BFF0D4BFA06237F9B0A3DB0EDF44C83C540D1A98C845331E2734182482C900C739834AD79638ED11AFE95ACD0828D86FE9C2FE8FE3130BE38DED501DAFAA744162E1976A3B2D635174B9887B7C3CB2E917D3EA5ECF85ECD5BBC0E682264917D4F1098E183FAC42567BD0C1E40306E1FA89721F7E113133BAC0FBE605F753F19257CEB42962C94BD5A1884B1B00B1980B132D275FC8078F1E443C7A7241E216082FAE0285B4A98FFB8BA0E95E127392A3AEFEF235275DC9782A57E788C9F7EB1E5804393C47BDFB93D8CB129A2C13DD6045B5EDA9F186C03A421B03606E5C0238D2DA3C6F6A7E0EFAC411740450C5E246B1681A6209C3C99A166E810D2C2DE01BB8C3BF9DFB43D621FCE84A5437700E096581C339378DF7C7F3F3CC2C32A91BB4983B1562F119474C372F12950500EF90E3BC47A62F5D96FB4BD74EF2CD7FDC6B1F70CB896D693BE0B0B1E1B306164087A8BF547DB6B585583346B9EA396F0C4129CB13F08B01F02B18F9846A5F6A87CB0F0809891DDCE6009D7F0FDD159427DFFA841801BD6B64FA5C10263F523C22AB766F12270C56FCE4977FE53568BB9B23A2A66464767320DBF3A061AAF3182FD01E644DD84B4A4AF9CA2129E77E7F6AF12ECD7C2FBA20B789F6B318D3BC186C1E30BA3A0D4310571707493867B8C4929DBA408FCE310A9F5E921F49F3A080E3CD4686423F94188F8EA2509A2845EF0CE8E674BB8474E56B577F57C41A5FB5CD8DB087F1FE1300C426702C590C26D12DFC78253FAC1986F8E04134D7CC06398E5CF0313D5A7D2E585633C00E7ACEB5C60A5B26A0F5F18389991BFC6862665826BF2C44BF675AE39E1ADC1A3DD24704A7B6B32084887200ACDB3B1E160814AFC605FEF62D3A918AB2EC081BA639BFC47B53606AB8241E2DB5EBC8C606D8E24BEF06671A3C5E3357F332FCC17026D7679494D728EAFE6E256DCA0C8177D0E65ECE77E84A3DEF17443F8C34A3094B08F6717929303E34BAEC92F3985C43E18B36204F62D40926FD8373FE6C56E7C260191B53085B009A36559B25216C3EF3C8DD98F2DE72FE5778C06B6849A9E32BA20B800B79535C01961019A75B25146FEF8C91855472DC2052718BD58C3164B280D2078048D4D075449B188AB2020209602F94516E3335B36B4CD0A1167EA4E2E8692B39E736757AC9989BF2C74119B7F667977A4D557029166F3D307B0145F370D68B343DFD5A6CC0630452430A0EDF0E554810D0B5C402358B6B8A6A5A49880C4341F006DDFB18F3A2599CDC971525930D0F84315A3D7E6C19DD11C0FAD0BAE249842B288EA65DD2340050957783A5C2BA1818E972ABF59BEEA3400DC5550948676169CD51335DAC28E7612CF7B27AA56EF9E04E09D30D1D18C4FFD8091971832BA21B7A59E833B09D41CB5C4D5C811FE6F43D757CB815050FA41E33FDA0A802E05401FC83C683E50F147F607879EF878D0A21E29FF6878EE8545151B5150F5E0783F001E10B90F1A4C8078D2E5812A89FED0F1779B0F1C5DA87887781E2F3001E3E6B90F1F3E403C7D19657BB2B6C0B7F1C45A4D628DD425D8B38ADE5033A83DB954301FC55827741C039F7A049E4C099652797BEF924CE5161C2AF37D66691658354E5884E7D42131DABCB26C59A18CDEEC7AE238BAD7C528FCB509D379566806D8A6B0EDBD9A1DC1CFB624024993701C9FFE5AF1DEBC0F6859A8C0050166C626B2840400847ED8822C254455016484162024144E5859581A2415B08D60CC5EDF63AD5D0D7E36C052B2A39599C9304AA82577E450F4DF5E4C42288DC4F00E4B78F1162D45B312ABC57B23DE2BE12E0BD2222BA11AEC613D231CEEDAC90D68C84BD8295A5C6B33230624C6E186BC7426017C0D720D49084C5829AA49ACC0260613256CE56138294A32C44321B04E623579F7339667F5008E9C099036E2DDE1B372B587E02FAC5EF2B0151F405804F78AC5E8C718DF6E8337302CC166C8F3E73EB262E9F5DAE42C80C2A63FAC0732EBB9535735FD671C20B77D39619B2A9E724061C743EADE56F7ACCF98856C13531E56CEB33F0A2DB0756133B3D362831F4D99F225D750334B6DC8DE275F9623FA69F4720A4FDA6F688592879910D56688B10539161AE76F91043BDD55FC83344DE04CE2669E748AF9BA9AB7878E795B9E667E284F1DF61839E3A01D0764A682C6A3057AE18AF1DD3B15374372CA498BF59581821BA7B9CC820630106EC497144AFA80753AA07544D0015F1E43980556F00FE881638BCF95525AF5905E58A719E9AE3D83EF93EF78959C3C00648F8FBF4C05FA5FC0C8E9C"

#amfi_detect.py:
"""
amfi_detect.py: Determine AppleMobileFileIntegrity's OS configuration
"""

import enum

from ..support import utilities
from ..datasets import amfi_data


class AmfiConfigDetectLevel(enum.IntEnum):
    """
    Configuration levels used by AmfiConfigurationDetection
    """

    NO_CHECK:                   int = 0
    LIBRARY_VALIDATION:         int = 1  # For Ventura, use LIBRARY_VALIDATION_AND_SIG
    LIBRARY_VALIDATION_AND_SIG: int = 2
    ALLOW_ALL:                  int = 3


class AmfiConfigurationDetection:
    """
    Detect AppleMobileFileIntegrity's OS configuration

    Usage:

    >>> import amfi_detect
    >>> can_patch = amfi_detect.AmfiConfigurationDetection().check_config(amfi_detect.AmfiConfigDetectLevel.ALLOW_ALL)

    """

    def __init__(self) -> None:
        self.AMFI_ALLOW_TASK_FOR_PID:      bool = False
        self.AMFI_ALLOW_INVALID_SIGNATURE: bool = False
        self.AMFI_LV_ENFORCE_THIRD_PARTY:  bool = False
        self.AMFI_ALLOW_EVERYTHING:        bool = False
        self.SKIP_LIBRARY_VALIDATION:      bool = False

        self.boot_args: list = []
        self.oclp_args: list = []

        self._init_nvram_dicts()

        self._parse_amfi_bitmask()
        self._parse_amfi_boot_args()
        self._parse_oclp_configuration()


    def _init_nvram_dicts(self) -> None:
        """
        Initialize the boot-args and OCLP-Settings NVRAM dictionaries
        """

        boot_args = utilities.get_nvram("boot-args", decode=True)
        oclp_args = utilities.get_nvram("OCLP-Settings", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)

        if boot_args:
            self.boot_args = boot_args.split(" ")

        if oclp_args:
            self.oclp_args = oclp_args.split(" ")


    def _parse_amfi_bitmask(self) -> None:
        """
        Parse the AMFI bitmask from boot-args
        See data/amfi_data.py for more information
        """

        amfi_value = 0
        for arg in self.boot_args:
            if not arg.startswith("amfi="):
                continue
            try:
                amfi_value = arg.split("=")
                if len(amfi_value) != 2:
                    return
                amfi_value = amfi_value[1]
                if amfi_value.startswith("0x"):
                    amfi_value = int(amfi_value, 16)
                else:
                    amfi_value = int(amfi_value)
            except:
                return
            break

        if amfi_value == 0:
            return

        self.AMFI_ALLOW_TASK_FOR_PID:      bool = amfi_value & amfi_data.AppleMobileFileIntegrity.AMFI_ALLOW_TASK_FOR_PID
        self.AMFI_ALLOW_INVALID_SIGNATURE: bool = amfi_value & amfi_data.AppleMobileFileIntegrity.AMFI_ALLOW_INVALID_SIGNATURE
        self.AMFI_LV_ENFORCE_THIRD_PARTY:  bool = amfi_value & amfi_data.AppleMobileFileIntegrity.AMFI_LV_ENFORCE_THIRD_PARTY

        if amfi_value & amfi_data.AppleMobileFileIntegrity.AMFI_ALLOW_EVERYTHING:
            self.AMFI_ALLOW_EVERYTHING        = True
            self.SKIP_LIBRARY_VALIDATION      = True
            self.AMFI_ALLOW_INVALID_SIGNATURE = True


    def _parse_amfi_boot_args(self) -> None:
        """
        Parse the AMFI boot-args
        """

        for arg in self.boot_args:
            if arg.startswith("amfi_unrestrict_task_for_pid"):
                value = arg.split("=")
                if len(value) == 2:
                    if value[1] in ["0x1", "1"]:
                        self.AMFI_ALLOW_TASK_FOR_PID = True
            elif arg.startswith("amfi_allow_any_signature"):
                value = arg.split("=")
                if len(value) == 2:
                    if value[1] in ["0x1", "1"]:
                        self.AMFI_ALLOW_INVALID_SIGNATURE = True
            elif arg.startswith("amfi_get_out_of_my_way"):
                value = arg.split("=")
                if len(value) == 2:
                    if value[1] in ["0x1", "1"]:
                        self.AMFI_ALLOW_EVERYTHING = True
                        self.SKIP_LIBRARY_VALIDATION = True
                        self.AMFI_ALLOW_INVALID_SIGNATURE = True


    def _parse_oclp_configuration(self) -> None:
        """
        Parse the OCLP configuration
        """

        if "-allow_amfi" in self.oclp_args:
            self.SKIP_LIBRARY_VALIDATION = True


    def check_config(self, level: int) -> bool:
        """
        Check the AMFI configuration based on provided AMFI level
        See AmfiConfigLevel enum for valid levels

        Parameters:
            level (int): The level of AMFI checks to check for

        Returns:
            bool: True if the AMFI configuration matches the level, False otherwise
        """

        if level == AmfiConfigDetectLevel.NO_CHECK:
            return True
        if level == AmfiConfigDetectLevel.LIBRARY_VALIDATION:
            return self.SKIP_LIBRARY_VALIDATION
        if level == AmfiConfigDetectLevel.LIBRARY_VALIDATION_AND_SIG:
            return bool(self.SKIP_LIBRARY_VALIDATION and self.AMFI_ALLOW_INVALID_SIGNATURE)
        if level == AmfiConfigDetectLevel.ALLOW_ALL:
            return self.AMFI_ALLOW_EVERYTHING

        return False


#device_probe.py:
"""
device_probe.py: Hardware probing
"""

import enum
import itertools
import subprocess
import plistlib
import hashlib

from pathlib import Path
from dataclasses import dataclass, field
from typing import Any, ClassVar, Optional, Type, Union

from . import ioreg

from ..support import utilities

from ..datasets import (
    pci_data,
    usb_data
)


def class_code_to_bytes(class_code: int) -> bytes:
    return class_code.to_bytes(4, byteorder="little")


@dataclass
class CPU:
    name: str
    flags: list[str]
    leafs: list[str]


@dataclass
class USBDevice:
    vendor_id:     int
    device_id:     int
    device_class:  int
    device_speed:  int
    product_name:  str
    vendor_name:   Optional[str] = None
    serial_number: Optional[str] = None

    @classmethod
    def from_ioregistry(cls, entry: ioreg.io_registry_entry_t):
        properties: dict = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperties(entry, None, ioreg.kCFAllocatorDefault, ioreg.kNilOptions)[1])

        vendor_id     = None
        device_id     = None
        device_class  = None
        device_speed  = None
        vendor_name   = None
        serial_number = None
        product_name = "N/A"

        if "idVendor" in properties:
            vendor_id = properties["idVendor"]
        if "idProduct" in properties:
            device_id = properties["idProduct"]
        if "bDeviceClass" in properties:
            device_class = properties["bDeviceClass"]
        if "kUSBProductString" in properties:
            product_name = properties["kUSBProductString"].strip()
        if "kUSBVendorString" in properties:
            vendor_name = properties["kUSBVendorString"].strip()
        if "USBSpeed" in properties:
            device_speed = properties["USBSpeed"]
        if "kUSBSerialNumberString" in properties:
            serial_number = properties["kUSBSerialNumberString"].strip()

        return cls(vendor_id, device_id, device_class, device_speed, product_name, vendor_name, serial_number)


    def detect(self):
        self.detect_class()
        self.detect_speed()


    def detect_class(self) -> None:
        for device_class in self.ClassCode:
            if self.device_class == device_class.value:
                self.device_class = device_class


    def detect_speed(self) -> None:
        for speed in self.Speed:
            if self.device_speed == speed.value:
                self.device_speed = speed

    class Speed(enum.Enum):
        LOW_SPEED        = 0x01
        FULL_SPEED       = 0x02
        HIGH_SPEED       = 0x03
        SUPER_SPEED      = 0x04
        SUPER_SPEED_PLUS = 0x05


    class ClassCode(enum.Enum):
        # https://www.usb.org/defined-class-codes
        GENERIC           = 0x00
        AUDIO             = 0x01
        CDC_CONTROL       = 0x02
        HID               = 0x03
        PHYSICAL          = 0x05
        IMAGE             = 0x06
        PRINTER           = 0x07
        MASS_STORAGE      = 0x08
        HUB               = 0x09
        CDC_DATA          = 0x0A
        SMART_CARD        = 0x0B
        CONTENT_SEC       = 0x0D
        VIDEO             = 0x0E
        PERSONAL_HEALTH   = 0x0F
        AUDIO_VIDEO       = 0x10
        BILLBOARD         = 0x11
        USB_TYPE_C_BRIDGE = 0x12
        DISPLAY_BDP       = 0x13
        I3C               = 0x3C
        DIAGNOSTIC        = 0xDC
        WIRELESS          = 0xE0
        MISCELLANEOUS     = 0xEF
        APPLICATION       = 0xFE
        VENDOR_SPEC       = 0xFF


@dataclass
class PCIDevice:
    VENDOR_ID: ClassVar[int]  # Default vendor id, for subclasses.
    CLASS_CODES: ClassVar[list[int]]  # Default class codes, for subclasses.

    vendor_id:  int  # The vendor ID of this PCI device
    device_id:  int  # The device ID of this PCI device
    class_code: int  # The class code of this PCI device - https://pci-ids.ucw.cz/read/PD

    name:                Optional[str]  = None  # Name of IORegistryEntry
    model:               Optional[str]  = None  # model property
    acpi_path:           Optional[str]  = None  # ACPI Device Path
    pci_path:            Optional[str]  = None  # PCI Device Path
    disable_metal:       Optional[bool] = False # 'disable-metal' property
    force_compatible:    Optional[bool] = False # 'force-compat' property
    vendor_id_unspoofed: Optional[int]  = -1    # Unspoofed vendor ID of this PCI device
    device_id_unspoofed: Optional[int]  = -1    # Unspoofed device ID of this PCI device

    @classmethod
    def class_code_matching_dict(cls) -> dict:
        return {
            "IOProviderClass": "IOPCIDevice",
            "IOPropertyMatch": [{"class-code": class_code_to_bytes(class_code)} for class_code in cls.CLASS_CODES]
        }

    @classmethod
    def from_ioregistry(cls, entry: ioreg.io_registry_entry_t, anti_spoof=False):
        properties: dict = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperties(entry, None, ioreg.kCFAllocatorDefault, ioreg.kNilOptions)[1])  # type: ignore

        vendor_id = None
        device_id = None
        vendor_id_unspoofed = None
        device_id_unspoofed = None

        if "IOName" in properties:
            ioname = properties["IOName"]
            if type(ioname) is bytes:
                ioname = ioname.strip(b"\0").decode()

            if ioname.startswith("pci") and "," in ioname:
                vendor_id_unspoofed, device_id_unspoofed = (int(i, 16) for i in ioname[3:].split(","))
                if anti_spoof:
                    vendor_id = vendor_id_unspoofed
                    device_id = device_id_unspoofed

        if vendor_id is None and device_id is None:
            vendor_id, device_id = [int.from_bytes(properties[i][:4], byteorder="little") for i in ["vendor-id", "device-id"]]

        if vendor_id_unspoofed is None and device_id_unspoofed is None:
            vendor_id_unspoofed = vendor_id
            device_id_unspoofed = device_id

        device = cls(vendor_id, device_id, int.from_bytes(properties["class-code"][:6], byteorder="little"), name=ioreg.io_name_t_to_str(ioreg.IORegistryEntryGetName(entry, None)[1]))
        if "model" in properties:
            model = properties["model"]
            if isinstance(model, bytes):
                model = model.strip(b"\0").decode()
            device.model = model
        if "acpi-path" in properties:
            device.acpi_path = properties["acpi-path"]
        if "disable-metal" in properties:
            device.disable_metal = True
        if "force-compat" in properties:
            device.force_compatible = True

        device.vendor_id_unspoofed = vendor_id_unspoofed
        device.device_id_unspoofed = device_id_unspoofed
        device.populate_pci_path(entry)
        return device

    def vendor_detect(self, *, inherits: Optional[Type["PCIDevice"]] = None, classes: Optional[list] = None):
        for i in classes or itertools.chain.from_iterable([subclass.__subclasses__() for subclass in PCIDevice.__subclasses__()]):
            if issubclass(i, inherits or object) and i.detect(self):
                return i
        return None

    @classmethod
    def detect(cls, device):
        return device.vendor_id == cls.VENDOR_ID and ((device.class_code in cls.CLASS_CODES) if getattr(cls, "CLASS_CODES", None) else True) and ((device.class_code == cls.CLASS_CODE) if getattr(cls, "CLASS_CODE", None) else True)  # type: ignore  # pylint: disable=no-member

    def populate_pci_path(self, original_entry: ioreg.io_registry_entry_t):
        # Based off gfxutil logic, seems to work.
        paths = []
        entry = original_entry
        while entry:
            if ioreg.IOObjectConformsTo(entry, "IOPCIDevice".encode()):
                # Virtual PCI devices provide a botched IOService path (us.electronic.kext.vusb)
                # We only care about physical devices, so skip them
                try:
                    location = [hex(int(i, 16)) for i in ioreg.io_name_t_to_str(ioreg.IORegistryEntryGetLocationInPlane(entry, "IOService".encode(), None)[1]).split(",") + ["0"]]
                    paths.append(f"Pci({location[0]},{location[1]})")
                except ValueError:
                    break
            elif ioreg.IOObjectConformsTo(entry, "IOACPIPlatformDevice".encode()):
                paths.append(f"PciRoot({hex(int(ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(entry, '_UID', ioreg.kCFAllocatorDefault, ioreg.kNilOptions)) or 0))})")  # type: ignore
                break
            elif ioreg.IOObjectConformsTo(entry, "IOPCIBridge".encode()):
                pass
            else:
                # There's something in between that's not PCI! Abort
                paths = []
                break
            parent = ioreg.IORegistryEntryGetParentEntry(entry, "IOService".encode(), None)[1]
            if entry != original_entry:
                ioreg.IOObjectRelease(entry)
            entry = parent
        self.pci_path = "/".join(reversed(paths))


@dataclass
class GPU(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x030000, 0x038000]
    arch: enum.Enum = field(init=False)  # The architecture, see subclasses.

    def __post_init__(self):
        self.detect_arch()

    def detect_arch(self):
        raise NotImplementedError


@dataclass
class WirelessCard(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x028000]
    country_code: str = field(init=False)
    chipset: enum.Enum = field(init=False)

    def __post_init__(self):
        self.detect_chipset()

    @classmethod
    def from_ioregistry(cls, entry: ioreg.io_registry_entry_t, anti_spoof=True):
        device = super().from_ioregistry(entry, anti_spoof=anti_spoof)

        matching_dict = {
            "IOParentMatch": ioreg.corefoundation_to_native(ioreg.IORegistryEntryIDMatching(ioreg.IORegistryEntryGetRegistryEntryID(entry, None)[1])),
            "IOProviderClass": "IO80211Interface",
        }

        interface = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, matching_dict, None)[1]), None)
        if interface:
            device.country_code = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(interface, "IO80211CountryCode", ioreg.kCFAllocatorDefault, ioreg.kNilOptions))  # type: ignore # If not present, will be None anyways
        else:
            device.country_code = None  # type: ignore

        return device

    def detect_chipset(self):
        raise NotImplementedError


@dataclass
class NVMeController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [
        0x010802,
        # I don't know if this is a typo or what, but Apple controllers are 01:80:02, not 01:08:02
        0x018002
    ]

    aspm: Optional[int] = None
    # parent_aspm: Optional[int] = None

    @classmethod
    def from_ioregistry(cls, entry: ioreg.io_registry_entry_t, anti_spoof=True):
        device = super().from_ioregistry(entry, anti_spoof=anti_spoof)

        device.aspm: Union[int, bytes] = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(entry, "pci-aspm-default", ioreg.kCFAllocatorDefault, ioreg.kNilOptions)) or 0  # type: ignore
        if isinstance(device.aspm, bytes):
            device.aspm = int.from_bytes(device.aspm, byteorder="little")

        return device


@dataclass
class EthernetController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x020000]

    chipset: enum.Enum = field(init=False)

    def __post_init__(self):
        self.detect_chipset()

    def detect_chipset(self):
        raise NotImplementedError

@dataclass
class SATAController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x010601]

@dataclass
class SASController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x010400]

@dataclass
class XHCIController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x0c0330]

@dataclass
class EHCIController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x0c0320]

@dataclass
class OHCIController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x0c0310]

@dataclass
class UHCIController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x0c0300]

@dataclass
class SDXCController(PCIDevice):
    CLASS_CODES: ClassVar[list[int]] = [0x080501]

@dataclass
class NVIDIA(GPU):
    VENDOR_ID: ClassVar[int] = 0x10DE

    class Archs(enum.Enum):
        # pylint: disable=invalid-name
        Curie = "Curie"
        Fermi = "Fermi"
        Tesla = "Tesla"
        Kepler = "Kepler"
        Maxwell = "Maxwell"
        Pascal = "Pascal"
        Unknown = "Unknown"

    arch: Archs = field(init=False)

    def detect_arch(self):
        # G80/G80GL
        if self.device_id in pci_data.nvidia_ids.curie_ids:
            self.arch = NVIDIA.Archs.Curie
        elif self.device_id in pci_data.nvidia_ids.tesla_ids:
            self.arch = NVIDIA.Archs.Tesla
        elif self.device_id in pci_data.nvidia_ids.fermi_ids:
            self.arch = NVIDIA.Archs.Fermi
        elif self.device_id in pci_data.nvidia_ids.kepler_ids:
            self.arch = NVIDIA.Archs.Kepler
        elif self.device_id in pci_data.nvidia_ids.maxwell_ids:
            self.arch = NVIDIA.Archs.Maxwell
        elif self.device_id in pci_data.nvidia_ids.pascal_ids:
            self.arch = NVIDIA.Archs.Pascal
        else:
            self.arch = NVIDIA.Archs.Unknown

@dataclass
class NVIDIAEthernet(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x10DE

    class Chipsets(enum.Enum):
        nForceEthernet = "nForceEthernet"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        # nForce driver matches against Vendor ID, thus making all nForce chipsets supported
        self.chipset = NVIDIAEthernet.Chipsets.nForceEthernet

@dataclass
class AMD(GPU):
    VENDOR_ID: ClassVar[int] = 0x1002

    class Archs(enum.Enum):
        # pylint: disable=invalid-name
        R500 = "R500"
        TeraScale_1 = "TeraScale 1"
        TeraScale_2 = "TeraScale 2"
        Legacy_GCN_7000 = "Legacy GCN v1"
        Legacy_GCN_8000 = "Legacy GCN v2"
        Legacy_GCN_9000 = "Legacy GCN v3"
        Polaris = "Polaris"
        Polaris_Spoof = "Polaris (Spoofed)"
        Vega = "Vega"
        Navi = "Navi"
        Unknown = "Unknown"

    arch: Archs = field(init=False)

    def detect_arch(self):
        if self.device_id in pci_data.amd_ids.r500_ids:
            self.arch = AMD.Archs.R500
        elif self.device_id in pci_data.amd_ids.gcn_7000_ids:
            self.arch = AMD.Archs.Legacy_GCN_7000
        elif self.device_id in pci_data.amd_ids.gcn_8000_ids:
            self.arch = AMD.Archs.Legacy_GCN_8000
        elif self.device_id in pci_data.amd_ids.gcn_9000_ids:
            self.arch = AMD.Archs.Legacy_GCN_9000
        elif self.device_id in pci_data.amd_ids.terascale_1_ids:
            self.arch = AMD.Archs.TeraScale_1
        elif self.device_id in pci_data.amd_ids.terascale_2_ids:
            self.arch = AMD.Archs.TeraScale_2
        elif self.device_id in pci_data.amd_ids.polaris_ids:
            self.arch = AMD.Archs.Polaris
        elif self.device_id in pci_data.amd_ids.polaris_spoof_ids:
            self.arch = AMD.Archs.Polaris_Spoof
        elif self.device_id in pci_data.amd_ids.vega_ids:
            self.arch = AMD.Archs.Vega
        elif self.device_id in pci_data.amd_ids.navi_ids:
            self.arch = AMD.Archs.Navi
        else:
            self.arch = AMD.Archs.Unknown


@dataclass
class Intel(GPU):
    VENDOR_ID: ClassVar[int] = 0x8086

    class Archs(enum.Enum):
        # pylint: disable=invalid-name
        GMA_950 = "GMA 950"
        GMA_X3100 = "GMA X3100"
        Iron_Lake = "Iron Lake"
        Sandy_Bridge = "Sandy Bridge"
        Ivy_Bridge = "Ivy Bridge"
        Haswell = "Haswell"
        Broadwell = "Broadwell"
        Skylake = "Skylake"
        Kaby_Lake = "Kaby Lake"
        Coffee_Lake = "Coffee Lake"
        Comet_Lake = "Comet Lake"
        Ice_Lake = "Ice Lake"
        Unknown = "Unknown"

    arch: Archs = field(init=False)

    def detect_arch(self):
        if self.device_id in pci_data.intel_ids.gma_950_ids:
            self.arch = Intel.Archs.GMA_950
        elif self.device_id in pci_data.intel_ids.gma_x3100_ids:
            self.arch = Intel.Archs.GMA_X3100
        elif self.device_id in pci_data.intel_ids.iron_ids:
            self.arch = Intel.Archs.Iron_Lake
        elif self.device_id in pci_data.intel_ids.sandy_ids:
            self.arch = Intel.Archs.Sandy_Bridge
        elif self.device_id in pci_data.intel_ids.ivy_ids:
            self.arch = Intel.Archs.Ivy_Bridge
        elif self.device_id in pci_data.intel_ids.haswell_ids:
            self.arch = Intel.Archs.Haswell
        elif self.device_id in pci_data.intel_ids.broadwell_ids:
            self.arch = Intel.Archs.Broadwell
        elif self.device_id in pci_data.intel_ids.skylake_ids:
            self.arch = Intel.Archs.Skylake
        elif self.device_id in pci_data.intel_ids.kaby_lake_ids:
            self.arch = Intel.Archs.Kaby_Lake
        elif self.device_id in pci_data.intel_ids.coffee_lake_ids:
            self.arch = Intel.Archs.Coffee_Lake
        elif self.device_id in pci_data.intel_ids.comet_lake_ids:
            self.arch = Intel.Archs.Comet_Lake
        elif self.device_id in pci_data.intel_ids.ice_lake_ids:
            self.arch = Intel.Archs.Ice_Lake
        else:
            self.arch = Intel.Archs.Unknown

@dataclass
class IntelEthernet(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x8086

    class Chipsets(enum.Enum):
        AppleIntel8254XEthernet = "AppleIntel8254XEthernet Supported"
        AppleIntelI210Ethernet = "AppleIntelI210Ethernet Supported"
        Intel82574L = "Intel82574L Supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.intel_ids.AppleIntel8254XEthernet:
            self.chipset = IntelEthernet.Chipsets.AppleIntel8254XEthernet
        elif self.device_id in pci_data.intel_ids.AppleIntelI210Ethernet:
            self.chipset = IntelEthernet.Chipsets.AppleIntelI210Ethernet
        elif self.device_id in pci_data.intel_ids.Intel82574L:
            self.chipset = IntelEthernet.Chipsets.Intel82574L
        else:
            self.chipset = IntelEthernet.Chipsets.Unknown

@dataclass
class Broadcom(WirelessCard):
    VENDOR_ID: ClassVar[int] = 0x14E4

    class Chipsets(enum.Enum):
        # pylint: disable=invalid-name
        AppleBCMWLANBusInterfacePCIe = "AppleBCMWLANBusInterfacePCIe supported"
        AirportBrcmNIC = "AirportBrcmNIC supported"
        AirPortBrcmNICThirdParty = "AirPortBrcmNICThirdParty supported"
        AirPortBrcm4360 = "AirPortBrcm4360 supported"
        AirPortBrcm4331 = "AirPortBrcm4331 supported"
        AirPortBrcm43224 = "AppleAirPortBrcm43224 supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.broadcom_ids.AppleBCMWLANBusInterfacePCIe:
            self.chipset = Broadcom.Chipsets.AppleBCMWLANBusInterfacePCIe
        elif self.device_id in pci_data.broadcom_ids.AirPortBrcmNIC:
            self.chipset = Broadcom.Chipsets.AirportBrcmNIC
        elif self.device_id in pci_data.broadcom_ids.AirPortBrcmNICThirdParty:
            self.chipset = Broadcom.Chipsets.AirPortBrcmNICThirdParty
        elif self.device_id in pci_data.broadcom_ids.AirPortBrcm4360:
            self.chipset = Broadcom.Chipsets.AirPortBrcm4360
        elif self.device_id in pci_data.broadcom_ids.AirPortBrcm4331:
            self.chipset = Broadcom.Chipsets.AirPortBrcm4331
        elif self.device_id in pci_data.broadcom_ids.AppleAirPortBrcm43224:
            self.chipset = Broadcom.Chipsets.AirPortBrcm43224
        else:
            self.chipset = Broadcom.Chipsets.Unknown

@dataclass
class BroadcomEthernet(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x14E4

    class Chipsets(enum.Enum):
        AppleBCM5701Ethernet = "AppleBCM5701Ethernet supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.broadcom_ids.AppleBCM5701Ethernet:
            self.chipset = BroadcomEthernet.Chipsets.AppleBCM5701Ethernet
        else:
            self.chipset = BroadcomEthernet.Chipsets.Unknown

@dataclass
class Atheros(WirelessCard):
    VENDOR_ID: ClassVar[int] = 0x168C

    class Chipsets(enum.Enum):
        # pylint: disable=invalid-name
        # Well there's only one model but
        AirPortAtheros40 = "AirPortAtheros40 supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.atheros_ids.AtherosWifi:
            self.chipset = Atheros.Chipsets.AirPortAtheros40
        else:
            self.chipset = Atheros.Chipsets.Unknown


@dataclass
class Aquantia(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x1D6A

    class Chipsets(enum.Enum):
        # pylint: disable=invalid-name
        AppleEthernetAquantiaAqtion = "AppleEthernetAquantiaAqtion supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.aquantia_ids.AppleEthernetAquantiaAqtion:
            self.chipset = Aquantia.Chipsets.AppleEthernetAquantiaAqtion
        else:
            self.chipset = Aquantia.Chipsets.Unknown

@dataclass
class Marvell(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x11AB

    class Chipsets(enum.Enum):
        MarvelYukonEthernet = "MarvelYukonEthernet supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.marvell_ids.MarvelYukonEthernet:
            self.chipset = Marvell.Chipsets.MarvelYukonEthernet
        else:
            self.chipset = Marvell.Chipsets.Unknown

@dataclass
class SysKonnect(EthernetController):
    VENDOR_ID: ClassVar[int] = 0x1148

    class Chipsets(enum.Enum):
        MarvelYukonEthernet = "MarvelYukonEthernet supported"
        Unknown = "Unknown"

    chipset: Chipsets = field(init=False)

    def detect_chipset(self):
        if self.device_id in pci_data.syskonnect_ids.MarvelYukonEthernet:
            self.chipset = SysKonnect.Chipsets.MarvelYukonEthernet
        else:
            self.chipset = SysKonnect.Chipsets.Unknown


@dataclass
class Computer:
    real_model: Optional[str] = None
    real_board_id: Optional[str] = None
    reported_model: Optional[str] = None
    reported_board_id: Optional[str] = None
    build_model: Optional[str] = None
    uuid_sha1: Optional[str] = None
    gpus: list[GPU] = field(default_factory=list)
    igpu: Optional[GPU] = None  # Shortcut for IGPU
    dgpu: Optional[GPU] = None  # Shortcut for GFX0
    storage: list[PCIDevice] = field(default_factory=list)
    usb_controllers: list[PCIDevice] = field(default_factory=list)
    sdxc_controller: list[PCIDevice] = field(default_factory=list)
    ethernet: list[EthernetController] = field(default_factory=list)
    wifi: Optional[WirelessCard] = None
    cpu: Optional[CPU] = None
    usb_devices: list[USBDevice] = field(default_factory=list)
    oclp_version: Optional[str] = None
    opencore_version: Optional[str] = None
    opencore_path: Optional[str] = None
    bluetooth_chipset: Optional[str] = None
    internal_keyboard_type: Optional[str] = None
    trackpad_type: Optional[str] = None
    ambient_light_sensor: Optional[bool] = False
    third_party_sata_ssd: Optional[bool] = False
    pcie_webcam: Optional[bool] = False
    t1_chip: Optional[bool] = False
    secure_boot_model: Optional[str] = None
    secure_boot_policy: Optional[int] = None
    oclp_sys_version: Optional[str] = None
    oclp_sys_date: Optional[str] = None
    oclp_sys_url: Optional[str] = None
    oclp_sys_signed: Optional[bool] = False
    firmware_vendor: Optional[str] = None
    rosetta_active: Optional[bool] = False

    @staticmethod
    def probe():
        computer = Computer()
        computer.gpu_probe()
        computer.dgpu_probe()
        computer.igpu_probe()
        computer.wifi_probe()
        computer.storage_probe()
        computer.usb_controller_probe()
        computer.sdxc_controller_probe()
        computer.ethernet_probe()
        computer.smbios_probe()
        computer.usb_device_probe()
        computer.cpu_probe()
        computer.bluetooth_probe()
        computer.topcase_probe()
        computer.t1_probe()
        computer.ambient_light_sensor_probe()
        computer.pcie_webcam_probe()
        computer.sata_disk_probe()
        computer.oclp_sys_patch_probe()
        computer.check_rosetta()
        return computer


    def usb_device_probe(self):
        devices = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault, {"IOProviderClass": "IOUSBDevice"}, None
            )[1]
        )
        for device in devices:
            properties = USBDevice.from_ioregistry(device)
            if properties:
                properties.detect()
                self.usb_devices.append(properties)
            ioreg.IOObjectRelease(device)


    def gpu_probe(self):
        # Chain together two iterators: one for class code 03:00:00, the other for class code 03:80:00
        devices = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault, GPU.class_code_matching_dict(), None
            )[1]
        )

        for device in devices:
            vendor: Type[GPU] = PCIDevice.from_ioregistry(device).vendor_detect(inherits=GPU)  # type: ignore
            if vendor:
                self.gpus.append(vendor.from_ioregistry(device))  # type: ignore
            ioreg.IOObjectRelease(device)

    def dgpu_probe(self):
        device = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, ioreg.IOServiceNameMatching("GFX0".encode()), None)[1]), None)
        if not device:
            # No devices
            return

        vendor: Type[GPU] = PCIDevice.from_ioregistry(device).vendor_detect(inherits=GPU)  # type: ignore
        if vendor:
            self.dgpu = vendor.from_ioregistry(device)  # type: ignore
        ioreg.IOObjectRelease(device)

    def igpu_probe(self):
        device = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, ioreg.IOServiceNameMatching("IGPU".encode()), None)[1]), None)
        if not device:
            # No devices
            return

        vendor: Type[GPU] = PCIDevice.from_ioregistry(device).vendor_detect(inherits=GPU)  # type: ignore
        if vendor:
            self.igpu = vendor.from_ioregistry(device)  # type: ignore
        ioreg.IOObjectRelease(device)

    def wifi_probe(self):
        devices = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                WirelessCard.class_code_matching_dict(),
                None,
            )[1]
        )

        for device in devices:
            vendor: Type[WirelessCard] = PCIDevice.from_ioregistry(device, anti_spoof=True).vendor_detect(inherits=WirelessCard)  # type: ignore
            if vendor:
                self.wifi = vendor.from_ioregistry(device, anti_spoof=True)  # type: ignore
                break
            ioreg.IOObjectRelease(device)

    def ambient_light_sensor_probe(self):
        device = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, ioreg.IOServiceNameMatching("ALS0".encode()), None)[1]), None)
        if device:
            self.ambient_light_sensor = True
            ioreg.IOObjectRelease(device)

    def pcie_webcam_probe(self):
        # CMRA/14E4:1570
        device = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, ioreg.IOServiceNameMatching("CMRA".encode()), None)[1]), None)
        if device:
            self.pcie_webcam = True
            ioreg.IOObjectRelease(device)

    def sdxc_controller_probe(self):
        sdxc_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                SDXCController.class_code_matching_dict(),
                None,
            )[1]
        )

        for device in sdxc_controllers:
            self.sdxc_controller.append(SDXCController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)

    def usb_controller_probe(self):
        xhci_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                XHCIController.class_code_matching_dict(),
                None,
            )[1]
        )
        ehci_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                EHCIController.class_code_matching_dict(),
                None,
            )[1]
        )
        ohci_controllers  = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                OHCIController.class_code_matching_dict(),
                None,
            )[1]
        )

        uhci_controllers  = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                UHCIController.class_code_matching_dict(),
                None,
            )[1]
        )
        for device in xhci_controllers:
            self.usb_controllers.append(XHCIController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)
        for device in ehci_controllers:
            self.usb_controllers.append(EHCIController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)
        for device in ohci_controllers:
            self.usb_controllers.append(OHCIController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)
        for device in uhci_controllers:
            self.usb_controllers.append(UHCIController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)

    def ethernet_probe(self):
        ethernet_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                EthernetController.class_code_matching_dict(),
                None,
            )[1]
        )

        for device in ethernet_controllers:
            vendor: Type[EthernetController] = PCIDevice.from_ioregistry(device).vendor_detect(inherits=EthernetController)  # type: ignore
            if vendor:
                self.ethernet.append(vendor.from_ioregistry(device))  # type: ignore
            ioreg.IOObjectRelease(device)

    def storage_probe(self):
        sata_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                SATAController.class_code_matching_dict(),
                None,
            )[1]
        )
        sas_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                SASController.class_code_matching_dict(),
                None,
            )[1]
        )

        nvme_controllers = ioreg.ioiterator_to_list(
            ioreg.IOServiceGetMatchingServices(
                ioreg.kIOMasterPortDefault,
                NVMeController.class_code_matching_dict(),
                None,
            )[1]
        )
        for device in sata_controllers:
            self.storage.append(SATAController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)

        for device in sas_controllers:
            self.storage.append(SASController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)

        for device in nvme_controllers:
            self.storage.append(NVMeController.from_ioregistry(device))
            ioreg.IOObjectRelease(device)

    def smbios_probe(self):
        # Reported model
        entry = next(ioreg.ioiterator_to_list(ioreg.IOServiceGetMatchingServices(ioreg.kIOMasterPortDefault, ioreg.IOServiceMatching("IOPlatformExpertDevice".encode()), None)[1]))
        self.reported_model = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(entry, "model", ioreg.kCFAllocatorDefault, ioreg.kNilOptions)).strip(b"\0").decode()  # type: ignore
        translated = subprocess.run(["/usr/sbin/sysctl", "-in", "sysctl.proc_translated"], stdout=subprocess.PIPE).stdout.decode()
        if translated:
            board = "target-type"
        else:
            board = "board-id"
        self.reported_board_id = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(entry, board, ioreg.kCFAllocatorDefault, ioreg.kNilOptions)).strip(b"\0").decode()  # type: ignore
        self.uuid_sha1 = ioreg.corefoundation_to_native(ioreg.IORegistryEntryCreateCFProperty(entry, "IOPlatformUUID", ioreg.kCFAllocatorDefault, ioreg.kNilOptions))  # type: ignore
        self.uuid_sha1 = hashlib.sha1(self.uuid_sha1.encode()).hexdigest()
        ioreg.IOObjectRelease(entry)

        # Real model
        self.real_model = utilities.get_nvram("oem-product", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True) or self.reported_model
        self.real_board_id = utilities.get_nvram("oem-board", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True) or self.reported_board_id
        self.build_model = utilities.get_nvram("OCLP-Model", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)

        # OCLP version
        self.oclp_version = utilities.get_nvram("OCLP-Version", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
        self.opencore_version = utilities.get_nvram("opencore-version", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
        self.opencore_path = utilities.get_nvram("boot-path", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)

        # SecureBoot Variables
        self.secure_boot_model = utilities.check_secure_boot_model()
        self.secure_boot_policy = utilities.check_ap_security_policy()

        # Firmware Vendor
        firmware_vendor = utilities.get_firmware_vendor(decode=False)
        if isinstance(firmware_vendor, bytes):
            firmware_vendor = str(firmware_vendor.replace(b"\x00", b"").decode("utf-8"))
        self.firmware_vendor = firmware_vendor

    def cpu_probe(self):
        self.cpu = CPU(
            subprocess.run(["/usr/sbin/sysctl", "machdep.cpu.brand_string"], stdout=subprocess.PIPE).stdout.decode().partition(": ")[2].strip(),
            subprocess.run(["/usr/sbin/sysctl", "machdep.cpu.features"], stdout=subprocess.PIPE).stdout.decode().partition(": ")[2].strip().split(" "),
            self.cpu_get_leafs(),
        )

    def cpu_get_leafs(self):
        leafs = []
        result = subprocess.run(["/usr/sbin/sysctl", "machdep.cpu.leaf7_features"], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        if result.returncode == 0:
            return result.stdout.decode().partition(": ")[2].strip().split(" ")
        return leafs

    def bluetooth_probe(self):
        if not self.usb_devices:
            return

        # Ensure we get the "best" bluetooth chipset (if multiple are present)
        if any("BRCM20702" in usb_device.product_name for usb_device in self.usb_devices):
            self.bluetooth_chipset = "BRCM20702 Hub"
        elif any("BCM20702A0" in usb_device.product_name or "BCM2045A0" in usb_device.product_name for usb_device in self.usb_devices):
            self.bluetooth_chipset = "3rd Party Bluetooth 4.0 Hub"
        elif any("BRCM2070 Hub" in usb_device.product_name for usb_device in self.usb_devices):
            self.bluetooth_chipset = "BRCM2070 Hub"
        elif any("BRCM2046 Hub" in usb_device.product_name for usb_device in self.usb_devices):
            self.bluetooth_chipset = "BRCM2046 Hub"
        elif any("Bluetooth" in usb_device.product_name for usb_device in self.usb_devices):
            self.bluetooth_chipset = "Generic"

    def topcase_probe(self):
        if not self.usb_devices:
            return

        for usb_device in self.usb_devices:
            if self.internal_keyboard_type and self.trackpad_type:
                break
            if usb_device.vendor_id != 0x5ac:
                continue

            if usb_device.device_id in usb_data.AppleIDs.Legacy_AppleUSBTCKeyboard:
                self.internal_keyboard_type = "Legacy"
            elif usb_device.device_id in usb_data.AppleIDs.Modern_AppleUSBTCKeyboard:
                self.internal_keyboard_type = "Modern"

            if usb_device.device_id in usb_data.AppleIDs.AppleUSBTrackpad:
                self.trackpad_type = "Legacy"
            elif usb_device.device_id in usb_data.AppleIDs.AppleUSBMultiTouch:
                self.trackpad_type = "Modern"

    def t1_probe(self):
        if not self.usb_devices:
            return

        for usb_device in self.usb_devices:
            if usb_device.vendor_id != 0x5ac:
                continue
            # Standard T1
            if usb_device.device_id == 0x8600:
                self.t1_chip = True
                break
            # T1 in DFU mode
            # Note all Apple devices report the same device ID in DFU mode
            if usb_device.device_id == 0x1281:
                # Break down serial number into components
                #   ex. "CPID:8002 CPRV:10 CPFM:03 SCEP:01 BDID:12 ECID:000E5C8E34600026 IBFL:3D"
                # Is this overcomplicating T1 detection? Probably...
                if usb_device.serial_number is None:
                    continue
                serial_number = usb_device.serial_number.split(" ")
                # T1s come in 2 known flavours:
                # - x619dev
                #   - CPID: 0x8002
                #   - BDID: 0x13
                # - x619ap
                #   - CPID: 0x8002
                #   - BDID: 0x12
                if "CPID:8002" not in serial_number:
                    continue
                if "BDID:13" not in serial_number and "BDID:12" not in serial_number:
                    continue
                self.t1_chip = True
                break

    def sata_disk_probe(self):
        # Get all SATA Controllers/Disks from 'system_profiler SPSerialATADataType'
        # Determine whether SATA SSD is present and Apple-made
        sp_sata_data = plistlib.loads(subprocess.run(["/usr/sbin/system_profiler", "SPSerialATADataType", "-xml"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        for root in sp_sata_data:
            for ahci_controller in root["_items"]:
                # Each AHCI controller will have its own entry
                # Skip entries that are AHCI PCIe controllers
                # Apple's AHCI PCIe controller will report 'PCI' interconnect
                try:
                    if ahci_controller["spsata_physical_interconnect"] == "SATA":
                        for port in ahci_controller["_items"]:
                            if port["spsata_medium_type"] == "Solid State" and "apple" not in port["device_model"].lower():
                                self.third_party_sata_ssd = True
                                # Bail out of loop as we only need to know if there are any third-party SSDs present
                                break
                except KeyError:
                    # Notes:
                    # - SATA Optical Disk Drives don't report 'spsata_medium_type'
                    # - 'spsata_physical_interconnect' was not introduced till 10.9
                    continue

    def oclp_sys_patch_probe(self):
        path = Path("/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist")
        if not path.exists():
            self.oclp_sys_signed = True  # No plist, so assume root is valid
            return
        sys_plist = plistlib.load(path.open("rb"))
        if sys_plist:
            if "OpenCore Legacy Patcher" in sys_plist:
                self.oclp_sys_version = sys_plist["OpenCore Legacy Patcher"]
            if "Time Patched" in sys_plist:
                self.oclp_sys_date = sys_plist["Time Patched"]
            if "Commit URL" in sys_plist:
                self.oclp_sys_url = sys_plist["Commit URL"]
            if "Custom Signature" in sys_plist:
                self.oclp_sys_signed = sys_plist["Custom Signature"]

    def check_rosetta(self):
        result = subprocess.run(["/usr/sbin/sysctl", "-in", "sysctl.proc_translated"], stdout=subprocess.PIPE).stdout.decode()
        if "1" in result:
            self.rosetta_active = True
        else:
            self.rosetta_active = False

#ioreg.py:
"""
ioreg.py: PyObjc Handling for IOKit
"""

from typing import NewType, Union
import objc

from CoreFoundation import CFRelease, kCFAllocatorDefault  # type: ignore # pylint: disable=no-name-in-module
from Foundation import NSBundle  # type: ignore # pylint: disable=no-name-in-module
from PyObjCTools import Conversion

IOKit_bundle = NSBundle.bundleWithIdentifier_("com.apple.framework.IOKit")

# pylint: disable=invalid-name
io_name_t_ref_out = b"[128c]"  # io_name_t is char[128]
const_io_name_t_ref_in = b"r*"
CFStringRef = b"^{__CFString=}"
CFDictionaryRef = b"^{__CFDictionary=}"
CFAllocatorRef = b"^{__CFAllocator=}"
# pylint: enable=invalid-name

# https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html
functions = [
    ("IORegistryEntryCreateCFProperties", b"IIo^@" + CFAllocatorRef + b"I"),
    ("IOServiceMatching", CFDictionaryRef + b"r*"),
    ("IOServiceGetMatchingServices", b"II" + CFDictionaryRef + b"o^I"),
    ("IOIteratorNext", b"II"),
    ("IORegistryEntryGetParentEntry", b"IIr*o^I"),
    ("IOObjectRelease", b"II"),
    ("IORegistryEntryGetName", b"IIo" + io_name_t_ref_out),
    ("IOObjectGetClass", b"IIo" + io_name_t_ref_out),
    ("IOObjectCopyClass", CFStringRef + b"I"),
    ("IOObjectCopySuperclassForClass", CFStringRef + CFStringRef),
    ("IORegistryEntryGetChildIterator", b"IIr*o^I"),
    ("IORegistryCreateIterator", b"IIr*Io^I"),
    ("IORegistryEntryCreateIterator", b"IIr*Io^I"),
    ("IORegistryIteratorEnterEntry", b"II"),
    ("IORegistryIteratorExitEntry", b"II"),
    ("IORegistryEntryCreateCFProperty", b"@I" + CFStringRef + CFAllocatorRef + b"I"),
    ("IORegistryEntryGetPath", b"IIr*oI"),
    ("IORegistryEntryCopyPath", CFStringRef + b"Ir*"),
    ("IOObjectConformsTo", b"II" + const_io_name_t_ref_in),
    ("IORegistryEntryGetLocationInPlane", b"II" + const_io_name_t_ref_in + b"o" + io_name_t_ref_out),
    ("IOServiceNameMatching", CFDictionaryRef + b"r*"),
    ("IORegistryEntryGetRegistryEntryID", b"IIo^Q"),
    ("IORegistryEntryIDMatching", CFDictionaryRef + b"Q"),
    ("IORegistryEntryFromPath", b"II" + const_io_name_t_ref_in),
]

variables = [("kIOMasterPortDefault", b"I")]

# pylint: disable=invalid-name
pointer = type(None)

kern_return_t = NewType("kern_return_t", int)
boolean_t = int

io_object_t = NewType("io_object_t", object)
io_name_t = bytes
io_string_t = bytes

# io_registry_entry_t = NewType("io_registry_entry_t", io_object_t)
io_registry_entry_t = io_object_t
io_iterator_t = NewType("io_iterator_t", io_object_t)

CFTypeRef = Union[int, float, bytes, dict, list]

IOOptionBits = int
mach_port_t = int
CFAllocatorType = type(kCFAllocatorDefault)

NULL = 0

kIOMasterPortDefault: mach_port_t
kNilOptions: IOOptionBits = NULL

# IOKitLib.h
kIORegistryIterateRecursively = 1
kIORegistryIterateParents = 2

# pylint: enable=invalid-name


# kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef * properties, CFAllocatorRef allocator, IOOptionBits options);
def IORegistryEntryCreateCFProperties(entry: io_registry_entry_t, properties: pointer, allocator: CFAllocatorType, options: IOOptionBits) -> tuple[kern_return_t, dict]:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFMutableDictionaryRef IOServiceMatching(const char * name);
def IOServiceMatching(name: bytes) -> dict:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IOServiceGetMatchingServices(mach_port_t masterPort, CFDictionaryRef matching CF_RELEASES_ARGUMENT, io_iterator_t * existing);
def IOServiceGetMatchingServices(masterPort: mach_port_t, matching: dict, existing: pointer) -> tuple[kern_return_t, io_iterator_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# io_object_t IOIteratorNext(io_iterator_t iterator);
def IOIteratorNext(iterator: io_iterator_t) -> io_object_t:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t * parent);
def IORegistryEntryGetParentEntry(entry: io_registry_entry_t, plane: io_name_t, parent: pointer) -> tuple[kern_return_t, io_registry_entry_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IOObjectRelease(io_object_t object);
def IOObjectRelease(object: io_object_t) -> kern_return_t:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetName(io_registry_entry_t entry, io_name_t name);
def IORegistryEntryGetName(entry: io_registry_entry_t, name: pointer) -> tuple[kern_return_t, bytes]:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IOObjectGetClass(io_object_t object, io_name_t className);
def IOObjectGetClass(object: io_object_t, className: pointer) -> tuple[kern_return_t, bytes]:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFStringRef IOObjectCopyClass(io_object_t object);
def IOObjectCopyClass(object: io_object_t) -> str:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFStringRef IOObjectCopySuperclassForClass(CFStringRef classname)
def IOObjectCopySuperclassForClass(classname: str) -> str:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t * iterator);
def IORegistryEntryGetChildIterator(entry: io_registry_entry_t, plane: io_name_t, iterator: pointer) -> tuple[kern_return_t, io_iterator_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryCreateIterator(mach_port_t masterPort, const io_name_t plane, IOOptionBits options, io_iterator_t * iterator)
def IORegistryCreateIterator(masterPort: mach_port_t, plane: io_name_t, options: IOOptionBits, iterator: pointer) -> tuple[kern_return_t, io_iterator_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryCreateIterator(io_registry_entry_t entry, const io_name_t plane, IOOptionBits options, io_iterator_t * iterator)
def IORegistryEntryCreateIterator(entry: io_registry_entry_t, plane: io_name_t, options: IOOptionBits, iterator: pointer) -> tuple[kern_return_t, io_iterator_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryIteratorEnterEntry(io_iterator_t iterator)
def IORegistryIteratorEnterEntry(iterator: io_iterator_t) -> kern_return_t:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryIteratorExitEntry(io_iterator_t iterator)
def IORegistryIteratorExitEntry(iterator: io_iterator_t) -> kern_return_t:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options);
def IORegistryEntryCreateCFProperty(entry: io_registry_entry_t, key: str, allocator: CFAllocatorType, options: IOOptionBits) -> CFTypeRef:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetPath(io_registry_entry_t entry, const io_name_t plane, io_string_t path);
def IORegistryEntryGetPath(entry: io_registry_entry_t, plane: io_name_t, path: pointer) -> tuple[kern_return_t, io_string_t]:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFStringRef IORegistryEntryCopyPath(io_registry_entry_t entry, const io_name_t plane)
def IORegistryEntryCopyPath(entry: io_registry_entry_t, plane: bytes) -> str:  # pylint: disable=invalid-name
    raise NotImplementedError


# boolean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
def IOObjectConformsTo(object: io_object_t, className: bytes) -> boolean_t:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
def IORegistryEntryGetLocationInPlane(entry: io_registry_entry_t, plane: io_name_t, location: pointer) -> tuple[kern_return_t, bytes]:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFMutableDictionaryRef IOServiceNameMatching(const char * name);
def IOServiceNameMatching(name: bytes) -> dict:  # pylint: disable=invalid-name
    raise NotImplementedError


# kern_return_t IORegistryEntryGetRegistryEntryID(io_registry_entry_t entry, uint64_t * entryID)
def IORegistryEntryGetRegistryEntryID(entry: io_registry_entry_t, entryID: pointer) -> tuple[kern_return_t, int]:  # pylint: disable=invalid-name
    raise NotImplementedError


# CFMutableDictionaryRef IORegistryEntryIDMatching(uint64_t entryID);
def IORegistryEntryIDMatching(entryID: int) -> dict:  # pylint: disable=invalid-name
    raise NotImplementedError


# io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
def IORegistryEntryFromPath(mainPort: mach_port_t, path: io_string_t) -> io_registry_entry_t:  # pylint: disable=invalid-name
    raise NotImplementedError


objc.loadBundleFunctions(IOKit_bundle, globals(), functions)  # type: ignore # pylint: disable=no-member
objc.loadBundleVariables(IOKit_bundle, globals(), variables)  # type: ignore # pylint: disable=no-member


def ioiterator_to_list(iterator: io_iterator_t):
    # items = []
    item = IOIteratorNext(iterator)  # noqa: F821
    while item:
        # items.append(next)
        yield item
        item = IOIteratorNext(iterator)  # noqa: F821
    IOObjectRelease(iterator)  # noqa: F821
    # return items


def corefoundation_to_native(collection):
    if collection is None:  # nullptr
        return None
    native = Conversion.pythonCollectionFromPropertyList(collection)
    CFRelease(collection)
    return native


def native_to_corefoundation(native):
    return Conversion.propertyListFromPythonCollection(native)


def io_name_t_to_str(name):
    return name.partition(b"\0")[0].decode()


def get_class_inheritance(io_object):
    classes = []
    cls = IOObjectCopyClass(io_object)
    while cls:
        # yield cls
        classes.append(cls)
        CFRelease(cls)
        cls = IOObjectCopySuperclassForClass(cls)
    return classes


#os_probe.py:
"""
os_probe.py: OS Host information
"""

import platform
import plistlib
import subprocess


class OSProbe:
    """
    Library for querying OS information specific to macOS
    """

    def __init__(self) -> None:
        self.uname_data = platform.uname()


    def detect_kernel_major(self) -> int:
        """
        Detect the booted major kernel version

        Returns:
            int: Major kernel version (ex. 21, from 21.1.0)
        """

        return int(self.uname_data.release.partition(".")[0])


    def detect_kernel_minor(self) -> int:
        """
        Detect the booted minor kernel version

        Returns:
            int: Minor kernel version (ex. 1, from 21.1.0)
        """

        return int(self.uname_data.release.partition(".")[2].partition(".")[0])


    def detect_os_version(self) -> str:
        """
        Detect the booted OS version

        Returns:
            str: OS version (ex. 12.0)
        """

        result = subprocess.run(["/usr/bin/sw_vers", "-productVersion"], stdout=subprocess.PIPE)
        if result.returncode != 0:
            raise RuntimeError("Failed to detect OS version")

        return result.stdout.decode().strip()


    def detect_os_build(self, rsr: bool = False) -> str:
        """
        Detect the booted OS build

        Implementation note:
            With macOS 13.2, Apple implemented the Rapid Security Response system which
            will change the reported build to the RSR version and not the original host

            To get the proper versions:
            - Host: /System/Library/CoreServices/SystemVersion.plist
            - RSR:  /System/Volumes/Preboot/Cryptexes/OS/System/Library/CoreServices/SystemVersion.plist


        Parameters:
            rsr (bool): Whether to use the RSR version of the build

        Returns:
            str: OS build (ex. 21A5522h)
        """

        file_path = "/System/Library/CoreServices/SystemVersion.plist"
        if rsr is True:
            file_path = f"/System/Volumes/Preboot/Cryptexes/OS{file_path}"

        try:
            return plistlib.load(open(file_path, "rb"))["ProductBuildVersion"]
        except Exception as e:
            raise RuntimeError(f"Failed to detect OS build: {e}")

#Now EFI Builder Logic:
#bluetooth.py:
"""
bluetooth.py: Class for handling Bluetooth Patches, invocation from build.py
"""

import logging
import binascii

from . import support

from .. import constants

from ..detections import device_probe

from ..datasets import (
    cpu_data,
    smbios_data,
    bluetooth_data
)


class BuildBluetooth:
    """
    Build Library for Bluetooth Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off Bluetooth Build Process
        """

        if not self.constants.custom_model and self.computer.bluetooth_chipset:
            self._on_model()
        else:
            self._prebuilt_assumption()


    def _bluetooth_firmware_incompatibility_workaround(self) -> None:
        """
        For Mac firmwares that are unable to perform firmware uploads.
        Namely Macs with BCM2070 and BCM2046 chipsets, as well as pre-2012 Macs with upgraded chipsets.
        """
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["bluetoothInternalControllerInfo"] = binascii.unhexlify("0000000000000000000000000000")
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["bluetoothExternalDongleFailed"] = binascii.unhexlify("00")
        self.config["NVRAM"]["Delete"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"] += ["bluetoothInternalControllerInfo", "bluetoothExternalDongleFailed"]


    def _on_model(self) -> None:
        """
        On-Model Hardware Detection Handling
        """
        if self.computer.bluetooth_chipset in ["BRCM2070 Hub", "BRCM2046 Hub"]:
            logging.info("- Fixing Legacy Bluetooth for macOS Monterey")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("BlueToolFixup.kext", self.constants.bluetool_version, self.constants.bluetool_path)
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("Bluetooth-Spoof.kext", self.constants.btspoof_version, self.constants.btspoof_path)
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -btlfxallowanyaddr"
            self._bluetooth_firmware_incompatibility_workaround()
        elif self.computer.bluetooth_chipset == "BRCM20702 Hub":
            # BCM94331 can include either BCM2070 or BRCM20702 v1 Bluetooth chipsets
            # Note Monterey only natively supports BRCM20702 v2 (found with BCM94360)
            # Due to this, BlueToolFixup is required to resolve Firmware Uploading on legacy chipsets
            if self.computer.wifi:
                if self.computer.wifi.chipset == device_probe.Broadcom.Chipsets.AirPortBrcm4360:
                    logging.info("- Fixing Legacy Bluetooth for macOS Monterey")
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("BlueToolFixup.kext", self.constants.bluetool_version, self.constants.bluetool_path)

            # Older Mac firmwares (pre-2012) don't support the new chipsets correctly (regardless of WiFi card)
            if self.model in smbios_data.smbios_dictionary:
                if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                    logging.info("- Fixing Legacy Bluetooth for macOS Monterey")
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("BlueToolFixup.kext", self.constants.bluetool_version, self.constants.bluetool_path)
                    self._bluetooth_firmware_incompatibility_workaround()
        elif self.computer.bluetooth_chipset == "3rd Party Bluetooth 4.0 Hub":
            logging.info("- Detected 3rd Party Bluetooth Chipset")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("BlueToolFixup.kext", self.constants.bluetool_version, self.constants.bluetool_path)
            logging.info("- Enabling Bluetooth FeatureFlags")
            self.config["Kernel"]["Quirks"]["ExtendBTFeatureFlags"] = True


    def _prebuilt_assumption(self) -> None:
        """
        Fall back to pre-built assumptions
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "Bluetooth Model" in smbios_data.smbios_dictionary[self.model]:
            return

        if smbios_data.smbios_dictionary[self.model]["Bluetooth Model"] <= bluetooth_data.bluetooth_data.BRCM20702_v1.value:
            logging.info("- Fixing Legacy Bluetooth for macOS Monterey")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("BlueToolFixup.kext", self.constants.bluetool_version, self.constants.bluetool_path)
            if smbios_data.smbios_dictionary[self.model]["Bluetooth Model"] <= bluetooth_data.bluetooth_data.BRCM2070.value:
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -btlfxallowanyaddr"
                self._bluetooth_firmware_incompatibility_workaround()
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("Bluetooth-Spoof.kext", self.constants.btspoof_version, self.constants.btspoof_path)

#build.py:

"""
build.py: Class for generating OpenCore Configurations tailored for Macs
"""

import copy
import pickle
import shutil
import logging
import zipfile
import plistlib

from pathlib import Path
from datetime import date

from .. import constants

from ..support import utilities

from .networking import (
    wired,
    wireless
)
from . import (
    bluetooth,
    firmware,
    graphics_audio,
    support,
    storage,
    smbios,
    security,
    misc
)


def rmtree_handler(func, path, exc_info) -> None:
    if exc_info[0] == FileNotFoundError:
        return
    raise  # pylint: disable=misplaced-bare-raise


class BuildOpenCore:
    """
    Core Build Library for generating and validating OpenCore EFI Configurations
    compatible with genuine Macs
    """

    def __init__(self, model: str, global_constants: constants.Constants) -> None:
        self.model: str = model
        self.config: dict = None
        self.constants: constants.Constants = global_constants

        self._build_opencore()


    def _build_efi(self) -> None:
        """
        Build EFI folder
        """

        utilities.cls()
        logging.info(f"Building Configuration {'for external' if self.constants.custom_model else 'on model'}: {self.model}")

        self._generate_base()
        self._set_revision()

        # Set Lilu and co.
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("Lilu.kext", self.constants.lilu_version, self.constants.lilu_path)
        self.config["Kernel"]["Quirks"]["DisableLinkeditJettison"] = True

        # macOS Sequoia support for Lilu plugins
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -lilubetaall"

        # Call support functions
        for function in [
            firmware.BuildFirmware,
            wired.BuildWiredNetworking,
            wireless.BuildWirelessNetworking,
            graphics_audio.BuildGraphicsAudio,
            bluetooth.BuildBluetooth,
            storage.BuildStorage,
            smbios.BuildSMBIOS,
            security.BuildSecurity,
            misc.BuildMiscellaneous
        ]:
            function(self.model, self.constants, self.config)

        # Work-around ocvalidate
        if self.constants.validate is False:
            logging.info("- Adding bootmgfw.efi BlessOverride")
            self.config["Misc"]["BlessOverride"] += ["\\EFI\\Microsoft\\Boot\\bootmgfw.efi"]


    def _generate_base(self) -> None:
        """
        Generate OpenCore base folder and config
        """

        if not Path(self.constants.build_path).exists():
            logging.info("Creating build folder")
            Path(self.constants.build_path).mkdir()
        else:
            logging.info("Build folder already present, skipping")

        if Path(self.constants.opencore_zip_copied).exists():
            logging.info("Deleting old copy of OpenCore zip")
            Path(self.constants.opencore_zip_copied).unlink()
        if Path(self.constants.opencore_release_folder).exists():
            logging.info("Deleting old copy of OpenCore folder")
            shutil.rmtree(self.constants.opencore_release_folder, onerror=rmtree_handler, ignore_errors=True)

        logging.info("")
        logging.info(f"- Adding OpenCore v{self.constants.opencore_version} {'DEBUG' if self.constants.opencore_debug is True else 'RELEASE'}")
        shutil.copy(self.constants.opencore_zip_source, self.constants.build_path)
        zipfile.ZipFile(self.constants.opencore_zip_copied).extractall(self.constants.build_path)

        # Setup config.plist for editing
        logging.info("- Adding config.plist for OpenCore")
        shutil.copy(self.constants.plist_template, self.constants.oc_folder)
        self.config = plistlib.load(Path(self.constants.plist_path).open("rb"))


    def _set_revision(self) -> None:
        """
        Set revision information in config.plist
        """

        self.config["#Revision"]["Build-Version"] = f"{self.constants.patcher_version} - {date.today()}"
        if not self.constants.custom_model:
            self.config["#Revision"]["Build-Type"] = "OpenCore Built on Target Machine"
            computer_copy = copy.copy(self.constants.computer)
            computer_copy.ioregistry = None
            self.config["#Revision"]["Hardware-Probe"] = pickle.dumps(computer_copy)
        else:
            self.config["#Revision"]["Build-Type"] = "OpenCore Built for External Machine"
        self.config["#Revision"]["OpenCore-Version"] = f"{self.constants.opencore_version} - {'DEBUG' if self.constants.opencore_debug is True else 'RELEASE'}"
        self.config["#Revision"]["Original-Model"] = self.model
        self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Version"] = f"{self.constants.patcher_version}"
        self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Model"] = self.model


    def _save_config(self) -> None:
        """
        Save config.plist to disk
        """

        plistlib.dump(self.config, Path(self.constants.plist_path).open("wb"), sort_keys=True)


    def _build_opencore(self) -> None:
        """
        Kick off the build process

        This is the main function:
        - Generates the OpenCore configuration
        - Cleans working directory
        - Signs files
        - Validates generated EFI
        """

        # Generate OpenCore Configuration
        self._build_efi()
        if self.constants.allow_oc_everywhere is False or self.constants.allow_native_spoofs is True or (self.constants.custom_serial_number != "" and self.constants.custom_board_serial_number != ""):
            smbios.BuildSMBIOS(self.model, self.constants, self.config).set_smbios()
        support.BuildSupport(self.model, self.constants, self.config).cleanup()
        self._save_config()

        # Post-build handling
        support.BuildSupport(self.model, self.constants, self.config).sign_files()
        support.BuildSupport(self.model, self.constants, self.config).validate_pathing()

        logging.info("")
        logging.info(f"Your OpenCore EFI for {self.model} has been built at:")
        logging.info(f"    {self.constants.opencore_release_folder}")
        logging.info("")


# firmware.py:
"""
firmware.py: Class for handling CPU and Firmware Patches, invocation from build.py
"""

import shutil
import logging
import binascii

from pathlib import Path

from . import support

from .. import constants

from ..support import generate_smbios
from ..detections import device_probe

from ..datasets import (
    smbios_data,
    cpu_data,
    os_data
)


class BuildFirmware:
    """
    Build Library for CPU and Firmware Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off CPU and Firmware Build Process
        """

        self._cpu_compatibility_handling()
        self._power_management_handling()
        self._acpi_handling()
        self._firmware_driver_handling()
        self._firmware_compatibility_handling()
        self._apple_logo_handling()

    def _apple_logo_handling(self) -> None:
        """
        Apple logo Handling
        """

        # Macs that natively support Monterey (excluding MacPro6,1 and Macmini7,1) won't have boot.efi draw the Apple logo.
        # This causes a cosmetic issue when booting through OpenCore, as the Apple logo will be missing.

        if not self.model in smbios_data.smbios_dictionary:
            return

        if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] >= os_data.os_data.monterey and self.model not in ["MacPro6,1", "Macmini7,1"]:
            logging.info("- Enabling Boot Logo patch")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Booter"]["Patch"], "Comment", "Patch SkipLogo")["Enabled"] = True


    def _power_management_handling(self) -> None:
        """
        Power Management Handling
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
            return

        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value:
            # In macOS Ventura, Apple dropped AppleIntelCPUPowerManagement* kexts as they're unused on Haswell+
            # However re-injecting the AICPUPM kexts is not enough, as Ventura changed how 'intel_cpupm_matching' is set:
            #    macOS 12.5: https://github.com/apple-oss-distributions/xnu/blob/xnu-8020.140.41/osfmk/i386/pal_routines.h#L153-L163
            #    macOS 13.0: https://github.com/apple-oss-distributions/xnu/blob/xnu-8792.41.9/osfmk/i386/pal_routines.h#L153-L164
            #
            # Specifically Apple has this logic for power management:
            #  - 0: Kext Based Power Management
            #  - 3: Kernel Based Power Management (For Haswell+ and Virtual Machines)
            #  - 4: Generic Virtual Machine Power Management
            #
            # Apple determines which to use by verifying whether 'plugin-type' exists in ACPI (with a value of 1 for Haswell, 2 for VMs)
            # By default however, the plugin-type is not set, and thus the default value of '0' is used
            #    https://github.com/apple-oss-distributions/xnu/blob/e7776783b89a353188416a9a346c6cdb4928faad/osfmk/i386/pal_native.h#L62
            #
            # With Ventura, Apple no longer sets '0' as the default value, and instead sets it to '3'
            # This breaks AppleIntelCPUPowerManagement.kext matching as it no longer matches against the correct criteria
            #
            # To resolve, we patched AICPUPM to attach regardless of the value of 'intel_cpupm_matching'
            logging.info("- Enabling legacy power management support")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleIntelCPUPowerManagement.kext", self.constants.aicpupm_version, self.constants.aicpupm_path)
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleIntelCPUPowerManagementClient.kext", self.constants.aicpupm_version, self.constants.aicpupm_client_path)

        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.sandy_bridge.value or self.constants.disable_fw_throttle is True:
            # With macOS 12.3 Beta 1, Apple dropped the 'plugin-type' check within X86PlatformPlugin
            # Because of this, X86PP will match onto the CPU instead of ACPI_SMC_PlatformPlugin
            # This causes power management to break on pre-Ivy Bridge CPUs as they don't have correct
            # power management tables provided.
            # This patch will simply increase ASPP's 'IOProbeScore' to outmatch X86PP
            logging.info("- Overriding ACPI SMC matching")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("ASPP-Override.kext", self.constants.aspp_override_version, self.constants.aspp_override_path)
            if self.constants.disable_fw_throttle is True:
                # Only inject on older OSes if user requests
                support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Add"], "BundlePath", "ASPP-Override.kext")["MinKernel"] = ""

        if self.constants.disable_fw_throttle is True and smbios_data.smbios_dictionary[self.model]["CPU Generation"] >= cpu_data.CPUGen.nehalem.value:
            logging.info("- Disabling Firmware Throttling")
            # Nehalem and newer systems force firmware throttling via MSR_POWER_CTL
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("SimpleMSR.kext", self.constants.simplemsr_version, self.constants.simplemsr_path)


    def _acpi_handling(self) -> None:
        """
        ACPI Table Handling
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
            return

        # Resolves Big Sur support for consumer Nehalem
        # CPBG device in ACPI is a Co-Processor Bridge Device, which is not actually physically present
        # IOPCIFamily will error when enumerating this device, thus we'll power it off via _STA (has no effect in older OSes)
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] == cpu_data.CPUGen.nehalem.value and not (self.model.startswith("MacPro") or self.model.startswith("Xserve")):
            logging.info("- Adding SSDT-CPBG.aml")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Add"], "Path", "SSDT-CPBG.aml")["Enabled"] = True
            shutil.copy(self.constants.pci_ssdt_path, self.constants.acpi_path)

        if cpu_data.CPUGen.sandy_bridge <= smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value and self.model != "MacPro6,1":
            # Based on: https://egpu.io/forums/pc-setup/fix-dsdt-override-to-correct-error-12/
            # Applicable for Sandy and Ivy Bridge Macs
            logging.info("- Enabling Windows 10 UEFI Audio support")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Add"], "Path", "SSDT-PCI.aml")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Patch"], "Comment", "BUF0 to BUF1")["Enabled"] = True
            shutil.copy(self.constants.windows_ssdt_path, self.constants.acpi_path)


    def _cpu_compatibility_handling(self) -> None:
        """
        CPU Compatibility Handling
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
            return

        # SSE4,1 support (ie. Penryn)
        # Required for macOS Mojave and newer
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.penryn.value:
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AAAMouSSE.kext", self.constants.mousse_version, self.constants.mousse_path)
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("telemetrap.kext", self.constants.telemetrap_version, self.constants.telemetrap_path)

        # Force Rosetta Cryptex installation in macOS Ventura
        # Restores support for CPUs lacking AVX2.0 support
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value:
            logging.info("- Enabling Rosetta Cryptex support in Ventura")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("CryptexFixup.kext", self.constants.cryptexfixup_version, self.constants.cryptexfixup_path)

        # i3 Ivy Bridge iMacs don't support RDRAND
        # However for prebuilt, assume they do
        if (not self.constants.custom_model and "RDRAND" not in self.computer.cpu.flags) or \
            (smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.sandy_bridge.value):
            # Ref: https://github.com/reenigneorcim/SurPlus
            # Enable for all systems missing RDRAND support
            logging.info("- Adding SurPlus Patch for Race Condition")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "SurPlus v1 - PART 1 of 2 - Patch read_erandom (inlined in _early_random)")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "SurPlus v1 - PART 2 of 2 - Patch register_and_init_prng")["Enabled"] = True
            if self.constants.force_surplus is True:
                # Syncretic forces SurPlus to only run on Beta 7 and older by default for saftey reasons
                # If users desires, allow forcing in newer OSes
                logging.info("- Allowing SurPlus on all newer OSes")
                support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "SurPlus v1 - PART 1 of 2 - Patch read_erandom (inlined in _early_random)")["MaxKernel"] = ""
                support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "SurPlus v1 - PART 2 of 2 - Patch register_and_init_prng")["MaxKernel"] = ""

        # In macOS 12.4 and 12.5 Beta 1, Apple added AVX1.0 usage in AppleFSCompressionTypeZlib
        # Pre-Sandy Bridge CPUs don't support AVX1.0, thus we'll downgrade the kext to 12.3.1's
        # Currently a (hopefully) temporary workaround for the issue, proper fix needs to be investigated
        # Ref:
        #    https://forums.macrumors.com/threads/macos-12-monterey-on-unsupported-macs-thread.2299557/post-31120235
        #    https://forums.macrumors.com/threads/monterand-probably-the-start-of-an-ongoing-saga.2320479/post-31123553

        # To verify the non-AVX kext is used, check IOService for 'com_apple_AppleFSCompression_NoAVXCompressionTypeZlib'
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.sandy_bridge.value:
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("NoAVXFSCompressionTypeZlib.kext", self.constants.apfs_zlib_version, self.constants.apfs_zlib_path)
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("NoAVXFSCompressionTypeZlib-AVXpel.kext", self.constants.apfs_zlib_v2_version, self.constants.apfs_zlib_v2_path)

        # HID patches
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.penryn.value:
            logging.info("- Adding IOHIDFamily patch")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Identifier", "com.apple.iokit.IOHIDFamily")["Enabled"] = True

        # MacPro3,1/Xserve2,1 cannot boot with more than 4 threads in Sequoia
        # Note cpus=4 only overrides if more than 4 threads are present. So same on dual-core units
        if self.constants.force_quad_thread is True:
            logging.info("- Adding CPU Thread Limit Patch")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " cpus=4"


    def _firmware_driver_handling(self) -> None:
        """
        Firmware Driver Handling (Drivers/*.efi)
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
            return

        # Exfat check
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.sandy_bridge.value:
            # Sandy Bridge and newer Macs natively support ExFat
            logging.info("- Adding ExFatDxeLegacy.efi")
            shutil.copy(self.constants.exfat_legacy_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("ExFatDxeLegacy.efi", "UEFI", "Drivers")["Enabled"] = True

        # NVMe check
        if self.constants.nvme_boot is True:
            logging.info("- Enabling NVMe boot support")
            shutil.copy(self.constants.nvme_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("NvmExpressDxe.efi", "UEFI", "Drivers")["Enabled"] = True

        # USB check
        if self.constants.xhci_boot is True:
            logging.info("- Adding USB 3.0 Controller Patch")
            logging.info("- Adding XhciDxe.efi and UsbBusDxe.efi")
            shutil.copy(self.constants.xhci_driver_path, self.constants.drivers_path)
            shutil.copy(self.constants.usb_bus_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("XhciDxe.efi", "UEFI", "Drivers")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("UsbBusDxe.efi", "UEFI", "Drivers")["Enabled"] = True

        # PCIe Link Rate check
        if self.model == "MacPro3,1":
            logging.info("- Adding PCIe Link Rate Patch")
            shutil.copy(self.constants.link_rate_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("FixPCIeLinkRate.efi", "UEFI", "Drivers")["Enabled"] = True

        # CSM check
        # For model support, check for GUID in firmware and as well as Bootcamp Assistant's Info.plist ('PreUEFIModels' key)
        # Ref: https://github.com/acidanthera/OpenCorePkg/blob/0.9.5/Platform/OpenLegacyBoot/OpenLegacyBoot.c#L19
        if Path(self.constants.drivers_path / Path("OpenLegacyBoot.efi")).exists():
            # if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value and self.model != "MacPro6,1":
            #     logging.info("- Enabling CSM support")
            #     support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("OpenLegacyBoot.efi", "UEFI", "Drivers")["Enabled"] = True
            # else:
            #     # Shipped alongside OpenCorePkg, so remove if unused
            #     (self.constants.drivers_path / Path("OpenLegacyBoot.efi")).unlink()

            # Currently disabled for compatibility reasons
            # Certain machines freeze on boot with OpenLegacyBoot.efi
            (self.constants.drivers_path / Path("OpenLegacyBoot.efi")).unlink()

    def _firmware_compatibility_handling(self) -> None:
        """
        Firmware Compatibility Handling (Firmware and Kernel)
        """

        self._dual_dp_handling()

        # Patches IOPCIConfigurator.cpp's IOPCIIsHotplugPort to skip configRead16/32 calls
        # Credit to CaseySJ for original discovery:
        # - Patch: https://github.com/AMD-OSX/AMD_Vanilla/pull/196
        # - Source: https://github.com/apple-oss-distributions/IOPCIFamily/blob/IOPCIFamily-583.40.1/IOPCIConfigurator.cpp#L968-L1022
        #
        # Currently all pre-Sandy Bridge Macs lacking an iGPU benefit from this patch as well as MacPro6,1
        # Otherwise some graphics hardware will fail to wake, macOS will misreport hardware as ExpressCard-based,
        # prevents MacPro6,1 from both booting unaccelerated and breaks low power states.
        if (
            self.model in ["MacPro6,1", "MacBookPro4,1"] or
            (
                smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.sandy_bridge.value and \
                not self.model.startswith("MacBook")
            )
        ):
            logging.info("- Adding PCI Bus Enumeration Patch")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "CaseySJ - Fix PCI bus enumeration (Ventura)")["Enabled"] = True
            # Sonoma slightly adjusted this line specifically
            # - https://github.com/apple-oss-distributions/IOPCIFamily/blob/IOPCIFamily-583.40.1/IOPCIConfigurator.cpp#L1009
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "Fix PCI bus enumeration (Sonoma)")["Enabled"] = True

        if self.constants.set_vmm_cpuid is True:
            logging.info("- Enabling VMM patch")
            self.config["Kernel"]["Emulate"]["Cpuid1Data"] = binascii.unhexlify("00000000000000000000008000000000")
            self.config["Kernel"]["Emulate"]["Cpuid1Mask"] = binascii.unhexlify("00000000000000000000008000000000")

        if (
            self.model.startswith("MacBook")
            and (
                smbios_data.smbios_dictionary[self.model]["CPU Generation"] == cpu_data.CPUGen.haswell.value or
                smbios_data.smbios_dictionary[self.model]["CPU Generation"] == cpu_data.CPUGen.broadwell.value
            )
        ):
            # Fix Virtual Machine support for non-macOS OSes
            # Haswell and Broadwell MacBooks lock out the VMX bit if booting UEFI Windows
            logging.info("- Enabling VMX Bit for non-macOS OSes")
            self.config["UEFI"]["Quirks"]["EnableVmx"] = True

        # Works-around Hibernation bug where connecting all firmware drivers breaks the transition from S4
        # Mainly applicable for MacBookPro9,1
        if self.constants.disable_connectdrivers is True:
            logging.info("- Disabling ConnectDrivers")
            self.config["UEFI"]["ConnectDrivers"] = False

        if self.constants.nvram_write is False:
            logging.info("- Disabling Hardware NVRAM Write")
            self.config["NVRAM"]["WriteFlash"] = False

        if self.constants.serial_settings != "None":
            # AppleMCEReporter is very picky about which models attach to the kext
            # Commonly it will kernel panic on multi-socket systems, however even on single-socket systems it may cause instability
            # To avoid any issues, we'll disable it if the spoof is set to an affected SMBIOS
            affected_smbios = ["MacPro6,1", "MacPro7,1", "iMacPro1,1"]
            if self.model not in affected_smbios:
                # If MacPro6,1 host spoofs, we can safely enable it
                if self.constants.override_smbios in affected_smbios or generate_smbios.set_smbios_model_spoof(self.model) in affected_smbios:
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleMCEReporterDisabler.kext", self.constants.mce_version, self.constants.mce_path)


    def _dual_dp_handling(self) -> None:
        """
        Dual DisplayPort Stream Handler (ex. 5k iMac)

        Apple has 2 modes for display handling on 5K iMacs and iMac Pro
        If at any point in the boot chain an "unsupported" entry is loaded, the firmware will tell the
        Display Controller to enter a 4K compatible mode that only uses a single DisplayPort 1.2 stream internally.
        This is to prevent situations where the system would boot into an enviroment that cannot handle the custom
        dual DisplayPort 1.2 streams the 5k Display uses

        To work around this issue, we trick the firmware into loading OpenCore through Apple's Hardware Diagnostic Tests
        Specifically hiding as Product.efi under '/System/Library/CoreServices/.diagnostics/Drivers/HardwareDrivers/Product.efi'
        The reason chainloading via ./Drivers/HardwareDrivers is possible is thanks to it being loaded via an encrypted file buffer
        whereas other drivers like ./qa_logger.efi is invoked via Device Path.
        """

        if "Dual DisplayPort Display" not in smbios_data.smbios_dictionary[self.model]:
            return

        logging.info("- Adding 4K/5K Display Patch")
        # Set LauncherPath to '/boot.efi'
        # This is to ensure that only the Mac's firmware presents the boot option, but not OpenCore
        # https://github.com/acidanthera/OpenCorePkg/blob/0.7.6/Library/OcAppleBootPolicyLib/OcAppleBootPolicyLib.c#L50-L73
        self.config["Misc"]["Boot"]["LauncherPath"] = "\\boot.efi"

        # Setup diags.efi chainloading
        Path(self.constants.opencore_release_folder / Path("System/Library/CoreServices/.diagnostics/Drivers/HardwareDrivers")).mkdir(parents=True, exist_ok=True)
        if self.constants.boot_efi is True:
            path_oc_loader = self.constants.opencore_release_folder / Path("EFI/BOOT/BOOTx64.efi")
        else:
            path_oc_loader = self.constants.opencore_release_folder / Path("System/Library/CoreServices/boot.efi")
        shutil.move(path_oc_loader, self.constants.opencore_release_folder / Path("System/Library/CoreServices/.diagnostics/Drivers/HardwareDrivers/Product.efi"))
        shutil.copy(self.constants.diags_launcher_path, self.constants.opencore_release_folder)
        shutil.move(self.constants.opencore_release_folder / Path("diags.efi"), self.constants.opencore_release_folder / Path("boot.efi"))

#graphics_audio.py:
"""
graphics_audio.py: Class for handling Graphics and Audio Patches, invocation from build.py
"""

import shutil
import logging
import binascii

from pathlib import Path

from . import support

from .. import constants

from ..support import utilities
from ..detections import device_probe

from ..datasets import (
    smbios_data,
    model_array,
    os_data,
    cpu_data,
    video_bios_data
)


class BuildGraphicsAudio:
    """
    Build Library for Graphics and Audio Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self.gfx0_path = None

        self._build()


    def _build(self) -> None:
        """
        Kick off Graphics and Audio Build Process
        """

        self._imac_mxm_patching()
        self._graphics_handling()
        self._audio_handling()
        self._firmware_handling()
        self._spoof_handling()
        self._ioaccel_workaround()


    def _graphics_handling(self) -> None:
        """
        Graphics Handling

        Primarily for Mac Pros and systems with Nvidia Maxwell/Pascal GPUs
        """

        if self.constants.allow_oc_everywhere is False and self.constants.serial_settings != "None":
            if not support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("WhateverGreen.kext")["Enabled"] is True:
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_version, self.constants.whatevergreen_path)

        # Mac Pro handling
        if self.model in model_array.MacPro:
            if not self.constants.custom_model:
                for i, device in enumerate(self.computer.gpus):
                    logging.info(f"- Found dGPU ({i + 1}): {utilities.friendly_hex(device.vendor_id)}:{utilities.friendly_hex(device.device_id)}")
                    self.config["#Revision"][f"Hardware-MacPro-dGPU-{i + 1}"] = f"{utilities.friendly_hex(device.vendor_id)}:{utilities.friendly_hex(device.device_id)}"

                    if device.pci_path and device.acpi_path:
                        logging.info(f"- Found dGPU ({i + 1}) at {device.pci_path}")
                        if isinstance(device, device_probe.AMD):
                            logging.info("- Adding Mac Pro, Xserve DRM patches")
                            self.config["DeviceProperties"]["Add"][device.pci_path] = {"shikigva": 128, "unfairgva": 1, "rebuild-device-tree": 1, "agdpmod": "pikera", "enable-gva-support": 1}
                        elif isinstance(device, device_probe.NVIDIA):
                            logging.info("- Enabling Nvidia Output Patch")
                            self.config["DeviceProperties"]["Add"][device.pci_path] = {"rebuild-device-tree": 1, "agdpmod": "vit9696"}
                            self.config["UEFI"]["Quirks"]["ForgeUefiSupport"] = True
                            self.config["UEFI"]["Quirks"]["ReloadOptionRoms"] = True

                    else:
                        logging.info(f"- Failed to find Device path for dGPU {i + 1}")
                        if isinstance(device, device_probe.AMD):
                            logging.info("- Adding Mac Pro, Xserve DRM patches")
                            if "shikigva=128 unfairgva=1" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"]:
                                logging.info("- Falling back to boot-args")
                                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " shikigva=128 unfairgva=1 agdpmod=pikera radgva=1" + (
                                    " -wegtree" if "-wegtree" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] else ""
                                )
                        elif isinstance(device, device_probe.NVIDIA):
                            logging.info("- Enabling Nvidia Output Patch")
                            if "-wegtree agdpmod=vit9696" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"]:
                                logging.info("- Falling back to boot-args")
                                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -wegtree agdpmod=vit9696"
                            self.config["UEFI"]["Quirks"]["ForgeUefiSupport"] = True
                            self.config["UEFI"]["Quirks"]["ReloadOptionRoms"] = True

                if not self.computer.gpus:
                    logging.info("- No socketed dGPU found")

            else:
                logging.info("- Adding Mac Pro, Xserve DRM patches")
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " shikigva=128 unfairgva=1 -wegtree"

            if not support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("WhateverGreen.kext")["Enabled"] is True:
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_version, self.constants.whatevergreen_path)

        # Web Driver specific
        if not self.constants.custom_model:
            for i, device in enumerate(self.computer.gpus):
                if isinstance(device, device_probe.NVIDIA):
                    if (
                        device.arch in [device_probe.NVIDIA.Archs.Fermi, device_probe.NVIDIA.Archs.Maxwell, device_probe.NVIDIA.Archs.Pascal] or
                        (self.constants.force_nv_web is True and device.arch in [device_probe.NVIDIA.Archs.Tesla, device_probe.NVIDIA.Archs.Kepler])
                    ):
                        logging.info(f"- Enabling Web Driver Patches for GPU ({i + 1}): {utilities.friendly_hex(device.vendor_id)}:{utilities.friendly_hex(device.device_id)}")
                        if device.pci_path and device.acpi_path:
                            if device.pci_path in self.config["DeviceProperties"]["Add"]:
                                self.config["DeviceProperties"]["Add"][device.pci_path].update({"disable-metal": 1, "force-compat": 1})
                            else:
                                self.config["DeviceProperties"]["Add"][device.pci_path] = {"disable-metal": 1, "force-compat": 1}
                            support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_version, self.constants.whatevergreen_path)
                            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"].update({"nvda_drv": binascii.unhexlify("31")})
                            if "nvda_drv" not in self.config["NVRAM"]["Delete"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]:
                                self.config["NVRAM"]["Delete"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"] += ["nvda_drv"]
                        else:
                            if "ngfxgl=1 ngfxcompat=1" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"]:
                                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " ngfxgl=1 ngfxcompat=1"
                            support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_version, self.constants.whatevergreen_path)
                            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"].update({"nvda_drv": binascii.unhexlify("31")})
                            if "nvda_drv" not in self.config["NVRAM"]["Delete"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]:
                                self.config["NVRAM"]["Delete"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"] += ["nvda_drv"]

    def _backlight_path_detection(self) -> None:
        """
        iMac MXM dGPU Backlight DevicePath Detection
        """

        if not self.constants.custom_model:
            for i, device in enumerate(self.computer.gpus):
                    logging.info(f"- Found dGPU ({i + 1}): {utilities.friendly_hex(device.vendor_id)}:{utilities.friendly_hex(device.device_id)}")
                    self.config["#Revision"][f"Hardware-iMac-dGPU-{i + 1}"] = f"{utilities.friendly_hex(device.vendor_id)}:{utilities.friendly_hex(device.device_id)}"

                    # Work-around for AMD Navi MXM cards with PCIe bridge
                    if not self.computer.dgpu:
                        self.computer.dgpu=self.computer.gpus[i]

                    if device.pci_path != self.computer.dgpu.pci_path:
                        logging.info("- device path and GFX0 Device path are different")
                        self.gfx0_path = device.pci_path
                        logging.info(f"- Set GFX0 Device Path: {self.gfx0_path}")
                        self.computer.dgpu.device_id = device.device_id
                        self.device_id = device.device_id
                        logging.info(f"- Found GPU Arch: {device.arch}")
                        if device.arch in [device_probe.AMD.Archs.Navi]:
                            self.computer.dgpu.arch = device.arch

                        # self.computer.dgpu.vendor_id = device.vendor_id
                        # self.vendor_id = device.vendor_id
                    else:
                        self.gfx0_path = self.computer.dgpu.pci_path
                        logging.info(f"- Found GFX0 Device Path: {self.gfx0_path}")
                        logging.info(f"- Found GPU Arch: {self.computer.dgpu.arch}")

        else:
            if not self.constants.custom_model:
                logging.info("- Failed to find GFX0 Device path, falling back on known logic")
            if self.model in ["iMac11,1", "iMac11,3"]:
                self.gfx0_path = "PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"
            elif self.model in ["iMac9,1", "iMac10,1"]:
                self.gfx0_path = "PciRoot(0x0)/Pci(0xc,0x0)/Pci(0x0,0x0)"
            else:
                self.gfx0_path = "PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"


    def _nvidia_mxm_patch(self, backlight_path) -> None:
        """
        iMac Nvidia Kepler MXM Handler
        """

        if not support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("WhateverGreen.kext")["Enabled"] is True:
            # Ensure WEG is enabled as we need if for Backlight patching
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_navi_version, self.constants.whatevergreen_navi_path)
        if self.model in ["iMac11,1", "iMac11,2", "iMac11,3", "iMac10,1"]:
            logging.info("- Adding Nvidia Brightness Control and DRM patches")
            self.config["DeviceProperties"]["Add"][backlight_path] = {
                "applbkl": binascii.unhexlify("01000000"),
                "@0,backlight-control": binascii.unhexlify("01000000"),
                "@0,built-in": binascii.unhexlify("01000000"),
                "shikigva": 256,
                "agdpmod": "vit9696",
            }
            if self.constants.custom_model and self.model == "iMac11,2":
                # iMac11,2 can have either PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0) or PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)
                # Set both properties when we cannot run hardware detection
                self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"] = {
                    "applbkl": binascii.unhexlify("01000000"),
                    "@0,backlight-control": binascii.unhexlify("01000000"),
                    "@0,built-in": binascii.unhexlify("01000000"),
                    "shikigva": 256,
                    "agdpmod": "vit9696",
                }
        elif self.model in ["iMac12,1", "iMac12,2"]:
            logging.info("- Adding Nvidia Brightness Control and DRM patches")
            self.config["DeviceProperties"]["Add"][backlight_path] = {
                "applbkl": binascii.unhexlify("01000000"),
                "@0,backlight-control": binascii.unhexlify("01000000"),
                "@0,built-in": binascii.unhexlify("01000000"),
                "shikigva": 256,
                "agdpmod": "vit9696",
            }
            logging.info("- Disabling unsupported iGPU")
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x2,0x0)"] = {
                "name": binascii.unhexlify("23646973706C6179"),
                "class-code": binascii.unhexlify("FFFFFFFF"),
            }
        shutil.copy(self.constants.backlight_injector_path, self.constants.kexts_path)
        support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("BacklightInjector.kext")["Enabled"] = True
        self.config["UEFI"]["Quirks"]["ForgeUefiSupport"] = True
        self.config["UEFI"]["Quirks"]["ReloadOptionRoms"] = True


    def _amd_mxm_patch(self, backlight_path) -> None:
        """
        iMac AMD GCN and Navi MXM Handler
        """

        logging.info("- Adding AMD DRM patches")
        if not support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("WhateverGreen.kext")["Enabled"] is True:
            # Ensure WEG is enabled as we need if for Backlight patching
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("WhateverGreen.kext", self.constants.whatevergreen_navi_version, self.constants.whatevergreen_navi_path)

        if self.model == "iMac9,1":
            logging.info("- Adding iMac9,1 Brightness Control and DRM patches")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("BacklightInjector.kext", self.constants.backlight_injectorA_version, self.constants.backlight_injectorA_path)

        if not self.constants.custom_model:
            if self.computer.dgpu.device_id == 0x7340:
                logging.info(f"- Adding AMD RX5500XT vBIOS injection")
                self.config["DeviceProperties"]["Add"][backlight_path] = {"shikigva": 128, "unfairgva": 1, "agdpmod": "pikera", "rebuild-device-tree": 1, "enable-gva-support": 1, "ATY,bin_image": binascii.unhexlify(video_bios_data.RX5500XT_64K) }
                logging.info(f"- Adding AMD RX5500XT boot-args")
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " agdpmod=pikera applbkl=3"
            elif self.computer.dgpu.device_id_unspoofed == 0x6981:
                logging.info(f"- Adding AMD WX3200 device spoofing")
                self.config["DeviceProperties"]["Add"][backlight_path] = {"shikigva": 128, "unfairgva": 1, "agdpmod": "pikera", "rebuild-device-tree": 1, "enable-gva-support": 1, "model": "AMD Radeon Pro WX 3200", "device-id": binascii.unhexlify("FF67")}
            else:
                self.config["DeviceProperties"]["Add"][backlight_path] = {"shikigva": 128, "unfairgva": 1, "agdpmod": "pikera", "rebuild-device-tree": 1, "enable-gva-support": 1}
        else:
             self.config["DeviceProperties"]["Add"][backlight_path] = {"shikigva": 128, "unfairgva": 1, "agdpmod": "pikera", "rebuild-device-tree": 1, "enable-gva-support": 1}

        if self.constants.custom_model and self.model == "iMac11,2":
            # iMac11,2 can have either PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0) or PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)
            # Set both properties when we cannot run hardware detection
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"] = {"shikigva": 128, "unfairgva": 1, "agdpmod": "pikera", "rebuild-device-tree": 1, "enable-gva-support": 1}
        if self.model in ["iMac12,1", "iMac12,2"]:
            logging.info("- Disabling unsupported iGPU")
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x2,0x0)"] = {
                "name": binascii.unhexlify("23646973706C6179"),
                "class-code": binascii.unhexlify("FFFFFFFF"),
            }
        elif self.model in ["iMac9,1", "iMac10,1"]:
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AAAMouSSE.kext", self.constants.mousse_version, self.constants.mousse_path)
        if self.computer and self.computer.dgpu:
            if self.computer.dgpu.arch == device_probe.AMD.Archs.Legacy_GCN_7000:
                logging.info("- Adding Legacy GCN Power Gate Patches")
                self.config["DeviceProperties"]["Add"][backlight_path].update({
                    "CAIL,CAIL_DisableDrmdmaPowerGating": 1,
                    "CAIL,CAIL_DisableGfxCGPowerGating": 1,
                    "CAIL,CAIL_DisableUVDPowerGating": 1,
                    "CAIL,CAIL_DisableVCEPowerGating": 1,
                })
        if self.constants.imac_model == "GCN":
            logging.info("- Adding Legacy GCN Power Gate Patches")
            self.config["DeviceProperties"]["Add"][backlight_path].update({
                "CAIL,CAIL_DisableDrmdmaPowerGating": 1,
                "CAIL,CAIL_DisableGfxCGPowerGating": 1,
                "CAIL,CAIL_DisableUVDPowerGating": 1,
                "CAIL,CAIL_DisableVCEPowerGating": 1,
            })
            if self.model == "iMac11,2":
                self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"].update({
                    "CAIL,CAIL_DisableDrmdmaPowerGating": 1,
                    "CAIL,CAIL_DisableGfxCGPowerGating": 1,
                    "CAIL,CAIL_DisableUVDPowerGating": 1,
                    "CAIL,CAIL_DisableVCEPowerGating": 1,
                })
        elif self.constants.imac_model == "Lexa":
            logging.info("- Adding Lexa Spoofing Patches")
            self.config["DeviceProperties"]["Add"][backlight_path].update({
                "model": "AMD Radeon Pro WX 3200",
                "device-id": binascii.unhexlify("FF67"),
            })
            if self.model == "iMac11,2":
                self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x3,0x0)/Pci(0x0,0x0)"].update({
                    "model": "AMD Radeon Pro WX 3200",
                    "device-id": binascii.unhexlify("FF67"),
                })
        elif self.constants.imac_model == "Navi":
            logging.info("- Adding Navi Spoofing Patches")
            navi_backlight_path = backlight_path+"/Pci(0x0,0x0)/Pci(0x0,0x0)"
            self.config["DeviceProperties"]["Add"][navi_backlight_path] = {
                "ATY,bin_image": binascii.unhexlify(video_bios_data.RX5500XT_64K),
                "shikigva": 128,
                "unfairgva": 1,
                "rebuild-device-tree": 1,
                "enable-gva-support": 1
            }
            logging.info(f"- Adding AMD RX5500XT boot-args")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " agdpmod=pikera applbkl=3"


    def _audio_handling(self) -> None:
        """
        Audio Handler
        """

        if (self.model in model_array.LegacyAudio or self.model in model_array.MacPro) and self.constants.set_alc_usage is True:
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleALC.kext", self.constants.applealc_version, self.constants.applealc_path)

        # Audio Patch
        if self.constants.set_alc_usage is True:
            if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] <= os_data.os_data.high_sierra:
                # Models dropped in Mojave also lost Audio support
                # Xserves and MacPro4,1 are exceptions
                # iMac7,1 and iMac8,1 require AppleHDA/IOAudioFamily downgrade
                if not (self.model.startswith("Xserve") or self.model in ["MacPro4,1", "iMac7,1", "iMac8,1"]):
                    if "nForce Chipset" in smbios_data.smbios_dictionary[self.model]:
                        hdef_path = "PciRoot(0x0)/Pci(0x8,0x0)"
                    else:
                        hdef_path = "PciRoot(0x0)/Pci(0x1b,0x0)"
                    # In AppleALC, MacPro3,1's original layout is already in use, forcing layout 13 instead
                    if self.model == "MacPro3,1":
                        self.config["DeviceProperties"]["Add"][hdef_path] = {
                            "apple-layout-id": 90,
                            "use-apple-layout-id": 1,
                            "alc-layout-id": 13,
                        }
                    else:
                        self.config["DeviceProperties"]["Add"][hdef_path] = {
                            "apple-layout-id": 90,
                            "use-apple-layout-id": 1,
                            "use-layout-id": 1,
                        }
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleALC.kext", self.constants.applealc_version, self.constants.applealc_path)
            elif (self.model.startswith("MacPro") and self.model != "MacPro6,1") or self.model.startswith("Xserve"):
                # Used to enable Audio support for non-standard dGPUs
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleALC.kext", self.constants.applealc_version, self.constants.applealc_path)

        # Due to regression in AppleALC 1.6.4+, temporarily use 1.6.3 and set override
        if support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleALC.kext")["Enabled"] is True:
            if "-lilubetaall" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"]:
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -lilubetaall"


    def _firmware_handling(self) -> None:
        """
        Firmware Handler
        """

        # Add UGA to GOP layer
        if "UGA Graphics" in smbios_data.smbios_dictionary[self.model]:
            logging.info("- Adding UGA to GOP Patch")
            self.config["UEFI"]["Output"]["GopPassThrough"] = "Apple"

        # GMUX handling
        if self.constants.software_demux is True and self.model in ["MacBookPro8,2", "MacBookPro8,3"]:
            logging.info("- Enabling software demux")
            # Add ACPI patches
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Add"], "Path", "SSDT-DGPU.aml")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Patch"], "Comment", "_INI to XINI")["Enabled"] = True
            shutil.copy(self.constants.demux_ssdt_path, self.constants.acpi_path)
            # Disable dGPU
            # IOACPIPlane:/_SB/PCI0@0/P0P2@10000/GFX0@0
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"] = {
                "class-code": binascii.unhexlify("FFFFFFFF"),
                "device-id": binascii.unhexlify("FFFF0000"),
                "IOName": "Dortania Disabled Card",
                "name": "Dortania Disabled Card"
            }
            self.config["DeviceProperties"]["Delete"]["PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"] = ["class-code", "device-id", "IOName", "name"]
            # Add AMDGPUWakeHandler
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AMDGPUWakeHandler.kext", self.constants.gpu_wake_version, self.constants.gpu_wake_path)

        if self.constants.dGPU_switch is True and "Switchable GPUs" in smbios_data.smbios_dictionary[self.model]:
            logging.info("- Allowing GMUX switching in Windows")
            self.config["Booter"]["Quirks"]["SignalAppleOS"] = True

        # Force Output support PC VBIOS on Mac Pros
        if self.constants.force_output_support is True:
            logging.info("- Forcing GOP Support")
            self.config["UEFI"]["Quirks"]["ForgeUefiSupport"] = True
            self.config["UEFI"]["Quirks"]["ReloadOptionRoms"] = True

        # AMD GOP VBIOS injection for AMD GCN 1-4 GPUs
        if self.constants.amd_gop_injection is True:
            logging.info("- Adding AMDGOP.efi")
            shutil.copy(self.constants.amd_gop_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("AMDGOP.efi", "UEFI", "Drivers")["Enabled"] = True

        # Nvidia Kepler GOP VBIOS injection
        if self.constants.nvidia_kepler_gop_injection is True:
            logging.info("- Adding NVGOP_GK.efi")
            shutil.copy(self.constants.nvidia_kepler_gop_driver_path, self.constants.drivers_path)
            support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("NVGOP_GK.efi", "UEFI", "Drivers")["Enabled"] = True


    def _spoof_handling(self) -> None:
        """
        SMBIOS Spoofing Handler
        """

        if self.constants.serial_settings == "None":
            return

        # AppleMuxControl Override
        if self.model == "MacBookPro9,1":
            logging.info("- Adding AppleMuxControl Override")
            amc_map_path = Path(self.constants.plist_folder_path) / Path("AppleMuxControl/Info.plist")
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"] = {"agdpmod": "vit9696"}
            Path(self.constants.amc_kext_folder).mkdir()
            Path(self.constants.amc_contents_folder).mkdir()
            shutil.copy(amc_map_path, self.constants.amc_contents_folder)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AMC-Override.kext")["Enabled"] = True

        if self.model not in model_array.NoAGPMSupport:
            logging.info("- Adding AppleGraphicsPowerManagement Override")
            agpm_map_path = Path(self.constants.plist_folder_path) / Path("AppleGraphicsPowerManagement/Info.plist")
            Path(self.constants.agpm_kext_folder).mkdir()
            Path(self.constants.agpm_contents_folder).mkdir()
            shutil.copy(agpm_map_path, self.constants.agpm_contents_folder)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AGPM-Override.kext")["Enabled"] = True

        if self.model in model_array.AGDPSupport:
            logging.info("- Adding AppleGraphicsDevicePolicy Override")
            agdp_map_path = Path(self.constants.plist_folder_path) / Path("AppleGraphicsDevicePolicy/Info.plist")
            Path(self.constants.agdp_kext_folder).mkdir()
            Path(self.constants.agdp_contents_folder).mkdir()
            shutil.copy(agdp_map_path, self.constants.agdp_contents_folder)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AGDP-Override.kext")["Enabled"] = True

        # AGPM Patch
        if self.model in model_array.DualGPUPatch:
            logging.info("- Adding dual GPU patch")
            if not self.constants.custom_model and self.computer.dgpu and self.computer.dgpu.pci_path:
                self.gfx0_path = self.computer.dgpu.pci_path
                logging.info(f"- Found GFX0 Device Path: {self.gfx0_path}")
            else:
                if not self.constants.custom_model:
                    logging.info("- Failed to find GFX0 Device path, falling back on known logic")
                self.gfx0_path = "PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)"

            if self.model in model_array.IntelNvidiaDRM and self.constants.drm_support is True:
                logging.info("- Prioritizing DRM support over Intel QuickSync")
                self.config["DeviceProperties"]["Add"][self.gfx0_path] = {"agdpmod": "vit9696", "shikigva": 256}
                self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x2,0x0)"] = {
                    "name": binascii.unhexlify("23646973706C6179"),
                    "IOName": "#display",
                    "class-code": binascii.unhexlify("FFFFFFFF"),
                }
            elif self.constants.serial_settings != "None":
                if self.gfx0_path not in self.config["DeviceProperties"]["Add"] or "agdpmod" not in self.config["DeviceProperties"]["Add"][self.gfx0_path]:
                    self.config["DeviceProperties"]["Add"][self.gfx0_path] = {"agdpmod": "vit9696"}

        if self.model.startswith("iMac14,1"):
            # Ensure that agdpmod is applied to iMac14,x with iGPU only
            self.config["DeviceProperties"]["Add"]["PciRoot(0x0)/Pci(0x2,0x0)"] = {"agdpmod": "vit9696"}


    def _imac_mxm_patching(self) -> None:
        """
        General iMac MXM Handler
        """

        self._backlight_path_detection()
        # Check GPU Vendor
        if self.constants.metal_build is True:
            logging.info("- Adding Metal GPU patches on request")
            if self.constants.imac_vendor == "AMD":
                self._amd_mxm_patch(self.gfx0_path)
            elif self.constants.imac_vendor == "Nvidia":
                self._nvidia_mxm_patch(self.gfx0_path)
            else:
                logging.info("- Failed to find vendor")
        elif not self.constants.custom_model and self.model in model_array.LegacyGPU and self.computer.dgpu:
            logging.info(f"- Detected dGPU: {utilities.friendly_hex(self.computer.dgpu.vendor_id)}:{utilities.friendly_hex(self.computer.dgpu.device_id)}")
            if self.computer.dgpu.arch in [
                device_probe.AMD.Archs.Legacy_GCN_7000,
                device_probe.AMD.Archs.Legacy_GCN_8000,
                device_probe.AMD.Archs.Legacy_GCN_9000,
                device_probe.AMD.Archs.Polaris,
                device_probe.AMD.Archs.Polaris_Spoof,
                device_probe.AMD.Archs.Vega,
                device_probe.AMD.Archs.Navi,
            ]:
                self._amd_mxm_patch(self.gfx0_path)
            elif self.computer.dgpu.arch == device_probe.NVIDIA.Archs.Kepler:
                self._nvidia_mxm_patch(self.gfx0_path)

    def _ioaccel_workaround(self) -> None:
        """
        Miscellaneous IOAccelerator Handler

        When MTL bundles are missing from disk, WindowServer will repeatedly crash
        This primarily occurs when installing an RSR update, where root is cleaned but AuxKC is not
        """

        gpu_archs = []
        if not self.constants.custom_model:
            gpu_archs = [gpu.arch for gpu in self.constants.computer.gpus]
        else:
            if self.model not in smbios_data.smbios_dictionary:
                return
            gpu_archs = smbios_data.smbios_dictionary[self.model]["Stock GPUs"]

        # Check if KDKless and KDK GPUs are present
        # We only want KDKless.kext if there are no KDK GPUs
        has_kdkless_gpu = False
        has_kdk_gpu = False
        for arch in gpu_archs:
            if arch in [
                device_probe.Intel.Archs.Ivy_Bridge,
                device_probe.Intel.Archs.Haswell,
                device_probe.Intel.Archs.Broadwell,
                device_probe.Intel.Archs.Skylake,
                device_probe.NVIDIA.Archs.Kepler,
            ]:
                has_kdkless_gpu = True

            # Non-Metal KDK
            if arch in [
                device_probe.NVIDIA.Archs.Tesla,
                device_probe.NVIDIA.Archs.Maxwell,
                device_probe.NVIDIA.Archs.Pascal,
                device_probe.AMD.Archs.TeraScale_1,
                device_probe.AMD.Archs.TeraScale_2,
                device_probe.Intel.Archs.Iron_Lake,
                device_probe.Intel.Archs.Sandy_Bridge,
            ]:
                has_kdk_gpu = True

            if arch in [
                # Metal KDK (always)
                device_probe.AMD.Archs.Legacy_GCN_7000,
                device_probe.AMD.Archs.Legacy_GCN_8000,
                device_probe.AMD.Archs.Legacy_GCN_9000,
            ]:
                has_kdk_gpu = True

            if arch in [
                # Metal KDK (pre-AVX2.0)
                device_probe.AMD.Archs.Polaris,
                device_probe.AMD.Archs.Polaris_Spoof,
                device_probe.AMD.Archs.Vega,
                device_probe.AMD.Archs.Navi,
            ]:
                if (
                    self.model == "MacBookPro13,3" or
                    smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value
                ):
                    # MacBookPro13,3 has AVX2.0 however the GPU has an unsupported framebuffer
                    has_kdk_gpu = True

        if has_kdkless_gpu is True and has_kdk_gpu is False:
            # KDKlessWorkaround is required for KDKless GPUs
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("KDKlessWorkaround.kext", self.constants.kdkless_version, self.constants.kdkless_path)
            return

        # KDKlessWorkaround supports disabling native AMD stack on Ventura for pre-AVX2.0 CPUs
        # Applicable for Polaris, Vega, Navi GPUs
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] > cpu_data.CPUGen.ivy_bridge.value:
            return
        for arch in gpu_archs:
            if arch in [
                device_probe.AMD.Archs.Polaris,
                device_probe.AMD.Archs.Polaris_Spoof,
                device_probe.AMD.Archs.Vega,
                device_probe.AMD.Archs.Navi,
            ]:
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("KDKlessWorkaround.kext", self.constants.kdkless_version, self.constants.kdkless_path)
                return


#misc.py:
"""
misc.py: Class for handling Misc Patches, invocation from build.py
"""

import shutil
import logging
import binascii

from pathlib import Path

from . import support

from .. import constants

from ..support import generate_smbios
from ..detections import device_probe

from ..datasets import (
    model_array,
    smbios_data,
    cpu_data,
    os_data
)


class BuildMiscellaneous:
    """
    Build Library for Miscellaneous Hardware and Software Support
xw
    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off Misc Build Process
        """

        self._feature_unlock_handling()
        self._restrict_events_handling()
        self._firewire_handling()
        self._topcase_handling()
        self._thunderbolt_handling()
        self._webcam_handling()
        self._usb_handling()
        self._debug_handling()
        self._cpu_friend_handling()
        self._general_oc_handling()
        self._t1_handling()


    def _feature_unlock_handling(self) -> None:
        """
        FeatureUnlock Handler
        """

        if self.constants.fu_status is False:
            return

        if not self.model in smbios_data.smbios_dictionary:
            return

        if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] >= os_data.os_data.sonoma:
            return

        support.BuildSupport(self.model, self.constants, self.config).enable_kext("FeatureUnlock.kext", self.constants.featureunlock_version, self.constants.featureunlock_path)
        if self.constants.fu_arguments is not None and self.constants.fu_arguments != "":
            logging.info(f"- Adding additional FeatureUnlock args: {self.constants.fu_arguments}")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += self.constants.fu_arguments


    def _restrict_events_handling(self) -> None:
        """
        RestrictEvents Handler
        """

        block_args = ",".join(self._re_generate_block_arguments())
        patch_args = ",".join(self._re_generate_patch_arguments())

        if block_args != "":
            logging.info(f"- Setting RestrictEvents block arguments: {block_args}")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("RestrictEvents.kext", self.constants.restrictevents_version, self.constants.restrictevents_path)
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["revblock"] = block_args

        if block_args != "" and patch_args == "":
            # Disable unneeded Userspace patching (cs_validate_page is quite expensive)
            patch_args = "none"

        if patch_args != "":
            logging.info(f"- Setting RestrictEvents patch arguments: {patch_args}")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("RestrictEvents.kext", self.constants.restrictevents_version, self.constants.restrictevents_path)
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["revpatch"] = patch_args

        if support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("RestrictEvents.kext")["Enabled"] is False:
            # Ensure this is done at the end so all previous RestrictEvents patches are applied
            # RestrictEvents and EFICheckDisabler will conflict if both are injected
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("EFICheckDisabler.kext", "", self.constants.efi_disabler_path)


    def _re_generate_block_arguments(self) -> list:
        """
        Generate RestrictEvents block arguments

        Returns:
            list: RestrictEvents block arguments
        """

        re_block_args = []

        # Resolve GMUX switching in Big Sur+
        if self.model in ["MacBookPro6,1", "MacBookPro6,2", "MacBookPro9,1", "MacBookPro10,1"]:
            re_block_args.append("gmux")

        # Resolve memory error reporting on MacPro7,1 SMBIOS
        if self.model in model_array.MacPro:
            logging.info("- Disabling memory error reporting")
            re_block_args.append("pcie")

        # Resolve mediaanalysisd crashing on 3802 GPUs
        # Applicable for systems that are the primary iCloud Photos library host, with large amounts of unprocessed faces
        if self.constants.disable_mediaanalysisd is True:
            logging.info("- Disabling mediaanalysisd")
            re_block_args.append("media")

        return re_block_args


    def _re_generate_patch_arguments(self) -> list:
        """
        Generate RestrictEvents patch arguments

        Returns:
            list: Patch arguments
        """

        re_patch_args = []

        # Alternative approach to the kern.hv_vmm_present patch
        # Dynamically sets the property to 1 if software update/installer is detected
        # Always enabled in installers/recovery environments
        if self.constants.allow_oc_everywhere is False and (self.constants.serial_settings == "None" or self.constants.secure_status is False):
            re_patch_args.append("sbvmm")

        # Resolve CoreGraphics.framework crashing on Ivy Bridge in macOS 13.3+
        # Ref: https://github.com/acidanthera/RestrictEvents/pull/12
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] == cpu_data.CPUGen.ivy_bridge.value:
            logging.info("- Fixing CoreGraphics support on Ivy Bridge")
            re_patch_args.append("f16c")

        return re_patch_args


    def _cpu_friend_handling(self) -> None:
        """
        CPUFriend Handler
        """

        if self.constants.allow_oc_everywhere is False and self.model not in ["iMac7,1", "Xserve2,1", "Dortania1,1"] and self.constants.disallow_cpufriend is False and self.constants.serial_settings != "None":
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("CPUFriend.kext", self.constants.cpufriend_version, self.constants.cpufriend_path)

            # CPUFriendDataProvider handling
            pp_map_path = Path(self.constants.platform_plugin_plist_path) / Path(f"{self.model}/Info.plist")
            if not pp_map_path.exists():
                raise Exception(f"{pp_map_path} does not exist!!! Please file an issue stating file is missing for {self.model}.")
            Path(self.constants.pp_kext_folder).mkdir()
            Path(self.constants.pp_contents_folder).mkdir()
            shutil.copy(pp_map_path, self.constants.pp_contents_folder)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("CPUFriendDataProvider.kext")["Enabled"] = True


    def _firewire_handling(self) -> None:
        """
        FireWire Handler
        """

        if self.constants.firewire_boot is False:
            return
        if generate_smbios.check_firewire(self.model) is False:
            return

        # Enable FireWire Boot Support
        # Applicable for both native FireWire and Thunderbolt to FireWire adapters
        logging.info("- Enabling FireWire Boot Support")
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("IOFireWireFamily.kext", self.constants.fw_kext, self.constants.fw_family_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("IOFireWireSBP2.kext", self.constants.fw_kext, self.constants.fw_sbp2_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("IOFireWireSerialBusProtocolTransport.kext", self.constants.fw_kext, self.constants.fw_bus_path)
        support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("IOFireWireFamily.kext/Contents/PlugIns/AppleFWOHCI.kext")["Enabled"] = True


    def _topcase_handling(self) -> None:
        """
        USB/SPI Top Case Handler
        """

        # macOS 14.4 Beta 1 strips SPI-based top case support for Broadwell through Kaby Lake MacBooks (and MacBookAir6,x)
        if self.model.startswith("MacBook") and self.model in smbios_data.smbios_dictionary:
            if self.model.startswith("MacBookAir6") or (cpu_data.CPUGen.broadwell <= smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.kaby_lake):
                logging.info("- Enabling SPI-based top case support")
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleHSSPISupport.kext", self.constants.apple_spi_version, self.constants.apple_spi_path)
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleHSSPIHIDDriver.kext", self.constants.apple_spi_hid_version, self.constants.apple_spi_hid_path)
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleTopCaseInjector.kext", self.constants.topcase_inj_version, self.constants.top_case_inj_path)


        #On-device probing
        if not self.constants.custom_model and self.computer.internal_keyboard_type and self.computer.trackpad_type:

            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBTopCase.kext", self.constants.topcase_version, self.constants.top_case_path)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCButtons.kext")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyEventDriver.kext")["Enabled"] = True

            if self.computer.internal_keyboard_type == "Legacy":
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("LegacyKeyboardInjector.kext", self.constants.legacy_keyboard, self.constants.legacy_keyboard_path)
            if self.computer.trackpad_type == "Legacy":
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBTrackpad.kext", self.constants.apple_trackpad, self.constants.apple_trackpad_path)
            elif self.computer.trackpad_type == "Modern":
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBMultitouch.kext", self.constants.multitouch_version, self.constants.multitouch_path)

        #Predefined fallback
        else:
            # Multi Touch Top Case support for macOS Ventura+
            if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.skylake.value:
                if self.model.startswith("MacBook"):
                    # These units got the Force Touch top case, so ignore them
                    if self.model not in ["MacBookPro11,4", "MacBookPro11,5", "MacBookPro12,1", "MacBook8,1"]:
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBTopCase.kext", self.constants.topcase_version, self.constants.top_case_path)
                        support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCButtons.kext")["Enabled"] = True
                        support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyboard.kext")["Enabled"] = True
                        support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("AppleUSBTopCase.kext/Contents/PlugIns/AppleUSBTCKeyEventDriver.kext")["Enabled"] = True
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBMultitouch.kext", self.constants.multitouch_version, self.constants.multitouch_path)

            # Two-finger Top Case support for macOS High Sierra+
            if self.model == "MacBook5,2":
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleUSBTrackpad.kext", self.constants.apple_trackpad, self.constants.apple_trackpad_path) # Also requires AppleUSBTopCase.kext
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("LegacyKeyboardInjector.kext", self.constants.legacy_keyboard, self.constants.legacy_keyboard_path) # Inject legacy personalities into AppleUSBTCKeyboard and AppleUSBTCKeyEventDriver


    def _thunderbolt_handling(self) -> None:
        """
        Thunderbolt Handler
        """

        if self.constants.disable_tb is True and self.model in ["MacBookPro11,1", "MacBookPro11,2", "MacBookPro11,3", "MacBookPro11,4", "MacBookPro11,5"]:
            logging.info("- Disabling 2013-2014 laptop Thunderbolt Controller")
            if self.model in ["MacBookPro11,3", "MacBookPro11,5"]:
                # 15" dGPU models: IOACPIPlane:/_SB/PCI0@0/PEG1@10001/UPSB@0/DSB0@0/NHI0@0
                tb_device_path = "PciRoot(0x0)/Pci(0x1,0x1)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)"
            else:
                # 13" and 15" iGPU 2013-2014 models: IOACPIPlane:/_SB/PCI0@0/P0P2@10000/UPSB@0/DSB0@0/NHI0@0
                tb_device_path = "PciRoot(0x0)/Pci(0x1,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)/Pci(0x0,0x0)"

            self.config["DeviceProperties"]["Add"][tb_device_path] = {"class-code": binascii.unhexlify("FFFFFFFF"), "device-id": binascii.unhexlify("FFFF0000")}


    def _webcam_handling(self) -> None:
        """
        iSight Handler
        """
        if self.model in smbios_data.smbios_dictionary:
            if "Legacy iSight" in smbios_data.smbios_dictionary[self.model]:
                if smbios_data.smbios_dictionary[self.model]["Legacy iSight"] is True:
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("LegacyUSBVideoSupport.kext", self.constants.apple_isight_version, self.constants.apple_isight_path)

        if not self.constants.custom_model:
            if self.constants.computer.pcie_webcam is True:
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleCameraInterface.kext", self.constants.apple_camera_version, self.constants.apple_camera_path)
        else:
            if self.model.startswith("MacBook") and self.model in smbios_data.smbios_dictionary:
                if cpu_data.CPUGen.haswell <= smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.kaby_lake:
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleCameraInterface.kext", self.constants.apple_camera_version, self.constants.apple_camera_path)


    def _usb_handling(self) -> None:
        """
        USB Handler
        """

        # USB Map
        usb_map_path = Path(self.constants.plist_folder_path) / Path("AppleUSBMaps/Info.plist")
        if (
            usb_map_path.exists()
            and (self.constants.allow_oc_everywhere is False or self.constants.allow_native_spoofs is True)
            and self.model not in ["Xserve2,1", "Dortania1,1"]
            and (
                (self.model in model_array.Missing_USB_Map or self.model in model_array.Missing_USB_Map_Ventura)
                or self.constants.serial_settings in ["Moderate", "Advanced"])
        ):
            logging.info("- Adding USB-Map.kext")
            Path(self.constants.map_kext_folder).mkdir()
            Path(self.constants.map_contents_folder).mkdir()
            shutil.copy(usb_map_path, self.constants.map_contents_folder)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB-Map.kext")["Enabled"] = True
            if self.model in model_array.Missing_USB_Map_Ventura and self.constants.serial_settings not in ["Moderate", "Advanced"]:
                support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB-Map.kext")["MinKernel"] = "22.0.0"

        # Add UHCI/OHCI drivers
        # All Penryn Macs lack an internal USB hub to route USB 1.1 devices to the EHCI controller
        # And MacPro4,1, MacPro5,1 and Xserve3,1 are the only post-Penryn Macs that lack an internal USB hub
        # - Ref: https://techcommunity.microsoft.com/t5/microsoft-usb-blog/reasons-to-avoid-companion-controllers/ba-p/270710
        #
        # To be paired for usb11.py's 'Legacy USB 1.1' patchset
        #
        # Note: With macOS 14.1, injection of these kexts causes a panic.
        #       To avoid this, a MaxKernel is configured with XNU 23.0.0 (macOS 14.0).
        #       Additionally sys_patch.py stack will now patches the bins onto disk for 14.1+.
        #       Reason for keeping the dual logic is due to potential conflicts of in-cache vs injection if we start
        #       patching pre-14.1 hosts.
        if (
            smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.penryn.value or \
            self.model in ["MacPro4,1", "MacPro5,1", "Xserve3,1"]
        ):
            logging.info("- Adding UHCI/OHCI USB support")
            shutil.copy(self.constants.apple_usb_11_injector_path, self.constants.kexts_path)
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB1.1-Injector.kext/Contents/PlugIns/AppleUSBOHCI.kext")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB1.1-Injector.kext/Contents/PlugIns/AppleUSBOHCIPCI.kext")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB1.1-Injector.kext/Contents/PlugIns/AppleUSBUHCI.kext")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("USB1.1-Injector.kext/Contents/PlugIns/AppleUSBUHCIPCI.kext")["Enabled"] = True


    def _debug_handling(self) -> None:
        """
        Debug Handler for OpenCorePkg and Kernel Space
        """

        if self.constants.verbose_debug is True:
            logging.info("- Enabling Verbose boot")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -v"

        if self.constants.kext_debug is True:
            logging.info("- Enabling DEBUG Kexts")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -liludbgall liludump=90"
            # Disabled due to macOS Monterey crashing shortly after kernel init
            # Use DebugEnhancer.kext instead
            # self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " msgbuf=1048576"
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("DebugEnhancer.kext", self.constants.debugenhancer_version, self.constants.debugenhancer_path)

        if self.constants.opencore_debug is True:
            logging.info("- Enabling DEBUG OpenCore")
            self.config["Misc"]["Debug"]["Target"] = 0x43
            self.config["Misc"]["Debug"]["DisplayLevel"] = 0x80000042


    def _general_oc_handling(self) -> None:
        """
        General OpenCorePkg Handler
        """

        logging.info("- Adding OpenCanopy GUI")
        shutil.copy(self.constants.gui_path, self.constants.oc_folder)
        support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("OpenCanopy.efi", "UEFI", "Drivers")["Enabled"] = True
        support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("OpenRuntime.efi", "UEFI", "Drivers")["Enabled"] = True
        support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("OpenLinuxBoot.efi", "UEFI", "Drivers")["Enabled"] = True
        support.BuildSupport(self.model, self.constants, self.config).get_efi_binary_by_path("ResetNvramEntry.efi", "UEFI", "Drivers")["Enabled"] = True

        if self.constants.showpicker is False:
            logging.info("- Hiding OpenCore picker")
            self.config["Misc"]["Boot"]["ShowPicker"] = False

        if self.constants.oc_timeout != 5:
            logging.info(f"- Setting custom OpenCore picker timeout to {self.constants.oc_timeout} seconds")
            self.config["Misc"]["Boot"]["Timeout"] = self.constants.oc_timeout

        if self.constants.vault is True:
            logging.info("- Setting Vault configuration")
            self.config["Misc"]["Security"]["Vault"] = "Secure"

    def _t1_handling(self) -> None:
        """
        T1 Security Chip Handler
        """
        if self.model not in ["MacBookPro13,2", "MacBookPro13,3", "MacBookPro14,2", "MacBookPro14,3"]:
            return

        logging.info("- Enabling T1 Security Chip support")

        support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Block"], "Identifier", "com.apple.driver.AppleSSE")["Enabled"] = True
        support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Block"], "Identifier", "com.apple.driver.AppleKeyStore")["Enabled"] = True
        support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Block"], "Identifier", "com.apple.driver.AppleCredentialManager")["Enabled"] = True

        support.BuildSupport(self.model, self.constants, self.config).enable_kext("corecrypto_T1.kext", self.constants.t1_corecrypto_version, self.constants.t1_corecrypto_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleSSE.kext", self.constants.t1_sse_version, self.constants.t1_sse_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleKeyStore.kext", self.constants.t1_key_store_version, self.constants.t1_key_store_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleCredentialManager.kext", self.constants.t1_credential_version, self.constants.t1_credential_path)
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("KernelRelayHost.kext", self.constants.kernel_relay_version, self.constants.kernel_relay_path)

#Networking: wired.py:
"""
wired.py: Class for handling Wired Networking Patches, invocation from build.py
"""

from .. import support

from ... import constants

from ...detections import device_probe

from ...datasets import (
    smbios_data,
    cpu_data,
    os_data
)


class BuildWiredNetworking:
    """
    Build Library for Wired Networking Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off Wired Build Process
        """

        # Check if Ethernet was detected, otherwise fall back to assumptions (mainly for 2011 MacBook Airs and TB Ethernet)
        if not self.constants.custom_model and self.constants.computer.ethernet:
            self._on_model()
        else:
            self._prebuilt_assumption()

        # Always enable due to chance of hot-plugging
        self._usb_ecm_dongles()
        self._i210_handling()


    def _usb_ecm_dongles(self) -> None:
        """
        USB ECM Dongle Handling
        """
        # With Sonoma, our WiFi patches require downgrading IOSkywalk
        # Unfortunately Apple's DriverKit stack uses IOSkywalk for ECM dongles, so we'll need force load
        # the kernel driver to prevent a kernel panic
        # - DriverKit: com.apple.DriverKit.AppleUserECM.dext
        # - Kext: AppleUSBECM.kext
        if not self.model in smbios_data.smbios_dictionary:
            return
        if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] >= os_data.os_data.sonoma:
            return

        support.BuildSupport(self.model, self.constants, self.config).enable_kext("ECM-Override.kext", self.constants.ecm_override_version, self.constants.ecm_override_path)


    def _i210_handling(self) -> None:
        """
        PCIe i210 NIC Handling
        """
        # i210 NICs are broke in macOS 14 due to driver kit downgrades
        # See ECM logic for why it's always enabled
        if not self.model in smbios_data.smbios_dictionary:
            return
        if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] >= os_data.os_data.sonoma:
            return
        support.BuildSupport(self.model, self.constants, self.config).enable_kext("CatalinaIntelI210Ethernet.kext", self.constants.i210_version, self.constants.i210_path)
        # Ivy Bridge and newer natively support DriverKit, so set MinKernel to 23.0.0
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] >= cpu_data.CPUGen.ivy_bridge.value:
            support.BuildSupport(self.model, self.constants, self.config).get_kext_by_bundle_path("CatalinaIntelI210Ethernet.kext")["MinKernel"] = "23.0.0"


    def _on_model(self) -> None:
        """
        On-Model Hardware Detection Handling
        """

        for controller in self.constants.computer.ethernet:
            if isinstance(controller, device_probe.BroadcomEthernet) and controller.chipset == device_probe.BroadcomEthernet.Chipsets.AppleBCM5701Ethernet:
                if not self.model in smbios_data.smbios_dictionary:
                    continue
                if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                    # Required due to Big Sur's BCM5701 requiring VT-D support
                    # Applicable for pre-Ivy Bridge models
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("CatalinaBCM5701Ethernet.kext", self.constants.bcm570_version, self.constants.bcm570_path)
            elif isinstance(controller, device_probe.IntelEthernet):
                if not self.model in smbios_data.smbios_dictionary:
                    continue
                if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                    # Apple's IOSkywalkFamily in DriverKit requires VT-D support
                    # Applicable for pre-Ivy Bridge models
                    if controller.chipset == device_probe.IntelEthernet.Chipsets.AppleIntelI210Ethernet:
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("CatalinaIntelI210Ethernet.kext", self.constants.i210_version, self.constants.i210_path)
                    elif controller.chipset == device_probe.IntelEthernet.Chipsets.AppleIntel8254XEthernet:
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleIntel8254XEthernet.kext", self.constants.intel_8254x_version, self.constants.intel_8254x_path)
                    elif controller.chipset == device_probe.IntelEthernet.Chipsets.Intel82574L:
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("Intel82574L.kext", self.constants.intel_82574l_version, self.constants.intel_82574l_path)
            elif isinstance(controller, device_probe.NVIDIAEthernet):
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("nForceEthernet.kext", self.constants.nforce_version, self.constants.nforce_path)
            elif isinstance(controller, device_probe.Marvell) or isinstance(controller, device_probe.SysKonnect):
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("MarvelYukonEthernet.kext", self.constants.marvel_version, self.constants.marvel_path)

            # Pre-Ivy Bridge Aquantia Ethernet Patch
            if isinstance(controller, device_probe.Aquantia) and controller.chipset == device_probe.Aquantia.Chipsets.AppleEthernetAquantiaAqtion:
                if not self.model in smbios_data.smbios_dictionary:
                    continue
                if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleEthernetAbuantiaAqtion.kext", self.constants.aquantia_version, self.constants.aquantia_path)


    def _prebuilt_assumption(self) -> None:
        """
        Fall back to pre-built assumptions
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "Ethernet Chipset" in smbios_data.smbios_dictionary[self.model]:
            return

        if smbios_data.smbios_dictionary[self.model]["Ethernet Chipset"] == "Broadcom":
            if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                # Required due to Big Sur's BCM5701 requiring VT-D support
                # Applicable for pre-Ivy Bridge models
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("CatalinaBCM5701Ethernet.kext", self.constants.bcm570_version, self.constants.bcm570_path)
        elif smbios_data.smbios_dictionary[self.model]["Ethernet Chipset"] == "Nvidia":
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("nForceEthernet.kext", self.constants.nforce_version, self.constants.nforce_path)
        elif smbios_data.smbios_dictionary[self.model]["Ethernet Chipset"] == "Marvell":
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("MarvelYukonEthernet.kext", self.constants.marvel_version, self.constants.marvel_path)
        elif smbios_data.smbios_dictionary[self.model]["Ethernet Chipset"] == "Intel 80003ES2LAN":
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleIntel8254XEthernet.kext", self.constants.intel_8254x_version, self.constants.intel_8254x_path)
        elif smbios_data.smbios_dictionary[self.model]["Ethernet Chipset"] == "Intel 82574L":
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("Intel82574L.kext", self.constants.intel_82574l_version, self.constants.intel_82574l_path)

#security.py:
"""
security.py: Class for handling macOS Security Patches, invocation from build.py
"""

import logging
import binascii

from . import support

from .. import constants

from ..support import utilities
from ..detections import device_probe

from ..datasets import (
    smbios_data,
    os_data
)


class BuildSecurity:
    """
    Build Library for Security Patch Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off Security Build Process
        """

        if self.constants.sip_status is False or self.constants.custom_sip_value:
            # Work-around 12.3 bug where Electron apps no longer launch with SIP lowered
            # Unknown whether this is intended behavior or not, revisit with 12.4
            logging.info("- Adding ipc_control_port_options=0 to boot-args")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " ipc_control_port_options=0"
            # Adds AutoPkgInstaller for Automatic OpenCore-Patcher installation
            # Only install if running the GUI (AutoPkg-Assets.pkg requires the GUI)
            if self.constants.wxpython_variant is True:
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("AutoPkgInstaller.kext", self.constants.autopkg_version, self.constants.autopkg_path)
            if self.constants.custom_sip_value:
                logging.info(f"- Setting SIP value to: {self.constants.custom_sip_value}")
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["csr-active-config"] = utilities.string_to_hex(self.constants.custom_sip_value.lstrip("0x"))
            elif self.constants.sip_status is False:
                logging.info("- Set SIP to allow Root Volume patching")
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["csr-active-config"] = binascii.unhexlify("03080000")

            # apfs.kext has an undocumented boot-arg that allows FileVault usage on broken APFS seals (-arv_allow_fv)
            # This is however hidden behind kern.development, thus we patch _apfs_filevault_allowed to always return true
            # Note this function was added in 11.3 (20E232, 20.4), older builds do not support this (ie. 11.2.3)
            logging.info("- Allowing FileVault on Root Patched systems")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "Force FileVault on Broken Seal")["Enabled"] = True
            # Lets us check in sys_patch.py if config supports FileVault
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Settings"] += " -allow_fv"

            # Patch KC UUID panics due to RSR installation
            # - Ref: https://github.com/dortania/OpenCore-Legacy-Patcher/issues/1019
            logging.info("- Enabling KC UUID mismatch patch")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -nokcmismatchpanic"
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("RSRHelper.kext", self.constants.rsrhelper_version, self.constants.rsrhelper_path)

        if self.constants.disable_cs_lv is True:
            # In Ventura, LV patch broke. For now, add AMFI arg
            # Before merging into mainline, this needs to be resolved
            if self.constants.disable_amfi is True:
                logging.info("- Disabling AMFI")
                self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " amfi=0x80"
            else:
                logging.info("- Disabling Library Validation")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "Disable Library Validation Enforcement")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Comment", "Disable _csr_check() in _vnode_check_signature")["Enabled"] = True
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Settings"] += " -allow_amfi"
            # CSLVFixup simply patches out __RESTRICT and __restrict out of the Music.app Binary
            # Ref: https://pewpewthespells.com/blog/blocking_code_injection_on_ios_and_os_x.html
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("CSLVFixup.kext", self.constants.cslvfixup_version, self.constants.cslvfixup_path)

        if self.constants.secure_status is False:
            logging.info("- Disabling SecureBootModel")
            self.config["Misc"]["Security"]["SecureBootModel"] = "Disabled"

        if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] < os_data.os_data.sonoma:
            logging.info("- Enabling AMFIPass")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AMFIPass.kext", self.constants.amfipass_version, self.constants.amfipass_path)


#smbios.py:
"""
smbios.py: Class for handling SMBIOS Patches, invocation from build.py
"""

import ast
import uuid
import logging
import binascii
import plistlib
import subprocess

from pathlib import Path

from . import support

from .. import constants

from ..support import (
    utilities,
    generate_smbios
)
from ..datasets import (
    smbios_data,
    cpu_data,
    model_array
)


class BuildSMBIOS:
    """
    Build Library for SMBIOS Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants

        self._build()


    def _build(self) -> None:
        """
        Kick off SMBIOS Build Process
        """

        if self.constants.allow_oc_everywhere is False or self.constants.allow_native_spoofs is True:
            if self.constants.serial_settings == "None":
                # Credit to Parrotgeek1 for boot.efi and hv_vmm_present patch sets
                logging.info("- Enabling Board ID exemption patch")
                support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Booter"]["Patch"], "Comment", "Skip Board ID check")["Enabled"] = True

            else:
                logging.info("- Enabling SMC exemption patch")
                support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["Kernel"]["Patch"], "Identifier", "com.apple.driver.AppleSMC")["Enabled"] = True
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("SMC-Spoof.kext", self.constants.smcspoof_version, self.constants.smcspoof_path)

        if self.constants.serial_settings in ["Moderate", "Advanced"]:
            logging.info("- Enabling USB Rename Patches")
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Patch"], "Comment", "XHC1 to SHC1")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Patch"], "Comment", "EHC1 to EH01")["Enabled"] = True
            support.BuildSupport(self.model, self.constants, self.config).get_item_by_kv(self.config["ACPI"]["Patch"], "Comment", "EHC2 to EH02")["Enabled"] = True

        if self.model == self.constants.override_smbios:
            logging.info("- Adding -no_compat_check")
            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -no_compat_check"


    def set_smbios(self) -> None:
        """
        SMBIOS Handler
        """

        spoofed_model = self.model

        if self.constants.override_smbios == "Default":
            if self.constants.serial_settings != "None":
                logging.info("- Setting macOS Monterey Supported SMBIOS")
                if self.constants.allow_native_spoofs is True:
                    spoofed_model = self.model
                else:
                    spoofed_model = generate_smbios.set_smbios_model_spoof(self.model)
        else:
            spoofed_model = self.constants.override_smbios
        logging.info(f"- Using Model ID: {spoofed_model}")

        spoofed_board = ""
        if spoofed_model in smbios_data.smbios_dictionary:
            if "Board ID" in smbios_data.smbios_dictionary[spoofed_model]:
                spoofed_board = smbios_data.smbios_dictionary[spoofed_model]["Board ID"]
        logging.info(f"- Using Board ID: {spoofed_board}")

        self.spoofed_model = spoofed_model
        self.spoofed_board = spoofed_board

        if self.constants.allow_oc_everywhere is False or self.constants.allow_native_spoofs is True:
            self.config["#Revision"]["Spoofed-Model"] = f"{self.spoofed_model} - {self.constants.serial_settings}"

        if self.constants.serial_settings == "Moderate":
            logging.info("- Using Moderate SMBIOS patching")
            self._moderate_serial_patch()
        elif self.constants.serial_settings == "Advanced":
            logging.info("- Using Advanced SMBIOS patching")
            self._advanced_serial_patch()
        elif self.constants.serial_settings == "Minimal":
            logging.info("- Using Minimal SMBIOS patching")
            self.spoofed_model = self.model
            self._minimal_serial_patch()
        else:
            # Update DataHub to resolve Lilu Race Condition
            # macOS Monterey will sometimes not present the boardIdentifier in the DeviceTree on UEFI 1.2 or older Mac,
            # Thus resulting in an infinite loop as Lilu tries to request the Board ID
            # To resolve this, set PlatformInfo -> DataHub -> BoardProduct and enable UpdateDataHub

            # Note 1: Only apply if system is UEFI 1.2, this is generally Ivy Bridge and older
            # Note 2: Flipping 'UEFI -> ProtocolOverrides -> DataHub' will break hibernation
            if (smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.ivy_bridge.value and self.model):
                logging.info("- Detected UEFI 1.2 or older Mac, updating BoardProduct")
                self.config["PlatformInfo"]["DataHub"]["BoardProduct"] = self.spoofed_board
                self.config["PlatformInfo"]["UpdateDataHub"] = True

            if self.constants.custom_serial_number != "" and self.constants.custom_board_serial_number != "":
                logging.info("- Adding custom serial numbers")
                self.config["PlatformInfo"]["Automatic"] = True
                self.config["PlatformInfo"]["UpdateDataHub"] = True
                self.config["PlatformInfo"]["UpdateNVRAM"] = True
                self.config["PlatformInfo"]["UpdateSMBIOS"] = True
                self.config["UEFI"]["ProtocolOverrides"]["DataHub"] = True
                self.config["PlatformInfo"]["Generic"]["SystemSerialNumber"] = self.constants.custom_serial_number
                self.config["PlatformInfo"]["Generic"]["MLB"] = self.constants.custom_board_serial_number
                self.config["PlatformInfo"]["Generic"]["MaxBIOSVersion"] = False
                self.config["PlatformInfo"]["Generic"]["SystemProductName"] = self.spoofed_model
                self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-SN"] = self.constants.custom_serial_number
                self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-MLB"] = self.constants.custom_board_serial_number

        # USB Map and CPUFriend Patching
        if (
            self.constants.allow_oc_everywhere is False
            and self.model not in ["Xserve2,1", "Dortania1,1"]
            and ((self.model in model_array.Missing_USB_Map or self.model in model_array.Missing_USB_Map_Ventura) or self.constants.serial_settings in ["Moderate", "Advanced"])
        ):
            new_map_ls = Path(self.constants.map_contents_folder) / Path("Info.plist")
            map_config = plistlib.load(Path(new_map_ls).open("rb"))
            # Strip unused USB maps
            for entry in list(map_config["IOKitPersonalities_x86_64"]):
                if not entry.startswith(self.model):
                    map_config["IOKitPersonalities_x86_64"].pop(entry)
                else:
                    try:
                        map_config["IOKitPersonalities_x86_64"][entry]["model"] = self.spoofed_model
                        if self.constants.serial_settings in ["Minimal", "None"]:
                            if map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] == "EH01":
                                map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] = "EHC1"
                            if map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] == "EH02":
                                map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] = "EHC2"
                            if map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] == "SHC1":
                                map_config["IOKitPersonalities_x86_64"][entry]["IONameMatch"] = "XHC1"
                    except KeyError:
                        continue
            plistlib.dump(map_config, Path(new_map_ls).open("wb"), sort_keys=True)
        if self.constants.allow_oc_everywhere is False and self.model not in ["iMac7,1", "Xserve2,1", "Dortania1,1"] and self.constants.disallow_cpufriend is False and self.constants.serial_settings != "None":
            # Adjust CPU Friend Data to correct SMBIOS
            new_cpu_ls = Path(self.constants.pp_contents_folder) / Path("Info.plist")
            cpu_config = plistlib.load(Path(new_cpu_ls).open("rb"))
            string_stuff = str(cpu_config["IOKitPersonalities"]["CPUFriendDataProvider"]["cf-frequency-data"])
            string_stuff = string_stuff.replace(self.model, self.spoofed_model)
            string_stuff = ast.literal_eval(string_stuff)
            cpu_config["IOKitPersonalities"]["CPUFriendDataProvider"]["cf-frequency-data"] = string_stuff
            plistlib.dump(cpu_config, Path(new_cpu_ls).open("wb"), sort_keys=True)

        if self.constants.allow_oc_everywhere is False and self.constants.serial_settings != "None":
            if self.model == "MacBookPro9,1":
                new_amc_ls = Path(self.constants.amc_contents_folder) / Path("Info.plist")
                amc_config = plistlib.load(Path(new_amc_ls).open("rb"))
                amc_config["IOKitPersonalities"]["AppleMuxControl"]["ConfigMap"][self.spoofed_board] = amc_config["IOKitPersonalities"]["AppleMuxControl"]["ConfigMap"].pop(self.model)
                for entry in list(amc_config["IOKitPersonalities"]["AppleMuxControl"]["ConfigMap"]):
                    if not entry.startswith(self.spoofed_board):
                        amc_config["IOKitPersonalities"]["AppleMuxControl"]["ConfigMap"].pop(entry)
                plistlib.dump(amc_config, Path(new_amc_ls).open("wb"), sort_keys=True)
            if self.model not in model_array.NoAGPMSupport:
                new_agpm_ls = Path(self.constants.agpm_contents_folder) / Path("Info.plist")
                agpm_config = plistlib.load(Path(new_agpm_ls).open("rb"))
                agpm_config["IOKitPersonalities"]["AGPM"]["Machines"][self.spoofed_board] = agpm_config["IOKitPersonalities"]["AGPM"]["Machines"].pop(self.model)
                if self.model == "MacBookPro6,2":
                    # Force G State to not exceed moderate state
                    # Ref: https://github.com/fabioiop/MBP-2010-GPU-Panic-fix
                    logging.info("- Patching G State for MacBookPro6,2")
                    for gpu in ["Vendor10deDevice0a34", "Vendor10deDevice0a29"]:
                        agpm_config["IOKitPersonalities"]["AGPM"]["Machines"][self.spoofed_board][gpu]["BoostPState"] = [2, 2, 2, 2]
                        agpm_config["IOKitPersonalities"]["AGPM"]["Machines"][self.spoofed_board][gpu]["BoostTime"] = [2, 2, 2, 2]

                for entry in list(agpm_config["IOKitPersonalities"]["AGPM"]["Machines"]):
                    if not entry.startswith(self.spoofed_board):
                        agpm_config["IOKitPersonalities"]["AGPM"]["Machines"].pop(entry)

                plistlib.dump(agpm_config, Path(new_agpm_ls).open("wb"), sort_keys=True)
            if self.model in model_array.AGDPSupport:
                new_agdp_ls = Path(self.constants.agdp_contents_folder) / Path("Info.plist")
                agdp_config = plistlib.load(Path(new_agdp_ls).open("rb"))
                agdp_config["IOKitPersonalities"]["AppleGraphicsDevicePolicy"]["ConfigMap"][self.spoofed_board] = agdp_config["IOKitPersonalities"]["AppleGraphicsDevicePolicy"]["ConfigMap"].pop(
                    self.model
                )
                for entry in list(agdp_config["IOKitPersonalities"]["AppleGraphicsDevicePolicy"]["ConfigMap"]):
                    if not entry.startswith(self.spoofed_board):
                        agdp_config["IOKitPersonalities"]["AppleGraphicsDevicePolicy"]["ConfigMap"].pop(entry)
                plistlib.dump(agdp_config, Path(new_agdp_ls).open("wb"), sort_keys=True)


    def _minimal_serial_patch(self) -> None:
        """
        Minimal SMBIOS Spoofing Handler

        This function will only spoof the following:
        - Board ID
        - Firmware Features
        - BIOS Version
        - Serial Numbers (if override requested)
        """

        # Generate Firmware Features
        fw_feature = generate_smbios.generate_fw_features(self.model, self.constants.custom_model)
        # fw_feature = self.patch_firmware_feature()
        fw_feature = hex(fw_feature).lstrip("0x").rstrip("L").strip()
        logging.info(f"- Setting Firmware Feature: {fw_feature}")
        fw_feature = utilities.string_to_hex(fw_feature)

        # FirmwareFeatures
        self.config["PlatformInfo"]["PlatformNVRAM"]["FirmwareFeatures"] = fw_feature
        self.config["PlatformInfo"]["PlatformNVRAM"]["FirmwareFeaturesMask"] = fw_feature
        self.config["PlatformInfo"]["SMBIOS"]["FirmwareFeatures"] = fw_feature
        self.config["PlatformInfo"]["SMBIOS"]["FirmwareFeaturesMask"] = fw_feature

        # Board ID
        self.config["PlatformInfo"]["DataHub"]["BoardProduct"] = self.spoofed_board
        self.config["PlatformInfo"]["PlatformNVRAM"]["BID"] = self.spoofed_board
        self.config["PlatformInfo"]["SMBIOS"]["BoardProduct"] = self.spoofed_board

        # Model (ensures tables are not mismatched, even if we're not spoofing)
        self.config["PlatformInfo"]["DataHub"]["SystemProductName"] = self.model
        self.config["PlatformInfo"]["SMBIOS"]["SystemProductName"] = self.model
        self.config["PlatformInfo"]["SMBIOS"]["BoardVersion"] = self.model

        # Avoid incorrect Firmware Updates
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["run-efi-updater"] = "No"
        self.config["PlatformInfo"]["SMBIOS"]["BIOSVersion"] = "9999.999.999.999.999"

        # Update tables
        self.config["PlatformInfo"]["UpdateNVRAM"] = True
        self.config["PlatformInfo"]["UpdateSMBIOS"] = True
        self.config["PlatformInfo"]["UpdateDataHub"] = True

        if self.constants.custom_serial_number != "" and self.constants.custom_board_serial_number != "":
            logging.info("- Adding custom serial numbers")
            sn = self.constants.custom_serial_number
            mlb = self.constants.custom_board_serial_number

            # Serial Number
            self.config["PlatformInfo"]["SMBIOS"]["ChassisSerialNumber"] = sn
            self.config["PlatformInfo"]["SMBIOS"]["SystemSerialNumber"] = sn
            self.config["PlatformInfo"]["DataHub"]["SystemSerialNumber"] = sn
            self.config["PlatformInfo"]["PlatformNVRAM"]["SystemSerialNumber"] = sn
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-SN"] = sn

            # Board Serial Number
            self.config["PlatformInfo"]["SMBIOS"]["BoardSerialNumber"] = mlb
            self.config["PlatformInfo"]["PlatformNVRAM"]["BoardSerialNumber"] = mlb
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-MLB"] = mlb


    def _moderate_serial_patch(self) -> None:
        """
        Moderate SMBIOS Spoofing Handler

        Implements a full SMBIOS replacement, however retains original serial numbers (unless override requested)
        """

        if self.constants.custom_serial_number != "" and self.constants.custom_board_serial_number != "":
            logging.info("- Adding custom serial numbers")
            self.config["PlatformInfo"]["Generic"]["SystemSerialNumber"] = self.constants.custom_serial_number
            self.config["PlatformInfo"]["Generic"]["MLB"] = self.constants.custom_board_serial_number
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-SN"] = self.constants.custom_serial_number
            self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-MLB"] = self.constants.custom_board_serial_number
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["run-efi-updater"] = "No"
        self.config["PlatformInfo"]["Automatic"] = True
        self.config["PlatformInfo"]["UpdateDataHub"] = True
        self.config["PlatformInfo"]["UpdateNVRAM"] = True
        self.config["PlatformInfo"]["UpdateSMBIOS"] = True
        self.config["UEFI"]["ProtocolOverrides"]["DataHub"] = True
        self.config["PlatformInfo"]["Generic"]["SystemProductName"] = self.spoofed_model


    def _advanced_serial_patch(self) -> None:
        """
        Advanced SMBIOS Spoofing Handler

        Implements a full SMBIOS replacement, including serial numbers
        """

        if self.constants.custom_serial_number == "" or self.constants.custom_board_serial_number == "":
            macserial_output = subprocess.run([self.constants.macserial_path, "--generate", "--model", self.spoofed_model, "--num", "1"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            macserial_output = macserial_output.stdout.decode().strip().split(" | ")
            sn = macserial_output[0]
            mlb = macserial_output[1]
        else:
            sn = self.constants.custom_serial_number
            mlb = self.constants.custom_board_serial_number
        self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["run-efi-updater"] = "No"
        self.config["PlatformInfo"]["Automatic"] = True
        self.config["PlatformInfo"]["UpdateDataHub"] = True
        self.config["PlatformInfo"]["UpdateNVRAM"] = True
        self.config["PlatformInfo"]["UpdateSMBIOS"] = True
        self.config["UEFI"]["ProtocolOverrides"]["DataHub"] = True
        self.config["PlatformInfo"]["Generic"]["ROM"] = binascii.unhexlify("0016CB445566")
        self.config["PlatformInfo"]["Generic"]["SystemProductName"] = self.spoofed_model
        self.config["PlatformInfo"]["Generic"]["SystemSerialNumber"] = sn
        self.config["PlatformInfo"]["Generic"]["MLB"] = mlb
        self.config["PlatformInfo"]["Generic"]["SystemUUID"] = str(uuid.uuid4()).upper()
        self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-SN"] = sn
        self.config["NVRAM"]["Add"]["4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102"]["OCLP-Spoofed-MLB"] = mlb


#storage.py:
"""
storage.py: Class for handling Storage Controller Patches, invocation from build.py
"""

import logging

from . import support

from .. import constants

from ..support import utilities
from ..detections import device_probe

from ..datasets import (
    model_array,
    smbios_data,
    cpu_data
)


class BuildStorage:
    """
    Build Library for System Storage Support

    Invoke from build.py
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants
        self.computer: device_probe.Computer = self.constants.computer

        self._build()


    def _build(self) -> None:
        """
        Kick off Storage Build Process
        """

        self._ahci_handling()
        self._pata_handling()
        self._misc_handling()
        self._pcie_handling()
        self._trim_handling()


    def _ahci_handling(self) -> None:
        """
        AHCI (SATA) Handler
        """

        # MacBookAir6,x ship with an AHCI over PCIe SSD model 'APPLE SSD TS0128F' and 'APPLE SSD TS0256F'
        # This controller is not supported properly in macOS Ventura, instead populating itself as 'Media' with no partitions
        # To work-around this, use Monterey's AppleAHCI driver to force support
        if not self.constants.custom_model:
            sata_devices = [i for i in self.computer.storage if isinstance(i, device_probe.SATAController)]
            for controller in sata_devices:
                # https://linux-hardware.org/?id=pci:1179-010b-1b4b-9183
                if controller.vendor_id == 0x1179 and controller.device_id == 0x010b:
                    logging.info("- Enabling AHCI SSD patch")
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("MonteAHCIPort.kext", self.constants.monterey_ahci_version, self.constants.monterey_ahci_path)
                    break
        elif self.model in ["MacBookAir6,1", "MacBookAir6,2"]:
            logging.info("- Enabling AHCI SSD patch")
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("MonteAHCIPort.kext", self.constants.monterey_ahci_version, self.constants.monterey_ahci_path)

        # ThirdPartyDrives Check
        if self.constants.allow_3rd_party_drives is True:
            for drive in ["SATA 2.5", "SATA 3.5", "mSATA"]:
                if not self.model in smbios_data.smbios_dictionary:
                    break
                if not "Stock Storage" in smbios_data.smbios_dictionary[self.model]:
                    break
                if drive in smbios_data.smbios_dictionary[self.model]["Stock Storage"]:
                    if not self.constants.custom_model:
                        if self.computer.third_party_sata_ssd is True:
                            logging.info("- Adding SATA Hibernation Patch")
                            self.config["Kernel"]["Quirks"]["ThirdPartyDrives"] = True
                            break
                    else:
                        logging.info("- Adding SATA Hibernation Patch")
                        self.config["Kernel"]["Quirks"]["ThirdPartyDrives"] = True
                        break


    def _pata_handling(self) -> None:
        """
        ATA (PATA) Handler
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "Stock Storage" in smbios_data.smbios_dictionary[self.model]:
            return
        if not "PATA" in smbios_data.smbios_dictionary[self.model]["Stock Storage"]:
            return

        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleIntelPIIXATA.kext", self.constants.piixata_version, self.constants.piixata_path)


    def _pcie_handling(self) -> None:
        """
        PCIe/NVMe Handler
        """

        if not self.constants.custom_model and (self.constants.allow_oc_everywhere is True or self.model in model_array.MacPro):
            # Use Innie's same logic:
            # https://github.com/cdf/Innie/blob/v1.3.0/Innie/Innie.cpp#L90-L97
            for i, controller in enumerate(self.computer.storage):
                logging.info(f"- Fixing PCIe Storage Controller ({i + 1}) reporting")
                if controller.pci_path:
                    self.config["DeviceProperties"]["Add"][controller.pci_path] = {"built-in": 1}
                else:
                    logging.info(f"- Failed to find Device path for PCIe Storage Controller {i}, falling back to Innie")
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("Innie.kext", self.constants.innie_version, self.constants.innie_path)

        if not self.constants.custom_model:
            nvme_devices = [i for i in self.computer.storage if isinstance(i, device_probe.NVMeController)]
            if self.constants.allow_nvme_fixing is True:
                for i, controller in enumerate(nvme_devices):
                    if controller.vendor_id == 0x106b:
                        continue
                    logging.info(f"- Found 3rd Party NVMe SSD ({i + 1}): {utilities.friendly_hex(controller.vendor_id)}:{utilities.friendly_hex(controller.device_id)}")
                    self.config["#Revision"][f"Hardware-NVMe-{i}"] = f"{utilities.friendly_hex(controller.vendor_id)}:{utilities.friendly_hex(controller.device_id)}"

                    # Disable Bit 0 (L0s), enable Bit 1 (L1)
                    nvme_aspm = (controller.aspm & (~0b11)) | 0b10

                    if controller.pci_path:
                        logging.info(f"- Found NVMe ({i}) at {controller.pci_path}")
                        self.config["DeviceProperties"]["Add"].setdefault(controller.pci_path, {})["pci-aspm-default"] = nvme_aspm
                        self.config["DeviceProperties"]["Add"][controller.pci_path.rpartition("/")[0]] = {"pci-aspm-default": nvme_aspm}
                    else:
                        if "-nvmefaspm" not in self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"]:
                            logging.info("- Falling back to -nvmefaspm")
                            self.config["NVRAM"]["Add"]["7C436110-AB2A-4BBB-A880-FE41995C9F82"]["boot-args"] += " -nvmefaspm"

                    if (controller.vendor_id != 0x144D and controller.device_id != 0xA804):
                        # Avoid injecting NVMeFix when a native Apple NVMe drive is present
                        # https://github.com/acidanthera/NVMeFix/blob/1.0.9/NVMeFix/NVMeFix.cpp#L220-L225
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("NVMeFix.kext", self.constants.nvmefix_version, self.constants.nvmefix_path)

            if any((controller.vendor_id == 0x106b and controller.device_id in [0x2001, 0x2003]) for controller in nvme_devices):
                # Restore S1X/S3X NVMe support removed in 14.0 Beta 2
                # - APPLE SSD AP0128H, AP0256H, etc
                # - APPLE SSD AP0128J, AP0256J, etc
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("IOS3XeFamily.kext", self.constants.s3x_nvme_version, self.constants.s3x_nvme_path)

        # Restore S1X/S3X NVMe support removed in 14.0 Beta 2
        # Apple's usage of the S1X and S3X is quite sporadic and inconsistent, so we'll try a catch all for units with NVMe drives
        # Additionally expanded to cover all Mac models with the 12+16 pin SSD layout, for older machines with newer drives
        if self.constants.custom_model and self.model in smbios_data.smbios_dictionary:
            if "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
                if (cpu_data.CPUGen.haswell <= smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.kaby_lake) or self.model in [ "MacPro6,1" ]:
                    support.BuildSupport(self.model, self.constants, self.config).enable_kext("IOS3XeFamily.kext", self.constants.s3x_nvme_version, self.constants.s3x_nvme_path)

        # Apple RAID Card check
        if not self.constants.custom_model:
            if self.computer.storage:
                for storage_controller in self.computer.storage:
                    if storage_controller.vendor_id == 0x106b and storage_controller.device_id == 0x008A:
                        # AppleRAIDCard.kext only supports pci106b,8a
                        support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleRAIDCard.kext", self.constants.apple_raid_version, self.constants.apple_raid_path)
                        break
        elif self.model.startswith("Xserve"):
            # For Xserves, assume RAID is present
            # Namely due to Xserve2,1 being limited to 10.7, thus no hardware detection
            support.BuildSupport(self.model, self.constants, self.config).enable_kext("AppleRAIDCard.kext", self.constants.apple_raid_version, self.constants.apple_raid_path)


    def _misc_handling(self) -> None:
        """
        SDXC Handler
        """

        if not self.model in smbios_data.smbios_dictionary:
            return
        if not "CPU Generation" in smbios_data.smbios_dictionary[self.model]:
            return

        # With macOS Monterey, Apple's SDXC driver requires the system to support VT-D
        # However pre-Ivy Bridge don't support this feature
        if smbios_data.smbios_dictionary[self.model]["CPU Generation"] <= cpu_data.CPUGen.sandy_bridge.value:
            if (self.constants.computer.sdxc_controller and not self.constants.custom_model) or (self.model.startswith("MacBookPro8") or self.model.startswith("Macmini5")):
                support.BuildSupport(self.model, self.constants, self.config).enable_kext("BigSurSDXC.kext", self.constants.bigsursdxc_version, self.constants.bigsursdxc_path)


    def _trim_handling(self) -> None:
        """
        TRIM Handler
        """

        if self.constants.apfs_trim_timeout is False:
            logging.info(f"- Disabling APFS TRIM timeout")
            self.config["Kernel"]["Quirks"]["SetApfsTrimTimeout"] = 0


#support.py:
"""
support.py: Utility class for build functions
"""

import shutil
import typing
import logging
import plistlib
import zipfile
import subprocess

from pathlib import Path

from .. import constants


class BuildSupport:
    """
    Support Library for build.py and related libraries
    """

    def __init__(self, model: str, global_constants: constants.Constants, config: dict) -> None:
        self.model: str = model
        self.config: dict = config
        self.constants: constants.Constants = global_constants


    @staticmethod
    def get_item_by_kv(iterable: dict, key: str, value: typing.Any) -> dict:
        """
        Gets an item from a list of dicts by key and value

        Parameters:
            iterable (list): List of dicts
            key       (str): Key to search for
            value     (any): Value to search for

        """

        item = None
        for i in iterable:
            if i[key] == value:
                item = i
                break
        return item


    def get_kext_by_bundle_path(self, bundle_path: str) -> dict:
        """
        Gets a kext by bundle path

        Parameters:
            bundle_path (str): Relative bundle path of the kext in the EFI folder
        """

        kext: dict = self.get_item_by_kv(self.config["Kernel"]["Add"], "BundlePath", bundle_path)
        if not kext:
            logging.info(f"- Could not find kext {bundle_path}!")
            raise IndexError
        return kext


    def get_efi_binary_by_path(self, bundle_name: str, entry_type: str, efi_type: str) -> dict:
        """
        Gets an EFI binary by name

        Parameters:
            bundle_name (str): Name of the EFI binary
            entry_type  (str): Type of EFI binary (UEFI, Misc)
            efi_type    (str): Type of EFI binary (Drivers, Tools)
        """

        efi_binary: dict = self.get_item_by_kv(self.config[entry_type][efi_type], "Path", bundle_name)
        if not efi_binary:
            logging.info(f"- Could not find {efi_type}: {bundle_name}!")
            raise IndexError
        return efi_binary


    def enable_kext(self, kext_name: str, kext_version: str, kext_path: Path, check: bool = False) -> None:
        """
        Enables a kext in the config.plist

        Parameters:
            kext_name     (str): Name of the kext
            kext_version  (str): Version of the kext
            kext_path    (Path): Path to the kext
        """

        kext: dict = self.get_kext_by_bundle_path(kext_name)

        if callable(check) and not check():
            # Check failed
            return

        if kext["Enabled"] is True:
            return

        logging.info(f"- Adding {kext_name} {kext_version}")
        shutil.copy(kext_path, self.constants.kexts_path)
        kext["Enabled"] = True


    def sign_files(self) -> None:
        """
        Signs files for on OpenCorePkg's Vault system
        """

        if self.constants.vault is False:
            return

        logging.info("- Vaulting EFI\n=========================================")
        popen = subprocess.Popen([str(self.constants.vault_path), f"{self.constants.oc_folder}/"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
        for stdout_line in iter(popen.stdout.readline, ""):
            logging.info(stdout_line.strip())
        logging.info("=========================================")

    def validate_pathing(self) -> None:
        """
        Validate whether all files are accounted for on-disk

        This ensures that OpenCore won't hit a critical error and fail to boot
        """

        logging.info("- Validating generated config")
        if not Path(self.constants.opencore_release_folder / Path("EFI/OC/config.plist")):
            logging.info("- OpenCore config file missing!!!")
            raise Exception("OpenCore config file missing")

        config_plist = plistlib.load(Path(self.constants.opencore_release_folder / Path("EFI/OC/config.plist")).open("rb"))

        for acpi in config_plist["ACPI"]["Add"]:
            if not Path(self.constants.opencore_release_folder / Path("EFI/OC/ACPI") / Path(acpi["Path"])).exists():
                logging.info(f"- Missing ACPI Table: {acpi['Path']}")
                raise Exception(f"Missing ACPI Table: {acpi['Path']}")

        for kext in config_plist["Kernel"]["Add"]:
            kext_path = Path(self.constants.opencore_release_folder / Path("EFI/OC/Kexts") / Path(kext["BundlePath"]))
            kext_binary_path = Path(kext_path / Path(kext["ExecutablePath"]))
            kext_plist_path = Path(kext_path / Path(kext["PlistPath"]))
            if not kext_path.exists():
                logging.info(f"- Missing kext: {kext_path}")
                raise Exception(f"Missing {kext_path}")
            if not kext_binary_path.exists():
                logging.info(f"- Missing {kext['BundlePath']}'s binary: {kext_binary_path}")
                raise Exception(f"Missing {kext_binary_path}")
            if not kext_plist_path.exists():
                logging.info(f"- Missing {kext['BundlePath']}'s plist: {kext_plist_path}")
                raise Exception(f"Missing {kext_plist_path}")

        for tool in config_plist["Misc"]["Tools"]:
            if not Path(self.constants.opencore_release_folder / Path("EFI/OC/Tools") / Path(tool["Path"])).exists():
                logging.info(f"- Missing tool: {tool['Path']}")
                raise Exception(f"Missing tool: {tool['Path']}")

        for driver in config_plist["UEFI"]["Drivers"]:
            if not Path(self.constants.opencore_release_folder / Path("EFI/OC/Drivers") / Path(driver["Path"])).exists():
                logging.info(f"- Missing driver: {driver['Path']}")
                raise Exception(f"Missing driver: {driver['Path']}")

        # Validating local files
        # Report if they have no associated config.plist entry (i.e. they're not being used)
        for tool_files in Path(self.constants.opencore_release_folder / Path("EFI/OC/Tools")).glob("*"):
            if tool_files.name not in [x["Path"] for x in config_plist["Misc"]["Tools"]]:
                logging.info(f"- Missing tool from config: {tool_files.name}")
                raise Exception(f"Missing tool from config: {tool_files.name}")

        for driver_file in Path(self.constants.opencore_release_folder / Path("EFI/OC/Drivers")).glob("*"):
            if driver_file.name not in [x["Path"] for x in config_plist["UEFI"]["Drivers"]]:
                logging.info(f"- Found extra driver: {driver_file.name}")
                raise Exception(f"Found extra driver: {driver_file.name}")

        self._validate_malformed_kexts(self.constants.opencore_release_folder / Path("EFI/OC/Kexts"))


    def _validate_malformed_kexts(self, directory: str | Path) -> None:
        """
        Validate Info.plist and executable pathing for kexts
        """
        for kext_folder in Path(directory).glob("*.kext"):
            if not Path(kext_folder / Path("Contents/Info.plist")).exists():
                continue

            kext_data = plistlib.load(Path(kext_folder / Path("Contents/Info.plist")).open("rb"))
            if "CFBundleExecutable" in kext_data:
                expected_executable = Path(kext_folder / Path("Contents/MacOS") / Path(kext_data["CFBundleExecutable"]))
                if not expected_executable.exists():
                    logging.info(f"- Missing executable for {kext_folder.name}: Contents/MacOS/{expected_executable.name}")
                    raise Exception(f" - Missing executable for {kext_folder.name}: Contents/MacOS/{expected_executable.name}")

            if Path(kext_folder / Path("Contents/PlugIns")).exists():
                self._validate_malformed_kexts(kext_folder / Path("Contents/PlugIns"))


    def cleanup(self) -> None:
        """
        Clean up files and entries
        """

        logging.info("- Cleaning up files")
        # Remove unused entries
        entries_to_clean = {
            "ACPI":   ["Add", "Delete", "Patch"],
            "Booter": ["Patch"],
            "Kernel": ["Add", "Block", "Force", "Patch"],
            "Misc":   ["Tools"],
            "UEFI":   ["Drivers"],
        }

        for entry in entries_to_clean:
            for sub_entry in entries_to_clean[entry]:
                for item in list(self.config[entry][sub_entry]):
                    if item["Enabled"] is False:
                        self.config[entry][sub_entry].remove(item)

        for kext in self.constants.kexts_path.rglob("*.zip"):
            with zipfile.ZipFile(kext) as zip_file:
                zip_file.extractall(self.constants.kexts_path)
            kext.unlink()

        for item in self.constants.oc_folder.rglob("*.zip"):
            with zipfile.ZipFile(item) as zip_file:
                zip_file.extractall(self.constants.oc_folder)
            item.unlink()

        if not self.constants.recovery_status:
            # Crashes in RecoveryOS for unknown reason
            for i in self.constants.build_path.rglob("__MACOSX"):
                shutil.rmtree(i)

        # Remove unused plugins inside of kexts
        # Following plugins are sometimes unused as there's different variants machines need
        known_unused_plugins = [
            "AirPortBrcm4331.kext",
            "AirPortAtheros40.kext",
            "AppleAirPortBrcm43224.kext",
            "AirPortBrcm4360_Injector.kext",
            "AirPortBrcmNIC_Injector.kext"
        ]
        for kext in Path(self.constants.opencore_release_folder / Path("EFI/OC/Kexts")).glob("*.kext"):
            for plugin in Path(kext / "Contents/PlugIns/").glob("*.kext"):
                should_remove = True
                for enabled_kexts in self.config["Kernel"]["Add"]:
                    if enabled_kexts["BundlePath"].endswith(plugin.name):
                        should_remove = False
                        break
                if should_remove:
                    if plugin.name not in known_unused_plugins:
                        raise Exception(f" - Unknown plugin found: {plugin.name}")
                    shutil.rmtree(plugin)

        Path(self.constants.opencore_zip_copied).unlink()

#sucatalog
#__init__.py
"""
sucatalog: Python module for querying Apple's Software Update Catalog, supporting Tiger through Sequoia.

-------------------

## Usage

### Get Software Update Catalog URL

```python
>>> import sucatalog

>>> # Defaults to PublicRelease seed
>>> url = sucatalog.CatalogURL().url
"https://swscan.apple.com/.../index-15-14-13-12-10.16-10.15-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog"

>>> url = sucatalog.CatalogURL(seed=sucatalog.SeedType.DeveloperSeed).url
"https://swscan.apple.com/.../index-15seed-15-14-13-12-10.16-10.15-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog"

>>> url = sucatalog.CatalogURL(version=sucatalog.CatalogVersion.HIGH_SIERRA).url
"https://swscan.apple.com/.../index-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog"
```


### Parse Software Update Catalog - InstallAssistants only

>>> import sucatalog

>>> # Pass contents of URL (as dictionary)
>>> catalog = plistlib.loads(requests.get(url).content)

>>> products = sucatalog.CatalogProducts(catalog).products
[
    {
        'Build': '22G720',
        'Catalog': <SeedType.PublicRelease: ''>,
        'InstallAssistant': {
            'IntegrityDataSize': 42008,
            'IntegrityDataURL': 'https://swcdn.apple.com/.../InstallAssistant.pkg.integrityDataV1',
            'Size': 12210304673,
            'URL': 'https://swcdn.apple.com/.../InstallAssistant.pkg'
        },
        'PostDate': datetime.datetime(2024, 5, 20, 17, 18, 21),
        'ProductID': '052-96247',
        'Title': 'macOS Ventura',
        'Version': '13.6.7'
    }
]

### Parse Software Update Catalog - All products

By default, `CatalogProducts` will only return InstallAssistants. To get all products, set `install_assistants_only=False`.

>>> import sucatalog

>>> # Pass contents of URL (as dictionary)
>>> products = sucatalog.CatalogProducts(catalog, install_assistants_only=False).products
[
    {
        'Build': None,
        'Catalog': None,
        'Packages': [
            {
                'MetadataURL': 'https://swdist.apple.com/.../iLifeSlideshow_v2.pkm',
                'Size': 116656956,
                'URL': 'http://swcdn.apple.com/.../iLifeSlideshow_v2.pkg'
            },
            {
                'MetadataURL': 'https://swdist.apple.com/.../iPhoto9.2.3ContentUpdate.pkm',
                'Size': 59623907,
                'URL': 'http://swcdn.apple.com/.../iPhoto9.2.3ContentUpdate.pkg'
            },
            {
                'MetadataURL': 'https://swdist.apple.com/.../iPhoto9.2.3Update.pkm',
                'Size': 197263405,
                'URL': 'http://swcdn.apple.com/.../iPhoto9.2.3Update.pkg'
            }
        ],
        'PostDate': datetime.datetime(2019, 10, 23, 0, 2, 42),
        'ProductID': '041-85230',
        'Title': 'iPhoto Update',
        'Version': '9.2.3'
    },
    {
        'Build': None,
        'Catalog': None,
        'Packages': [
            {
                'Digest': '9aba109078feec7ea841529e955440b63d7755a0',
                'MetadataURL': 'https://swdist.apple.com/.../iPhoto9.4.3Update.pkm',
                'Size': 555246460,
                'URL': 'http://swcdn.apple.com/.../iPhoto9.4.3Update.pkg'
            },
            {
                'Digest': '0bb013221ca2df5e178d950cb229f41b8e680d00',
                'MetadataURL': 'https://swdist.apple.com/.../iPhoto9.4.3ContentUpdate.pkm',
                'Size': 213073666,
                'URL': 'http://swcdn.apple.com/.../iPhoto9.4.3ContentUpdate.pkg'
            }
        ],
        'PostDate': datetime.datetime(2019, 10, 13, 3, 23, 14),
        'ProductID': '041-88859',
        'Title': 'iPhoto Update',
        'Version': '9.4.3'
    }
]
"""

from .url       import CatalogURL
from .constants import CatalogVersion, SeedType
from .products  import CatalogProducts

#constants.py:
"""
constants.py: Enumerations for sucatalog-py
"""

from enum import StrEnum


class SeedType(StrEnum):
    """
    Enum for catalog types

    Variants:
        DeveloperSeed:  Developer Beta (Part of the Apple Developer Program)
        PublicSeed:     Public Beta
        CustomerSeed:   AppleSeed Program (Generally mirrors DeveloperSeed)
        PublicRelease:  Public Release
    """
    DeveloperSeed: str = "seed"
    PublicSeed:    str = "beta"
    CustomerSeed:  str = "customerseed"
    PublicRelease: str = ""


class CatalogVersion(StrEnum):
    """
    Enum for macOS versions

    Used for generating sucatalog URLs
    """
    SEQUOIA:        str = "15"
    SONOMA:         str = "14"
    VENTURA:        str = "13"
    MONTEREY:       str = "12"
    BIG_SUR:        str = "11"
    BIG_SUR_LEGACY: str = "10.16"
    CATALINA:       str = "10.15"
    MOJAVE:         str = "10.14"
    HIGH_SIERRA:    str = "10.13"
    SIERRA:         str = "10.12"
    EL_CAPITAN:     str = "10.11"
    YOSEMITE:       str = "10.10"
    MAVERICKS:      str = "10.9"
    MOUNTAIN_LION:  str = "mountainlion"
    LION:           str = "lion"
    SNOW_LEOPARD:   str = "snowleopard"
    LEOPARD:        str = "leopard"
    TIGER:          str = ""


class CatalogExtension(StrEnum):
    """
    Enum for catalog extensions

    Used for generating sucatalog URLs
    """
    PLIST: str = ".sucatalog"
    GZIP:  str = ".sucatalog.gz"


#products.py:
"""
products.py: Parse products from Software Update Catalog
"""

import re
import plistlib

import packaging.version
import xml.etree.ElementTree as ET

from pathlib   import Path
from functools import cached_property

from .url       import CatalogURL
from .constants import CatalogVersion, SeedType

from ..support import network_handler


class CatalogProducts:
    """
    Args:
        catalog                       (dict): Software Update Catalog (contents of CatalogURL's URL)
        install_assistants_only       (bool): Only list InstallAssistant products
        only_vmm_install_assistants   (bool): Only list VMM-x86_64-compatible InstallAssistant products
        max_install_assistant_version (CatalogVersion): Maximum InstallAssistant version to list
    """
    def __init__(self,
                 catalog: dict,
                 install_assistants_only: bool = True,
                 only_vmm_install_assistants: bool = True,
                 max_install_assistant_version: CatalogVersion = CatalogVersion.SEQUOIA
                ) -> None:
        self.catalog:             dict = catalog
        self.ia_only:             bool = install_assistants_only
        self.vmm_only:            bool = only_vmm_install_assistants
        self.max_ia_version: packaging = packaging.version.parse(f"{max_install_assistant_version.value}.99.99")
        self.max_ia_catalog: CatalogVersion = max_install_assistant_version


    def _legacy_parse_info_plist(self, data: dict) -> dict:
        """
        Legacy version of parsing for installer details through Info.plist
        """

        if "MobileAssetProperties" not in data:
            return {}
        if "SupportedDeviceModels" not in data["MobileAssetProperties"]:
            return {}
        if "OSVersion" not in data["MobileAssetProperties"]:
            return {}
        if "Build" not in data["MobileAssetProperties"]:
            return {}

        # Ensure Apple Silicon specific Installers are not listed
        if "VMM-x86_64" not in data["MobileAssetProperties"]["SupportedDeviceModels"]:
            if self.vmm_only:
                return {"Missing VMM Support": True}

        version = data["MobileAssetProperties"]["OSVersion"]
        build   = data["MobileAssetProperties"]["Build"]

        catalog = ""
        try:
            catalog = data["MobileAssetProperties"]["BridgeVersionInfo"]["CatalogURL"]
        except KeyError:
            pass

        if any([version, build]) is None:
            return {}

        return {
            "Version": version,
            "Build":   build,
            "Catalog": CatalogURL().catalog_url_to_seed(catalog),
        }


    def _parse_mobile_asset_plist(self, data: dict) -> dict:
        """
        Parses the MobileAsset plist for installer details

        With macOS Sequoia, the Info.plist is no longer present in the InstallAssistant's assets
        """
        _does_support_vmm = False
        for entry in data["Assets"]:
            if "SupportedDeviceModels" not in entry:
                continue
            if "OSVersion" not in entry:
                continue
            if "Build" not in entry:
                continue
            if "VMM-x86_64" not in entry["SupportedDeviceModels"]:
                if self.vmm_only:
                    continue

            _does_support_vmm = True

            build   = entry["Build"]
            version = entry["OSVersion"]

            catalog_url = ""
            try:
                catalog_url = entry["BridgeVersionInfo"]["CatalogURL"]
            except KeyError:
                pass

            return {
                "Version": version,
                "Build":   build,
                "Catalog": CatalogURL().catalog_url_to_seed(catalog_url),
            }

        if _does_support_vmm is False:
            if self.vmm_only:
                return {"Missing VMM Support": True}

        return {}


    def _parse_english_distributions(self, data: bytes) -> dict:
        """
        Resolve Title, Build and Version from the English distribution file
        """
        try:
            plist_contents = plistlib.loads(data)
        except plistlib.InvalidFileException:
            plist_contents = None

        try:
            xml_contents = ET.fromstring(data)
        except ET.ParseError:
            xml_contents = None

        _product_map = {
            "Title":   None,
            "Build":   None,
            "Version": None,
        }

        if plist_contents:
            if "macOSProductBuildVersion" in plist_contents:
                _product_map["Build"] = plist_contents["macOSProductBuildVersion"]
            if "macOSProductVersion" in plist_contents:
                _product_map["Version"] = plist_contents["macOSProductVersion"]
            if "BUILD" in plist_contents:
                _product_map["Build"] = plist_contents["BUILD"]
            if "VERSION" in plist_contents:
                _product_map["Version"] = plist_contents["VERSION"]

        if xml_contents:
            # Fetch item title
            item_title = xml_contents.find(".//title").text
            if item_title in ["SU_TITLE", "MANUAL_TITLE", "MAN_TITLE"]:
                # regex search the contents for the title
                title_search = re.search(r'"SU_TITLE"\s*=\s*"(.*)";', data.decode("utf-8"))
                if title_search:
                    item_title = title_search.group(1)

            _product_map["Title"] = item_title

        return _product_map


    def _build_installer_name(self, version: str, catalog: SeedType) -> str:
        """
        Builds the installer name based on the version and catalog
        """
        try:
            marketing_name = CatalogVersion(version.split(".")[0]).name
        except ValueError:
            marketing_name = "Unknown"

        # Replace _ with space
        marketing_name = marketing_name.replace("_", " ")

        # Convert to upper for each word
        marketing_name = "macOS " + " ".join([word.capitalize() for word in marketing_name.split()])

        # Append Beta if needed
        if catalog in [SeedType.DeveloperSeed, SeedType.PublicSeed, SeedType.CustomerSeed]:
            marketing_name += " Beta"

        return marketing_name


    def _list_latest_installers_only(self, products: list) -> list:
        """
        List only the latest installers per macOS version

        macOS versions capped at n-3 (n being the latest macOS version)
        """

        supported_versions = []

        # Build list of supported versions (n to n-3, where n is the latest macOS version set)
        did_find_latest = False
        for version in CatalogVersion:
            if did_find_latest is False:
                if version != self.max_ia_catalog:
                    continue
                did_find_latest = True

            supported_versions.append(version)

            if len(supported_versions) == 4:
                break

        # Invert the list
        supported_versions = supported_versions[::-1]

        # Create duplicate product list
        products_copy = products.copy()

        # Remove all but the newest version
        for version in supported_versions:
            _newest_version = packaging.version.parse("0.0.0")

            # First, determine largest version
            for installer in products:
                if installer["Version"] is None:
                    continue
                if not installer["Version"].startswith(version.value):
                    continue
                if installer["Catalog"] in [SeedType.CustomerSeed, SeedType.DeveloperSeed, SeedType.PublicSeed]:
                    continue
                try:
                    if packaging.version.parse(installer["Version"]) > _newest_version:
                        _newest_version = packaging.version.parse(installer["Version"])
                except packaging.version.InvalidVersion:
                    pass

            # Next, remove all installers that are not the newest version
            for installer in products:
                if installer["Version"] is None:
                    continue
                if not installer["Version"].startswith(version.value):
                    continue
                try:
                    if packaging.version.parse(installer["Version"]) < _newest_version:
                        if installer in products_copy:
                            products_copy.pop(products_copy.index(installer))
                except packaging.version.InvalidVersion:
                    pass

                # Remove beta versions if a public release is available
                if _newest_version != packaging.version.parse("0.0.0"):
                    if installer["Catalog"] in [SeedType.CustomerSeed, SeedType.DeveloperSeed, SeedType.PublicSeed]:
                        if installer in products_copy:
                            products_copy.pop(products_copy.index(installer))


        # Remove EOL versions (older than n-3)
        for installer in products:
            if installer["Version"].split(".")[0] < supported_versions[-4].value:
                if installer in products_copy:
                    products_copy.pop(products_copy.index(installer))

        return products_copy


    @cached_property
    def products(self) -> None:
        """
        Returns a list of products from the sucatalog
        """

        catalog = self.catalog

        _products = []

        for product in catalog["Products"]:

            # InstallAssistants.pkgs (macOS Installers) will have the following keys:
            if self.ia_only:
                if "ExtendedMetaInfo" not in catalog["Products"][product]:
                    continue
                if "InstallAssistantPackageIdentifiers" not in catalog["Products"][product]["ExtendedMetaInfo"]:
                    continue
                if "SharedSupport" not in catalog["Products"][product]["ExtendedMetaInfo"]["InstallAssistantPackageIdentifiers"]:
                    continue

            _product_map = {
                "ProductID": product,
                "PostDate":  catalog["Products"][product]["PostDate"],
                "Title":     None,
                "Build":     None,
                "Version":   None,
                "Catalog":   None,

                # Optional keys if not InstallAssistant only:
                # "Packages": None,

                # Optional keys if InstallAssistant found:
                # "InstallAssistant": {
                #     "URL":       None,
                #     "Size":      None,
                #     "XNUMajor":  None,
                #     "IntegrityDataURL":  None,
                #     "IntegrityDataSize": None
                # },
            }

            # InstallAssistant logic
            if "Packages" in catalog["Products"][product]:
                # Add packages to product map if not InstallAssistant only
                if self.ia_only is False:
                    _product_map["Packages"] = catalog["Products"][product]["Packages"]
                for package in catalog["Products"][product]["Packages"]:
                    if "URL" in package:
                        if Path(package["URL"]).name == "InstallAssistant.pkg":
                            _product_map["InstallAssistant"] = {
                                "URL":               package["URL"],
                                "Size":              package["Size"],
                                "IntegrityDataURL":  package["IntegrityDataURL"],
                                "IntegrityDataSize": package["IntegrityDataSize"]
                            }

                        if Path(package["URL"]).name not in ["Info.plist", "com_apple_MobileAsset_MacSoftwareUpdate.plist"]:
                            continue

                        net_obj = network_handler.NetworkUtilities().get(package["URL"])
                        if net_obj is None:
                            continue

                        contents = net_obj.content
                        try:
                            plist_contents = plistlib.loads(contents)
                        except plistlib.InvalidFileException:
                            continue

                        if plist_contents:
                            if Path(package["URL"]).name == "Info.plist":
                                result = self._legacy_parse_info_plist(plist_contents)
                            else:
                                result = self._parse_mobile_asset_plist(plist_contents)

                            if result == {"Missing VMM Support": True}:
                                _product_map = {}
                                break

                            _product_map.update(result)

            if _product_map == {}:
                continue

            if _product_map["Version"] is not None:
                _product_map["Title"] = self._build_installer_name(_product_map["Version"], _product_map["Catalog"])

            # Fall back to English distribution if no version is found
            if _product_map["Version"] is None:
                url = None
                if "Distributions" in catalog["Products"][product]:
                    if "English" in catalog["Products"][product]["Distributions"]:
                        url = catalog["Products"][product]["Distributions"]["English"]
                    elif "en" in catalog["Products"][product]["Distributions"]:
                        url = catalog["Products"][product]["Distributions"]["en"]

                if url is None:
                    continue

                net_obj = network_handler.NetworkUtilities().get(url)
                if net_obj is None:
                    continue

                contents = net_obj.content

                _product_map.update(self._parse_english_distributions(contents))

                if _product_map["Version"] is None:
                    if "ServerMetadataURL" in catalog["Products"][product]:
                        server_metadata_url = catalog["Products"][product]["ServerMetadataURL"]

                        net_obj = network_handler.NetworkUtilities().get(server_metadata_url)
                        if net_obj is None:
                            continue

                        server_metadata_contents = net_obj.content

                        try:
                            server_metadata_plist = plistlib.loads(server_metadata_contents)
                        except plistlib.InvalidFileException:
                            pass

                        if "CFBundleShortVersionString" in server_metadata_plist:
                            _product_map["Version"] = server_metadata_plist["CFBundleShortVersionString"]


            if _product_map["Version"] is not None:
                # Check if version is newer than the max version
                if self.ia_only:
                    try:
                        if packaging.version.parse(_product_map["Version"]) > self.max_ia_version:
                            continue
                    except packaging.version.InvalidVersion:
                        pass

            if _product_map["Build"] is not None:
                if "InstallAssistant" in _product_map:
                    try:
                        # Grab first 2 characters of build
                        _product_map["InstallAssistant"]["XNUMajor"] = int(_product_map["Build"][:2])
                    except ValueError:
                        pass

            # If version is still None, set to 0.0.0
            if _product_map["Version"] is None:
                _product_map["Version"] = "0.0.0"

            _products.append(_product_map)

        _products = sorted(_products, key=lambda x: x["Version"])

        return _products


    @cached_property
    def latest_products(self) -> list:
        """
        Returns a list of the latest products from the sucatalog
        """
        return self._list_latest_installers_only(self.products)


#url.py
"""
url.py: Generate URL for Software Update Catalog

Usage:
>>> import sucatalog
>>> catalog_url = sucatalog.CatalogURL().url
https://swscan.apple.com/content/catalogs/others/index-15seed-15-14-13-12-10.16-10.15-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog
"""

import logging
import plistlib

from .constants import (
    SeedType,
    CatalogVersion,
    CatalogExtension
)

from ..support import network_handler


class CatalogURL:
    """
    Provides URL generation for Software Update Catalog

    Args:
        version   (CatalogVersion):    Version of macOS
        seed      (SeedType):          Seed type
        extension (CatalogExtension):  Extension for the catalog URL
    """
    def __init__(self,
                 version: CatalogVersion = CatalogVersion.SEQUOIA,
                 seed: SeedType = SeedType.PublicRelease,
                 extension: CatalogExtension = CatalogExtension.PLIST
                 ) -> None:
        self.version   = version
        self.seed      = seed
        self.extension = extension

        self.seed    = self._fix_seed_type()
        self.version = self._fix_version()


    def _fix_seed_type(self) -> SeedType:
        """
        Fixes seed type for URL generation
        """
        # Pre-Mountain Lion lacked seed types
        if self.version in [CatalogVersion.LION, CatalogVersion.SNOW_LEOPARD, CatalogVersion.LEOPARD, CatalogVersion.TIGER]:
            if self.seed != SeedType.PublicRelease:
                logging.warning(f"{self.seed.name} not supported for {self.version.name}, defaulting to PublicRelease")
                return SeedType.PublicRelease

        # Pre-Yosemite lacked PublicSeed/CustomerSeed, thus override to DeveloperSeed
        if self.version in [CatalogVersion.MAVERICKS, CatalogVersion.MOUNTAIN_LION]:
            if self.seed in [SeedType.PublicSeed, SeedType.CustomerSeed]:
                logging.warning(f"{self.seed.name} not supported for {self.version.name}, defaulting to DeveloperSeed")
                return SeedType.DeveloperSeed

        return self.seed


    def _fix_version(self) -> CatalogVersion:
        """
        Fixes version for URL generation
        """
        if self.version == CatalogVersion.BIG_SUR:
            return CatalogVersion.BIG_SUR_LEGACY

        return self.version


    def _fetch_versions_for_url(self) -> list:
        """
        Fetches versions for URL generation
        """
        versions: list = []

        _did_hit_variant: bool = False
        for variant in CatalogVersion:

            # Avoid appending versions newer than the current version
            if variant == self.version:
                _did_hit_variant = True
            if _did_hit_variant is False:
                continue

            # Skip invalid version
            if variant in [CatalogVersion.BIG_SUR, CatalogVersion.TIGER]:
                continue

            versions.append(variant.value)

        if self.version == CatalogVersion.SNOW_LEOPARD:
            # Reverse list pre-Lion (ie. just Snow Leopard, since Lion is a list of one)
            versions = versions[::-1]

        return versions


    def _construct_catalog_url(self) -> str:
        """
        Constructs the catalog URL based on the seed type
        """

        url: str = "https://swscan.apple.com/content/catalogs"

        if self.version == CatalogVersion.TIGER:
            url += "/index"
        else:
            url += "/others/index"

        if self.seed in [SeedType.DeveloperSeed, SeedType.PublicSeed, SeedType.CustomerSeed]:
            url += f"-{self.version.value}"
            if self.version == CatalogVersion.MAVERICKS and self.seed == SeedType.CustomerSeed:
                # Apple previously used 'publicseed' for CustomerSeed in Mavericks
                url += "publicseed"
            else:
                url += f"{self.seed.value}"

        # 10.10 and older don't append versions for CustomerSeed
        if self.seed == SeedType.CustomerSeed and self.version in [
            CatalogVersion.YOSEMITE,
            CatalogVersion.MAVERICKS,
            CatalogVersion.MOUNTAIN_LION,
            CatalogVersion.LION,
            CatalogVersion.SNOW_LEOPARD,
            CatalogVersion.LEOPARD
        ]:
            pass
        else:
            for version in self._fetch_versions_for_url():
                url += f"-{version}"

        if self.version != CatalogVersion.TIGER:
            url += ".merged-1"
        url += self.extension.value

        return url


    def catalog_url_to_seed(self, catalog_url: str) -> SeedType:
        """
        Converts the Catalog URL to a SeedType
        """
        if "beta" in catalog_url:
            return SeedType.PublicSeed
        elif "customerseed" in catalog_url:
            return SeedType.CustomerSeed
        elif "seed" in catalog_url:
            return SeedType.DeveloperSeed
        return SeedType.PublicRelease


    @property
    def url(self) -> str:
        """
        Generate URL for Software Update Catalog

        Returns:
            str: URL for Software Update Catalog
        """
        return self._construct_catalog_url()


    @property
    def url_contents(self) -> dict:
        """
        Return URL contents
        """
        try:
            return plistlib.loads(network_handler.NetworkUtilities().get(self.url).content)
        except Exception as e:
            logging.error(f"Failed to fetch URL contents: {e}")
            return None


#support
analytics_handler.py:
"""
analytics_handler.py: Analytics and Crash Reporting Handler
"""

import json
import datetime
import plistlib

from pathlib import Path

from .. import constants

from . import (
    network_handler,
    global_settings
)


DATE_FORMAT:      str = "%Y-%m-%d %H-%M-%S"
ANALYTICS_SERVER: str = ""
SITE_KEY:         str = ""
CRASH_URL:        str = ANALYTICS_SERVER + "/crash"

VALID_ANALYTICS_ENTRIES: dict = {
    'KEY':                 str,               # Prevent abuse (embedded at compile time)
    'UNIQUE_IDENTITY':     str,               # Host's UUID as SHA1 hash
    'APPLICATION_NAME':    str,               # ex. OpenCore Legacy Patcher
    'APPLICATION_VERSION': str,               # ex. 0.2.0
    'OS_VERSION':          str,               # ex. 10.15.7
    'MODEL':               str,               # ex. MacBookPro11,5
    'GPUS':                list,              # ex. ['Intel Iris Pro', 'AMD Radeon R9 M370X']
    'FIRMWARE':            str,               # ex. APPLE
    'LOCATION':            str,               # ex. 'US' (just broad region, don't need to be specific)
    'TIMESTAMP':           datetime.datetime, # ex. 2021-09-01-12-00-00
}

VALID_CRASH_ENTRIES: dict = {
    'KEY':                 str,               # Prevent abuse (embedded at compile time)
    'APPLICATION_VERSION': str,               # ex. 0.2.0
    'APPLICATION_COMMIT':  str,               # ex. 0.2.0 or {commit hash if not a release}
    'OS_VERSION':          str,               # ex. 10.15.7
    'MODEL':               str,               # ex. MacBookPro11,5
    'TIMESTAMP':           datetime.datetime, # ex. 2021-09-01-12-00-00
    'CRASH_LOG':           str,               # ex. "This is a crash log"
}


class Analytics:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants
        self.unique_identity = str(self.constants.computer.uuid_sha1)
        self.application =     str("OpenCore Legacy Patcher")
        self.version =         str(self.constants.patcher_version)
        self.os =              str(self.constants.detected_os_version)
        self.model =           str(self.constants.computer.real_model)
        self.date =            str(datetime.datetime.now().strftime(DATE_FORMAT))


    def send_analytics(self) -> None:
        if global_settings.GlobalEnviromentSettings().read_property("DisableCrashAndAnalyticsReporting") is True:
            return

        self._generate_base_data()
        self._post_analytics_data()


    def send_crash_report(self, log_file: Path) -> None:
        if ANALYTICS_SERVER == "":
            return
        if SITE_KEY == "":
            return
        if global_settings.GlobalEnviromentSettings().read_property("DisableCrashAndAnalyticsReporting") is True:
            return
        if not log_file.exists():
            return
        if self.constants.commit_info[0].startswith("refs/tags"):
            # Avoid being overloaded with crash reports
            return

        commit_info = self.constants.commit_info[0].split("/")[-1] + "_" + self.constants.commit_info[1].split("T")[0] + "_" + self.constants.commit_info[2].split("/")[-1]

        crash_data= {
            "KEY":                 SITE_KEY,
            "APPLICATION_VERSION": self.version,
            "APPLICATION_COMMIT":  commit_info,
            "OS_VERSION":          self.os,
            "MODEL":               self.model,
            "TIMESTAMP":           self.date,
            "CRASH_LOG":           log_file.read_text()
        }

        network_handler.NetworkUtilities().post(CRASH_URL, json = crash_data)


    def _get_country(self) -> str:
        # Get approximate country from .GlobalPreferences.plist
        path = "/Library/Preferences/.GlobalPreferences.plist"
        if not Path(path).exists():
            return "US"

        try:
            result = plistlib.load(Path(path).open("rb"))
        except:
            return "US"

        if "Country" not in result:
            return "US"

        return result["Country"]


    def _generate_base_data(self) -> None:
        self.gpus = []

        self.firmware = str(self.constants.computer.firmware_vendor)
        self.location = str(self._get_country())

        for gpu in self.constants.computer.gpus:
            self.gpus.append(str(gpu.arch))

        self.data = {
            'KEY':                 SITE_KEY,
            'UNIQUE_IDENTITY':     self.unique_identity,
            'APPLICATION_NAME':    self.application,
            'APPLICATION_VERSION': self.version,
            'OS_VERSION':          self.os,
            'MODEL':               self.model,
            'GPUS':                self.gpus,
            'FIRMWARE':            self.firmware,
            'LOCATION':            self.location,
            'TIMESTAMP':           self.date,
        }

        # convert to JSON:
        self.data = json.dumps(self.data)


    def _post_analytics_data(self) -> None:
        # Post data to analytics server
        if ANALYTICS_SERVER == "":
            return
        if SITE_KEY == "":
            return
        network_handler.NetworkUtilities().post(ANALYTICS_SERVER, json = self.data)



#arguments.py:
"""
arguments.py: CLI argument handling
"""

import sys
import time
import logging
import plistlib
import threading
import subprocess

from pathlib import Path

from . import subprocess_wrapper

from .. import constants

from ..wx_gui import gui_entry
from ..efi_builder import build
from ..sys_patch import sys_patch
from ..sys_patch.auto_patcher import StartAutomaticPatching

from ..datasets import (
    model_array,
    os_data
)

from . import (
    utilities,
    defaults,
    validation
)



# Generic building args
class arguments:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants

        self.args = utilities.check_cli_args()

        self._parse_arguments()


    def _parse_arguments(self) -> None:
        """
        Parses arguments passed to the patcher
        """

        if self.args.validate:
            self._validation_handler()
            return

        if self.args.build:
            self._build_handler()
            return

        if self.args.patch_sys_vol:
            self._sys_patch_handler()
            return

        if self.args.unpatch_sys_vol:
            self._sys_unpatch_handler()
            return

        if self.args.prepare_for_update:
            self._prepare_for_update_handler()
            return

        if self.args.cache_os:
            self._cache_os_handler()
            return

        if self.args.auto_patch:
            self._sys_patch_auto_handler()
            return


    def _validation_handler(self) -> None:
        """
        Enter validation mode
        """
        logging.info("Set Validation Mode")
        validation.PatcherValidation(self.constants)


    def _sys_patch_handler(self) -> None:
        """
        Start root volume patching
        """

        logging.info("Set System Volume patching")
        if "Library/InstallerSandboxes/" in str(self.constants.payload_path):
            logging.info("- Running from Installer Sandbox, blocking OS updaters")
            thread = threading.Thread(target=sys_patch.PatchSysVolume(self.constants.custom_model or self.constants.computer.real_model, self.constants, None).start_patch)
            thread.start()
            while thread.is_alive():
                utilities.block_os_updaters()
                time.sleep(1)
        else:
            sys_patch.PatchSysVolume(self.constants.custom_model or self.constants.computer.real_model, self.constants, None).start_patch()


    def _sys_unpatch_handler(self) -> None:
        """
        Start root volume unpatching
        """
        logging.info("Set System Volume unpatching")
        sys_patch.PatchSysVolume(self.constants.custom_model or self.constants.computer.real_model, self.constants, None).start_unpatch()


    def _sys_patch_auto_handler(self) -> None:
        """
        Start root volume auto patching
        """

        logging.info("Set Auto patching")
        StartAutomaticPatching(self.constants).start_auto_patch()


    def _prepare_for_update_handler(self) -> None:
        """
        Prepare host for macOS update
        """
        logging.info("Preparing host for macOS update")

        os_data = utilities.fetch_staged_update(variant="Update")
        if os_data[0] is None:
            logging.info("No update staged, skipping")
            return

        os_version = os_data[0]
        os_build   = os_data[1]

        logging.info(f"Preparing for update to {os_version} ({os_build})")

        self._clean_le_handler()


    def _cache_os_handler(self) -> None:
        """
        Fetch KDK for incoming OS
        """
        results = subprocess.run(["/bin/ps", "-ax"], stdout=subprocess.PIPE)
        if results.stdout.decode("utf-8").count("OpenCore-Patcher --cache_os") > 1:
            logging.info("Another instance of OS caching is running, exiting")
            return

        gui_entry.EntryPoint(self.constants).start(entry=gui_entry.SupportedEntryPoints.OS_CACHE)


    def _clean_le_handler(self) -> None:
        """
        Clean /Library/Extensions of problematic kexts
        Note macOS Ventura and older do this automatically
        """

        if self.constants.detected_os < os_data.os_data.sonoma:
            return

        logging.info("Cleaning /Library/Extensions")

        for kext in Path("/Library/Extensions").glob("*.kext"):
            if not Path(f"{kext}/Contents/Info.plist").exists():
                continue
            try:
                kext_plist = plistlib.load(open(f"{kext}/Contents/Info.plist", "rb"))
            except Exception as e:
                logging.info(f"  - Failed to load plist for {kext.name}: {e}")
                continue
            if "GPUCompanionBundles" not in kext_plist:
                continue
            logging.info(f"  - Removing {kext.name}")
            subprocess_wrapper.run_as_root(["/bin/rm", "-rf", kext])


    def _build_handler(self) -> None:
        """
        Start config building process
        """
        logging.info("Set OpenCore Build")

        if self.args.model:
            if self.args.model:
                logging.info(f"- Using custom model: {self.args.model}")
                self.constants.custom_model = self.args.model
                defaults.GenerateDefaults(self.constants.custom_model, False, self.constants)
            elif self.constants.computer.real_model not in model_array.SupportedSMBIOS and self.constants.allow_oc_everywhere is False:
                logging.info(
                    """Your model is not supported by this patcher for running unsupported OSes!"

If you plan to create the USB for another machine, please select the "Change Model" option in the menu."""
                )
                sys.exit(1)
            else:
                logging.info(f"- Using detected model: {self.constants.computer.real_model}")
                defaults.GenerateDefaults(self.constants.custom_model, True, self.constants)

        if self.args.verbose:
            logging.info("- Set verbose configuration")
            self.constants.verbose_debug = True
        else:
            self.constants.verbose_debug = False  # Override Defaults detected

        if self.args.debug_oc:
            logging.info("- Set OpenCore DEBUG configuration")
            self.constants.opencore_debug = True

        if self.args.debug_kext:
            logging.info("- Set kext DEBUG configuration")
            self.constants.kext_debug = True

        if self.args.hide_picker:
            logging.info("- Set HidePicker configuration")
            self.constants.showpicker = False

        if self.args.disable_sip:
            logging.info("- Set Disable SIP configuration")
            self.constants.sip_status = False
        else:
            self.constants.sip_status = True  # Override Defaults detected

        if self.args.disable_smb:
            logging.info("- Set Disable SecureBootModel configuration")
            self.constants.secure_status = False
        else:
            self.constants.secure_status = True  # Override Defaults detected

        if self.args.vault:
            logging.info("- Set Vault configuration")
            self.constants.vault = True

        if self.args.firewire:
            logging.info("- Set FireWire Boot configuration")
            self.constants.firewire_boot = True

        if self.args.nvme:
            logging.info("- Set NVMe Boot configuration")
            self.constants.nvme_boot = True

        if self.args.wlan:
            logging.info("- Set Wake on WLAN configuration")
            self.constants.enable_wake_on_wlan = True

        if self.args.disable_tb:
            logging.info("- Set Disable Thunderbolt configuration")
            self.constants.disable_tb = True

        if self.args.force_surplus:
            logging.info("- Forcing SurPlus override configuration")
            self.constants.force_surplus = True

        if self.args.moderate_smbios:
            logging.info("- Set Moderate SMBIOS Patching configuration")
            self.constants.serial_settings = "Moderate"

        if self.args.smbios_spoof:
            if self.args.smbios_spoof == "Minimal":
                self.constants.serial_settings = "Minimal"
            elif self.args.smbios_spoof == "Moderate":
                self.constants.serial_settings = "Moderate"
            elif self.args.smbios_spoof == "Advanced":
                self.constants.serial_settings = "Advanced"
            else:
                logging.info(f"- Unknown SMBIOS arg passed: {self.args.smbios_spoof}")

        if self.args.support_all:
            logging.info("- Building for natively supported model")
            self.constants.allow_oc_everywhere = True
            self.constants.serial_settings = "None"

        build.BuildOpenCore(self.constants.custom_model or self.constants.computer.real_model, self.constants)

#commit_info.py:
"""
commit_info.py: Parse Commit Info from binary's info.plist
"""

import plistlib

from pathlib import Path


class ParseCommitInfo:

    def __init__(self, binary_path: str) -> None:
        """
        Parameters:
            binary_path (str): Path to binary
        """

        self.binary_path = str(binary_path)
        self.plist_path = self._convert_binary_path_to_plist_path()


    def _convert_binary_path_to_plist_path(self) -> str:
        """
        Resolve Info.plist path from binary path
        """

        if Path(self.binary_path).exists():
            plist_path = self.binary_path.replace("MacOS/OpenCore-Patcher", "Info.plist")
            if Path(plist_path).exists() and plist_path.endswith(".plist"):
                return plist_path
        return None


    def generate_commit_info(self) -> tuple:
        """
        Generate commit info from Info.plist

        Returns:
            tuple: (Branch, Commit Date, Commit URL)
        """

        if self.plist_path:
            plist_info = plistlib.load(Path(self.plist_path).open("rb"))
            if "Github" in plist_info:
                return (
                    plist_info["Github"]["Branch"],
                    plist_info["Github"]["Commit Date"],
                    plist_info["Github"]["Commit URL"],
                )
        return (
            "Running from source",
            "Not applicable",
            "",
        )

#defaults.py:
"""
defaults.py: Generate default data for host/target
"""

import logging
import plistlib
import subprocess

from pathlib import Path

from .. import constants

from ..detections import device_probe

from . import (
    utilities,
    generate_smbios,
    global_settings
)
from ..datasets import (
    smbios_data,
    cpu_data,
    os_data
)


class GenerateDefaults:

    def __init__(self, model: str, host_is_target: bool, global_constants: constants.Constants, ignore_settings_file: bool = False) -> None:
        self.constants: constants.Constants = global_constants

        self.model: str = model

        self.host_is_target: bool = host_is_target
        self.ignore_settings_file: bool = ignore_settings_file

        # Reset Variables
        self.constants.sip_status = True
        self.constants.secure_status = False
        self.constants.disable_cs_lv = False
        self.constants.disable_amfi = False
        self.constants.fu_status = False

        # Reset Variables - GUI override
        # Match constants.py for model specific settings
        # TODO: Write a sane system for this...
        self.constants.firewire_boot = False
        self.constants.xhci_boot = False
        self.constants.nvme_boot = False
        self.constants.force_quad_thread = False
        self.constants.enable_wake_on_wlan = False
        self.constants.disable_tb = False
        self.constants.dGPU_switch = False
        self.constants.disallow_cpufriend = False
        self.constants.disable_mediaanalysisd = False
        self.constants.set_alc_usage = True
        self.constants.nvram_write = True
        self.constants.allow_nvme_fixing = True
        self.constants.allow_3rd_party_drives = True
        self.constants.disable_fw_throttle = False
        self.constants.software_demux = False
        self.constants.disable_connectdrivers = False
        self.constants.amd_gop_injection = False
        self.constants.nvidia_kepler_gop_injection = False
        self.constants.disable_cs_lv = False
        self.constants.disable_amfi = False
        self.constants.secure_status = False
        self.constants.serial_settings = "None"
        self.constants.override_smbios = "Default"
        self.constants.allow_native_spoofs = False
        self.constants.allow_oc_everywhere = False
        self.constants.sip_status = True
        self.constants.custom_sip_value = None


        self.constants.fu_arguments = None

        self.constants.custom_serial_number = ""
        self.constants.custom_board_serial_number = ""

        if self.host_is_target is True:
            for gpu in self.constants.computer.gpus:
                if gpu.device_id_unspoofed == -1:
                    gpu.device_id_unspoofed = gpu.device_id
                if gpu.vendor_id_unspoofed == -1:
                    gpu.vendor_id_unspoofed = gpu.vendor_id

        self._general_probe()
        self._nvram_probe()
        self._gpu_probe()
        self._networking_probe()
        self._misc_hardwares_probe()
        self._smbios_probe()
        self._check_amfipass_supported()
        self._load_gui_defaults()


    def _general_probe(self) -> None:
        """
        General probe for data
        """

        if self.model in ["MacBookPro8,2", "MacBookPro8,3"]:
            # Users disabling TS2 most likely have a faulty dGPU
            # users can override this in settings
            ts2_status = global_settings.GlobalEnviromentSettings().read_property("MacBookPro_TeraScale_2_Accel")
            if ts2_status is True:
                self.constants.allow_ts2_accel = True
            else:
                global_settings.GlobalEnviromentSettings().write_property("MacBookPro_TeraScale_2_Accel", False)
                self.constants.allow_ts2_accel = False

        if self.model in ["MacPro3,1", "Xserve2,1"]:
            self.constants.force_quad_thread = True
        else:
            self.constants.force_quad_thread = False

        if self.model in smbios_data.smbios_dictionary:
            if smbios_data.smbios_dictionary[self.model]["CPU Generation"] >= cpu_data.CPUGen.skylake.value:
                # On 2016-2017 MacBook Pros, 15" devices used a stock Samsung SSD with IONVMeController
                # Technically this should be patched based on NVMeFix.kext logic,
                # however Apple deemed the SSD unsupported for enhanced performance
                # In addition, some upgraded NVMe drives still have issues with enhanced power management
                # Safest to disable by default, allow user to configure afterwards
                self.constants.allow_nvme_fixing = False
            else:
                self.constants.allow_nvme_fixing = True

        # Check if running in RecoveryOS
        self.constants.recovery_status = utilities.check_recovery()

        if global_settings.GlobalEnviromentSettings().read_property("Force_Web_Drivers") is True:
            self.constants.force_nv_web = True

        result = global_settings.GlobalEnviromentSettings().read_property("ShouldNukeKDKs")
        if result is False:
            self.constants.should_nuke_kdks = False


    def _smbios_probe(self) -> None:
        """
        SMBIOS specific probe
        """

        if not self.host_is_target:
            if self.model in ["MacPro4,1", "MacPro5,1"]:
                # Allow H.265 on AMD
                # Assume 2009+ machines have Polaris on pre-builts (internal testing)
                # Hardware Detection will never hit this
                self.constants.serial_settings = "Minimal"

        # Check if model uses T2 SMBIOS, if so see if it needs root patching (determined earlier on via SIP variable)
        # If not, allow SecureBootModel usage, otherwise force VMM patching
        # Needed for macOS Monterey to allow OTA updates
        try:
            spoof_model = generate_smbios.set_smbios_model_spoof(self.model)
        except:
            # Native Macs (mainly M1s) will error out as they don't know what SMBIOS to spoof to
            # As we don't spoof on native models, we can safely ignore this
            spoof_model = self.model

        if spoof_model in smbios_data.smbios_dictionary:
            if smbios_data.smbios_dictionary[spoof_model]["SecureBootModel"] is not None:
                if self.constants.sip_status is False:
                    # Force VMM as root patching breaks .im4m signature
                    self.constants.secure_status = False
                    self.constants.force_vmm = True
                else:
                    # Allow SecureBootModel
                    self.constants.secure_status = True
                    self.constants.force_vmm = False


    def _nvram_probe(self) -> None:
        """
        NVRAM specific probe
        """

        if not self.host_is_target:
            return

        if "-v" in (utilities.get_nvram("boot-args") or ""):
            self.constants.verbose_debug = True

        self.constants.custom_serial_number = utilities.get_nvram("OCLP-Spoofed-SN", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
        self.constants.custom_board_serial_number = utilities.get_nvram("OCLP-Spoofed-MLB", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
        if self.constants.custom_serial_number is None or self.constants.custom_board_serial_number is None:
            # If either variables are missing, we assume something is wrong with the spoofed variables and reset
            self.constants.custom_serial_number = ""
            self.constants.custom_board_serial_number = ""


    def _networking_probe(self) -> None:
        """
        Networking specific probe
        """

        is_legacy_wifi = False
        is_modern_wifi = False

        if self.host_is_target:
            if (
                (
                    isinstance(self.constants.computer.wifi, device_probe.Broadcom) and
                    self.constants.computer.wifi.chipset in [
                        device_probe.Broadcom.Chipsets.AirPortBrcm4331,
                        device_probe.Broadcom.Chipsets.AirPortBrcm43224,
                    ]
                ) or (
                    isinstance(self.constants.computer.wifi, device_probe.Atheros) and
                    self.constants.computer.wifi.chipset == device_probe.Atheros.Chipsets.AirPortAtheros40
                )
            ):
                is_legacy_wifi = True
            elif (
                (
                    isinstance(self.constants.computer.wifi, device_probe.Broadcom) and
                    self.constants.computer.wifi.chipset in [
                        device_probe.Broadcom.Chipsets.AirPortBrcm4360,
                        device_probe.Broadcom.Chipsets.AirportBrcmNIC,
                    ]
                )
            ):
                is_modern_wifi = True

        else:
            if self.model not in smbios_data.smbios_dictionary:
                return
            if (
                smbios_data.smbios_dictionary[self.model]["Wireless Model"] in [
                    device_probe.Broadcom.Chipsets.AirPortBrcm4331,
                    device_probe.Broadcom.Chipsets.AirPortBrcm43224,
                    device_probe.Atheros.Chipsets.AirPortAtheros40,
                ]
            ):
                is_legacy_wifi = True
            elif (
                    smbios_data.smbios_dictionary[self.model]["Wireless Model"] in [
                    device_probe.Broadcom.Chipsets.AirPortBrcm4360,
                    device_probe.Broadcom.Chipsets.AirportBrcmNIC,
                ]
            ):
                is_modern_wifi = True

        if is_legacy_wifi is False and is_modern_wifi is False:
            return

        # 12.0: Legacy Wireless chipsets require root patching
        # 14.0: Modern Wireless chipsets require root patching
        if self.model in smbios_data.smbios_dictionary:
            if smbios_data.smbios_dictionary[self.model]["Max OS Supported"] < os_data.os_data.sonoma:
                self.constants.sip_status = True
                self.constants.sip_status = False
                self.constants.secure_status = False
                self.constants.disable_cs_lv = True
                self.constants.disable_amfi = True

        # if is_legacy_wifi is True:
        #     # 13.0: Enabling AirPlay to Mac patches breaks Control Center on legacy chipsets
        #     # AirPlay to Mac was unsupported regardless, so we can safely disable it
        #     self.constants.fu_arguments = " -disable_sidecar_mac"


    def _misc_hardwares_probe(self) -> None:
        """
        Misc probe
        """
        if self.host_is_target:
            if self.constants.computer.usb_controllers:
                if self.model in smbios_data.smbios_dictionary:
                    if smbios_data.smbios_dictionary[self.model]["CPU Generation"] < cpu_data.CPUGen.ivy_bridge.value:
                        # Pre-Ivy do not natively support XHCI boot support
                        # If we detect XHCI on older model, enable
                        for controller in self.constants.computer.usb_controllers:
                            if isinstance(controller, device_probe.XHCIController):
                                self.constants.xhci_boot = True
                                break


    def _gpu_probe(self) -> None:
        """
        Graphics specific probe
        """

        gpu_archs = []
        if self.host_is_target:
            gpu_archs = [gpu.arch for gpu in self.constants.computer.gpus if gpu.class_code != 0xFFFFFFFF]
        else:
            if self.model in smbios_data.smbios_dictionary:
                gpu_archs = smbios_data.smbios_dictionary[self.model]["Stock GPUs"]

        for arch in gpu_archs:
            # Legacy Metal Logic
            if arch in [
                device_probe.Intel.Archs.Ivy_Bridge,
                device_probe.Intel.Archs.Haswell,
                device_probe.Intel.Archs.Broadwell,
                device_probe.Intel.Archs.Skylake,
                device_probe.NVIDIA.Archs.Kepler,
                device_probe.AMD.Archs.Legacy_GCN_7000,
                device_probe.AMD.Archs.Legacy_GCN_8000,
                device_probe.AMD.Archs.Legacy_GCN_9000,
                device_probe.AMD.Archs.Polaris,
                device_probe.AMD.Archs.Polaris_Spoof,
                device_probe.AMD.Archs.Vega,
                device_probe.AMD.Archs.Navi,
            ]:
                if arch in [
                    device_probe.Intel.Archs.Ivy_Bridge,
                    device_probe.Intel.Archs.Haswell,
                    device_probe.NVIDIA.Archs.Kepler,
                ]:
                    self.constants.disable_amfi = True
                    self.constants.disable_mediaanalysisd = True

                if arch in [
                        device_probe.AMD.Archs.Legacy_GCN_7000,
                        device_probe.AMD.Archs.Legacy_GCN_8000,
                        device_probe.AMD.Archs.Legacy_GCN_9000,
                        device_probe.AMD.Archs.Polaris,
                        device_probe.AMD.Archs.Polaris_Spoof,
                        device_probe.AMD.Archs.Vega,
                        device_probe.AMD.Archs.Navi,
                ]:
                    if arch == device_probe.AMD.Archs.Legacy_GCN_7000:
                        # Check if we're running in Rosetta
                        if self.host_is_target:
                            if self.constants.computer.rosetta_active is True:
                                continue

                    # Allow H.265 on AMD
                    if self.model in smbios_data.smbios_dictionary:
                        if "Socketed GPUs" in smbios_data.smbios_dictionary[self.model]:
                            self.constants.serial_settings = "Minimal"

                # See if system can use the native AMD stack in Ventura
                if arch in [
                    device_probe.AMD.Archs.Polaris,
                    device_probe.AMD.Archs.Polaris_Spoof,
                    device_probe.AMD.Archs.Vega,
                    device_probe.AMD.Archs.Navi,
                ]:
                    if self.host_is_target:
                        if "AVX2" in self.constants.computer.cpu.leafs:
                            continue
                    else:
                        if self.model in smbios_data.smbios_dictionary:
                            if smbios_data.smbios_dictionary[self.model]["CPU Generation"] >= cpu_data.CPUGen.haswell.value:
                                continue

                self.constants.sip_status = False
                self.constants.secure_status = False
                self.constants.disable_cs_lv = True

            # Non-Metal Logic
            elif arch in [
                device_probe.Intel.Archs.Iron_Lake,
                device_probe.Intel.Archs.Sandy_Bridge,
                device_probe.NVIDIA.Archs.Tesla,
                device_probe.NVIDIA.Archs.Fermi,
                device_probe.NVIDIA.Archs.Maxwell,
                device_probe.NVIDIA.Archs.Pascal,
                device_probe.AMD.Archs.TeraScale_1,
                device_probe.AMD.Archs.TeraScale_2,
            ]:
                self.constants.sip_status = False
                self.constants.secure_status = False
                self.constants.disable_cs_lv = True
                if os_data.os_data.ventura in self.constants.legacy_accel_support:
                    # Only disable AMFI if we officially support Ventura
                    self.constants.disable_amfi = True

                for key in ["Moraea_BlurBeta"]:
                    # Enable BetaBlur if user hasn't disabled it
                    is_key_enabled = subprocess.run(["/usr/bin/defaults", "read", "-globalDomain", key], stdout=subprocess.PIPE).stdout.decode("utf-8").strip()
                    if is_key_enabled not in ["false", "0"]:
                        subprocess.run(["/usr/bin/defaults", "write", "-globalDomain", key, "-bool", "true"])

    def _check_amfipass_supported(self) -> None:
        """
        Check if root volume supports AMFIPass

        The basic requirements of this function are:
        - The host is the target
        - Root volume doesn't have adhoc signed binaries

        If all of these conditions are met, it is safe to disable AMFI and CS_LV. Otherwise, for safety, leave it be.
        """

        if not self.host_is_target:
            # Unknown whether the host is using old binaries
            # Rebuild it once you are on the host
            return

        # Check for adhoc signed binaries
        if self.constants.computer.oclp_sys_signed is False:
            # Root patch with new binaries, then reboot
            return

        # Note: simply checking the authority is not enough, as the authority can be spoofed
        # (but do we really care? this is just a simple check)
        # Note: the cert will change

        self.constants.disable_amfi = False
        self.constants.disable_cs_lv = False


    def _load_gui_defaults(self) -> None:
        """
        Load GUI defaults from global settings
        """
        if not self.host_is_target:
            return
        if self.ignore_settings_file is True:
            return

        settings_plist = global_settings.GlobalEnviromentSettings().global_settings_plist
        if not Path(settings_plist).exists():
            return

        try:
            plist = plistlib.load(Path(settings_plist).open("rb"))
        except Exception as e:
            logging.error("Error: Unable to read global settings file")
            logging.error(e)
            return

        for key in plist:
            if not key.startswith("GUI:"):
                continue

            constants_key = key.replace("GUI:", "")

            if plist[key] == "PYTHON_NONE_VALUE":
                plist[key] = None

            if hasattr(self.constants, constants_key):
                # Check if type is different
                original_type = type(getattr(self.constants, constants_key))
                new_type = type(plist[key])
                if original_type != new_type:
                    logging.error(f"Global settings type mismatch for {constants_key}: {original_type} vs {new_type}")
                    logging.error(f"Removing {key} from global settings")
                    global_settings.GlobalEnviromentSettings().delete_property(key)
                    continue

                logging.info(f"Setting {constants_key} to {plist[key]}")
                setattr(self.constants, constants_key, plist[key])

#generate_smbios.py:
"""
generate_smbios.py: SMBIOS generation for OpenCore Legacy Patcher
"""

import logging

from . import utilities

from ..datasets import (
    smbios_data,
    os_data,
    cpu_data
)


def set_smbios_model_spoof(model):
    try:
        smbios_data.smbios_dictionary[model]["Screen Size"]
        # Found mobile SMBIOS
        if model.startswith("MacBookAir"):
            return "MacBookAir8,1"
        elif model.startswith("MacBookPro"):
            if smbios_data.smbios_dictionary[model]["Screen Size"] == 13:
                return "MacBookPro14,1"
            elif smbios_data.smbios_dictionary[model]["Screen Size"] >= 15:
                # 15" and 17"
                return "MacBookPro14,3"
            else:
                # Unknown Model
                raise Exception(f"Unknown SMBIOS for spoofing: {model}")
        elif model.startswith("MacBook"):
            if smbios_data.smbios_dictionary[model]["Screen Size"] == 13:
                return "MacBookAir8,1"
            elif smbios_data.smbios_dictionary[model]["Screen Size"] == 12:
                return "MacBook10,1"
            else:
                # Unknown Model
                raise Exception(f"Unknown SMBIOS for spoofing: {model}")
        else:
            # Unknown Model
            raise Exception(f"Unknown SMBIOS for spoofing: {model}")
    except KeyError:
        # Found desktop model
        if model.startswith("MacPro") or model.startswith("Xserve"):
            return "MacPro7,1"
        elif model.startswith("Macmini"):
            return "Macmini8,1"
        elif model.startswith("iMac"):
            if smbios_data.smbios_dictionary[model]["Max OS Supported"] <= os_data.os_data.high_sierra:
                # Models dropped in Mojave either do not have an iGPU, or should have them disabled
                return "iMacPro1,1"
            else:
                return "iMac18,3"
        else:
            # Unknown Model
            raise Exception(f"Unknown SMBIOS for spoofing: {model}")


def update_firmware_features(firmwarefeature):
    # Adjust FirmwareFeature to support everything macOS requires
    # APFS Bit (19/20): 10.13+ (OSInstall)
    # Large BaseSystem Bit (35): 12.0 B7+ (patchd)
    # https://github.com/acidanthera/OpenCorePkg/tree/2f76673546ac3e32d2e2d528095fddcd66ad6a23/Include/Apple/IndustryStandard/AppleFeatures.h
    firmwarefeature |= 2 ** 19  # FW_FEATURE_SUPPORTS_APFS
    firmwarefeature |= 2 ** 20  # FW_FEATURE_SUPPORTS_APFS_EXTRA
    firmwarefeature |= 2 ** 35  # FW_FEATURE_SUPPORTS_LARGE_BASESYSTEM
    return firmwarefeature


def generate_fw_features(model, custom):
    if not custom:
        firmwarefeature = utilities.get_rom("firmware-features")
        if not firmwarefeature:
            logging.info("- Failed to find FirmwareFeatures, falling back on defaults")
            if smbios_data.smbios_dictionary[model]["FirmwareFeatures"] is None:
                firmwarefeature = 0
            else:
                firmwarefeature = int(smbios_data.smbios_dictionary[model]["FirmwareFeatures"], 16)
    else:
        if smbios_data.smbios_dictionary[model]["FirmwareFeatures"] is None:
            firmwarefeature = 0
        else:
            firmwarefeature = int(smbios_data.smbios_dictionary[model]["FirmwareFeatures"], 16)
    firmwarefeature = update_firmware_features(firmwarefeature)
    return firmwarefeature


def find_model_off_board(board):
    # Find model based off Board ID provided
    # Return none if unknown

    # Strip extra data from Target Types (ap, uppercase)
    if not (board.startswith("Mac-") or board.startswith("VMM-")):
        if board.lower().endswith("ap"):
            board = board[:-2]
        board = board.lower()

    for key in smbios_data.smbios_dictionary:
        if board in [smbios_data.smbios_dictionary[key]["Board ID"], smbios_data.smbios_dictionary[key]["SecureBootModel"]]:
            if key.endswith("_v2") or key.endswith("_v3") or key.endswith("_v4"):
                # smbios_data has duplicate SMBIOS to handle multiple board IDs
                key = key[:-3]
            if key == "MacPro4,1":
                # 4,1 and 5,1 have the same board ID, best to return the newer ID
                key = "MacPro5,1"
            return key
    return None

def find_board_off_model(model):
    if model in smbios_data.smbios_dictionary:
        return smbios_data.smbios_dictionary[model]["Board ID"]
    else:
        return None


def check_firewire(model):
    # MacBooks never supported FireWire
    # Pre-Thunderbolt MacBook Airs as well
    if model.startswith("MacBookPro"):
        return True
    elif model.startswith("MacBookAir"):
        if smbios_data.smbios_dictionary[model]["CPU Generation"] < cpu_data.CPUGen.sandy_bridge.value:
            return False
    elif model.startswith("MacBook"):
        return False
    else:
        return True

def determine_best_board_id_for_sandy(current_board_id, gpus):
    # This function is mainly for users who are either spoofing or using hackintoshes
    # Generally hackintosh will use whatever the latest SMBIOS is, so we need to determine
    # the best Board ID to patch inside of AppleIntelSNBGraphicsFB

    # Currently the kext supports the following models:
    #   MacBookPro8,1 - Mac-94245B3640C91C81 (13")
    #   MacBookPro8,2 - Mac-94245A3940C91C80 (15")
    #   MacBookPro8,3 - Mac-942459F5819B171B (17")
    #   MacBookAir4,1 - Mac-C08A6BB70A942AC2 (11")
    #   MacBookAir4,2 - Mac-742912EFDBEE19B3 (13")
    #   Macmini5,1    - Mac-8ED6AF5B48C039E1
    #   Macmini5,2    - Mac-4BC72D62AD45599E (headless)
    #   Macmini5,3    - Mac-7BA5B2794B2CDB12
    #   iMac12,1      - Mac-942B5BF58194151B (headless)
    #   iMac12,2      - Mac-942B59F58194171B (headless)
    #   Unknown(MBP)  - Mac-94245AF5819B141B
    #   Unknown(iMac) - Mac-942B5B3A40C91381 (headless)
    if current_board_id:
        model = find_model_off_board(current_board_id)
        if model:
            if model.startswith("MacBook"):
                try:
                    size = int(smbios_data.smbios_dictionary[model]["Screen Size"])
                except KeyError:
                    size = 13 # Assume 13 if it's missing
                if model.startswith("MacBookPro"):
                    if size >= 17:
                        return find_board_off_model("MacBookPro8,3")
                    elif size >= 15:
                        return find_board_off_model("MacBookPro8,2")
                    else:
                        return find_board_off_model("MacBookPro8,1")
                else: # MacBook and MacBookAir
                    if size >= 13:
                        return find_board_off_model("MacBookAir4,2")
                    else:
                        return find_board_off_model("MacBookAir4,1")
            else:
                # We're working with a desktop, so need to figure out whether the unit is running headless or not
                if len(gpus) > 1:
                    # More than 1 GPU detected, assume headless
                    if model.startswith("Macmini"):
                        return find_board_off_model("Macmini5,2")
                    else:
                        return find_board_off_model("iMac12,2")
                else:
                    return find_board_off_model("Macmini5,1")
    return find_board_off_model("Macmini5,1") # Safest bet if we somehow don't know the model

#global_settings.py:
"""
global_settings.py: Library for querying and writing global enviroment settings

Alternative to Apple's 'defaults' tool
Store data in '/Users/Shared'
This is to ensure compatibility when running without a user
ie. during automated patching
"""

import logging
import plistlib

from pathlib import Path


class GlobalEnviromentSettings:
    """
    Library for querying and writing global enviroment settings
    """

    def __init__(self) -> None:
        self.file_name:              str = ".com.dortania.opencore-legacy-patcher.plist"
        self.global_settings_folder: str = "/Users/Shared"
        self.global_settings_plist:  str = f"{self.global_settings_folder}/{self.file_name}"

        self._generate_settings_file()
        self._convert_defaults_to_global_settings()


    def read_property(self, property_name: str) -> str:
        """
        Reads a property from the global settings file
        """

        if Path(self.global_settings_plist).exists():
            try:
                plist = plistlib.load(Path(self.global_settings_plist).open("rb"))
            except Exception as e:
                logging.error("Error: Unable to read global settings file")
                logging.error(e)
                return None
            if property_name in plist:
                return plist[property_name]
        return None


    def delete_property(self, property_name: str) -> None:
        """
        Deletes a property from the global settings file
        """
        if Path(self.global_settings_plist).exists():
            try:
                plist = plistlib.load(Path(self.global_settings_plist).open("rb"))
            except Exception as e:
                logging.error("Error: Unable to read global settings file")
                logging.error(e)
                return
            if property_name in plist:
                del plist[property_name]
                try:
                    plistlib.dump(plist, Path(self.global_settings_plist).open("wb"))
                except PermissionError:
                    logging.info("Failed to write to global settings")


    def write_property(self, property_name: str, property_value) -> None:
        """
        Writes a property to the global settings file
        """

        if Path(self.global_settings_plist).exists():
            try:
                plist = plistlib.load(Path(self.global_settings_plist).open("rb"))
            except Exception as e:
                logging.error("Error: Unable to read global settings file")
                logging.error(e)
                return
            plist[property_name] = property_value
            try:
                plistlib.dump(plist, Path(self.global_settings_plist).open("wb"))
            except PermissionError:
                logging.info("Failed to write to global settings file")


    def _generate_settings_file(self) -> None:
        if Path(self.global_settings_plist).exists():
            return
        try:
            plistlib.dump({"Developed by Dortania": True,}, Path(self.global_settings_plist).open("wb"))
        except PermissionError:
            logging.info("Permission error: Unable to write to global settings file")


    def _convert_defaults_to_global_settings(self) -> None:
        """
        Converts legacy defaults to global settings
        """

        defaults_path = "~/Library/Preferences/com.dortania.opencore-legacy-patcher.plist"
        defaults_path = Path(defaults_path).expanduser()

        if Path(defaults_path).exists():
            # merge defaults with global settings
            try:
                defaults_plist = plistlib.load(Path(defaults_path).open("rb"))
                global_settings_plist = plistlib.load(Path(self.global_settings_plist).open("rb"))
            except Exception as e:
                logging.error("Error: Unable to read global settings file")
                logging.error(e)
                return
            global_settings_plist.update(defaults_plist)
            try:
                plistlib.dump(global_settings_plist, Path(self.global_settings_plist).open("wb"))
            except PermissionError:
                logging.info("Permission error: Unable to write to global settings file")
                return

            # delete defaults plist
            try:
                Path(defaults_path).unlink()
            except Exception as e:
                logging.error("Error: Unable to delete defaults plist")
                logging.error(e)

# install.py:
"""
install.py: Installation of OpenCore files to ESP
"""

import logging
import plistlib
import subprocess
import re

from pathlib import Path

from . import utilities, subprocess_wrapper

from .. import constants


class tui_disk_installation:
    def __init__(self, versions):
        self.constants: constants.Constants = versions

    def list_disks(self):
        all_disks = {}
        # TODO: AllDisksAndPartitions is not supported in Snow Leopard and older
        try:
            # High Sierra and newer
            disks = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "list", "-plist", "physical"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        except ValueError:
            # Sierra and older
            disks = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "list", "-plist"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        for disk in disks["AllDisksAndPartitions"]:
            try:
                disk_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", disk["DeviceIdentifier"]], stdout=subprocess.PIPE).stdout.decode().strip().encode())
            except:
                # Chinesium USB can have garbage data in MediaName
                diskutil_output = subprocess.run(["/usr/sbin/diskutil", "info", "-plist", disk["DeviceIdentifier"]], stdout=subprocess.PIPE).stdout.decode().strip()
                ungarbafied_output = re.sub(r'(<key>MediaName</key>\s*<string>).*?(</string>)', r'\1\2', diskutil_output).encode()
                disk_info = plistlib.loads(ungarbafied_output)
            try:
                all_disks[disk["DeviceIdentifier"]] = {"identifier": disk_info["DeviceNode"], "name": disk_info.get("MediaName", "Disk"), "size": disk_info["TotalSize"], "partitions": {}}
                for partition in disk["Partitions"]:
                    partition_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", partition["DeviceIdentifier"]], stdout=subprocess.PIPE).stdout.decode().strip().encode())
                    all_disks[disk["DeviceIdentifier"]]["partitions"][partition["DeviceIdentifier"]] = {
                        "fs": partition_info.get("FilesystemType", partition_info["Content"]),
                        "type": partition_info["Content"],
                        "name": partition_info.get("VolumeName", ""),
                        "size": partition_info["TotalSize"],
                    }
            except KeyError:
                # Avoid crashing with CDs installed
                continue

        supported_disks = {}
        for disk in all_disks:
            if not any(all_disks[disk]["partitions"][partition]["fs"] in ("msdos", "EFI") for partition in all_disks[disk]["partitions"]):
                continue
            supported_disks.update({
                disk: {
                    "disk": disk,
                    "name": all_disks[disk]["name"],
                    "size": utilities.human_fmt(all_disks[disk]['size']),
                    "partitions": all_disks[disk]["partitions"]
                }
            })
        return supported_disks

    def list_partitions(self, disk_response, supported_disks):
        # Takes disk UUID as well as diskutil dataset generated by list_disks
        # Returns list of FAT32 partitions
        disk_identifier = disk_response
        selected_disk = supported_disks[disk_identifier]

        supported_partitions = {}

        for partition in selected_disk["partitions"]:
            if selected_disk["partitions"][partition]["fs"] not in ("msdos", "EFI"):
                continue
            supported_partitions.update({
                partition: {
                    "partition": partition,
                    "name": selected_disk["partitions"][partition]["name"],
                    "size": utilities.human_fmt(selected_disk["partitions"][partition]["size"])
                }
            })
        return supported_partitions


    def _determine_sd_card(self, media_name: str):
        # Array filled with common SD Card names
        # Note most USB-based SD Card readers generally report as "Storage Device"
        # Thus no reliable way to detect further without parsing IOService output (kUSBProductString)
        if any(x in media_name for x in ("SD Card", "SD/MMC", "SDXC Reader", "SD Reader", "Card Reader")):
            return True
        return False


    def install_opencore(self, full_disk_identifier: str):
        # TODO: Apple Script fails in Yosemite(?) and older
        logging.info(f"Mounting partition: {full_disk_identifier}")
        result = subprocess_wrapper.run_as_root(["/usr/sbin/diskutil", "mount", full_disk_identifier], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            logging.info("Mount failed")
            subprocess_wrapper.log(result)
            return

        partition_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", full_disk_identifier], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        parent_disk = partition_info["ParentWholeDisk"]
        drive_host_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", parent_disk], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        sd_type = drive_host_info.get("MediaName", "Disk")
        try:
            ssd_type = drive_host_info["SolidState"]
        except KeyError:
            ssd_type = False
        mount_path = Path(partition_info["MountPoint"])
        disk_type = partition_info["BusProtocol"]

        if not mount_path.exists():
            logging.info("EFI failed to mount!")
            return False

        if (mount_path / Path("EFI/OC")).exists():
            logging.info("Removing preexisting EFI/OC folder")
            subprocess.run(["/bin/rm", "-rf", mount_path / Path("EFI/OC")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if (mount_path / Path("System")).exists():
            logging.info("Removing preexisting System folder")
            subprocess.run(["/bin/rm", "-rf", mount_path / Path("System")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if (mount_path / Path("boot.efi")).exists():
            logging.info("Removing preexisting boot.efi")
            subprocess.run(["/bin/rm", mount_path / Path("boot.efi")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        logging.info("Copying OpenCore onto EFI partition")
        subprocess.run(["/bin/mkdir", "-p", mount_path / Path("EFI")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["/bin/cp", "-r", self.constants.opencore_release_folder / Path("EFI/OC"), mount_path / Path("EFI/OC")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        subprocess.run(["/bin/cp", "-r", self.constants.opencore_release_folder / Path("System"), mount_path / Path("System")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if Path(self.constants.opencore_release_folder / Path("boot.efi")).exists():
            subprocess.run(["/bin/cp", self.constants.opencore_release_folder / Path("boot.efi"), mount_path / Path("boot.efi")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if self.constants.boot_efi is True:
            logging.info("Converting Bootstrap to BOOTx64.efi")
            if (mount_path / Path("EFI/BOOT")).exists():
                subprocess.run(["/bin/rm", "-rf", mount_path / Path("EFI/BOOT")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            Path(mount_path / Path("EFI/BOOT")).mkdir()
            subprocess.run(["/bin/mv", mount_path / Path("System/Library/CoreServices/boot.efi"), mount_path / Path("EFI/BOOT/BOOTx64.efi")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            subprocess.run(["/bin/rm", "-rf", mount_path / Path("System")], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        if self._determine_sd_card(sd_type) is True:
            logging.info("Adding SD Card icon")
            subprocess.run(["/bin/cp", self.constants.icon_path_sd, mount_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        elif ssd_type is True:
            logging.info("Adding SSD icon")
            subprocess.run(["/bin/cp", self.constants.icon_path_ssd, mount_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        elif disk_type == "USB":
            logging.info("Adding External USB Drive icon")
            subprocess.run(["/bin/cp", self.constants.icon_path_external, mount_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            logging.info("Adding Internal Drive icon")
            subprocess.run(["/bin/cp", self.constants.icon_path_internal, mount_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        logging.info("Cleaning install location")
        if not self.constants.recovery_status:
            logging.info("Unmounting EFI partition")
            subprocess.run(["/usr/sbin/diskutil", "umount", mount_path], stdout=subprocess.PIPE).stdout.decode().strip().encode()

        logging.info("OpenCore transfer complete")

        return True

#integrity_verification.py:
"""
integrity_verification.py: Validate the integrity of Apple downloaded files via .chunklist and .integrityDataV1 files

Based off of chunklist.py:
- https://gist.github.com/dhinakg/cbe30edf31ddc153fd0b0c0570c9b041
"""

import enum
import hashlib
import logging
import binascii
import threading

from typing import Union
from pathlib import Path

CHUNK_LENGTH = 4 + 32


class ChunklistStatus(enum.Enum):
    """
    Chunklist status
    """
    IN_PROGRESS = 0
    SUCCESS     = 1
    FAILURE     = 2


class ChunklistVerification:
    """
    Library to validate Apple's files against their chunklist format
    Supports both chunklist and integrityDataV1 files
    - Ref: https://github.com/apple-oss-distributions/xnu/blob/xnu-8020.101.4/bsd/kern/chunklist.h

    Parameters:
        file_path      (Path): Path to the file to validate
        chunklist_path (Path): Path to the chunklist file

    Usage:
        >>> chunk_obj = ChunklistVerification("InstallAssistant.pkg", "InstallAssistant.pkg.integrityDataV1")
        >>> chunk_obj.validate()
        >>> while chunk_obj.status == ChunklistStatus.IN_PROGRESS:
        ...     print(f"Validating {chunk_obj.current_chunk} of {chunk_obj.total_chunks}")

        >>> if chunk_obj.status == ChunklistStatus.FAILURE:
        ...     print(chunk_obj.error_msg)
    """

    def __init__(self, file_path: Path, chunklist_path: Union[Path, bytes]) -> None:
        if isinstance(chunklist_path, bytes):
            self.chunklist_path: bytes = chunklist_path
        else:
            self.chunklist_path: Path = Path(chunklist_path)
        self.file_path:          Path = Path(file_path)

        self.chunks: dict = self._generate_chunks(self.chunklist_path)

        self.error_msg:     str = ""
        self.current_chunk: int = 0
        self.total_chunks:  int = len(self.chunks)

        self.status: ChunklistStatus = ChunklistStatus.IN_PROGRESS


    def _generate_chunks(self, chunklist: Union[Path, bytes]) -> dict:
        """
        Generate a dictionary of the chunklist header and chunks

        Parameters:
            chunklist (Path | bytes): Path to the chunklist file or the chunklist file itself
        """

        chunklist: bytes = chunklist if isinstance(chunklist, bytes) else chunklist.read_bytes()

        # Ref: https://github.com/apple-oss-distributions/xnu/blob/xnu-8020.101.4/bsd/kern/chunklist.h#L59-L69
        header: dict = {
            "magic":       chunklist[:4],
            "length":      int.from_bytes(chunklist[4:8], "little"),
            "fileVersion": chunklist[8],
            "chunkMethod": chunklist[9],
            "sigMethod":   chunklist[10],
            "chunkCount":  int.from_bytes(chunklist[12:20], "little"),
            "chunkOffset": int.from_bytes(chunklist[20:28], "little"),
            "sigOffset":   int.from_bytes(chunklist[28:36], "little")
        }

        if header["magic"] != b"CNKL":
            return None

        all_chunks = chunklist[header["chunkOffset"]:header["chunkOffset"]+header["chunkCount"]*CHUNK_LENGTH]
        chunks = [{"length": int.from_bytes(all_chunks[i:i+4], "little"), "checksum": all_chunks[i+4:i+CHUNK_LENGTH]} for i in range(0, len(all_chunks), CHUNK_LENGTH)]

        return chunks


    def _validate(self) -> None:
        """
        Validates provided file against chunklist
        """

        if self.chunks is None:
            self.status = ChunklistStatus.FAILURE
            return

        if not Path(self.file_path).exists():
            self.error_msg = f"File {self.file_path} does not exist"
            self.status = ChunklistStatus.FAILURE
            logging.info(self.error_msg)
            return

        if not Path(self.file_path).is_file():
            self.error_msg = f"File {self.file_path} is not a file"
            self.status = ChunklistStatus.FAILURE
            logging.info(self.error_msg)
            return

        with self.file_path.open("rb") as f:
            for chunk in self.chunks:
                self.current_chunk += 1
                status = hashlib.sha256(f.read(chunk["length"])).digest()
                if status != chunk["checksum"]:
                    self.error_msg = f"Chunk {self.current_chunk} checksum status FAIL: chunk sum {binascii.hexlify(chunk['checksum']).decode()}, calculated sum {binascii.hexlify(status).decode()}"
                    self.status = ChunklistStatus.FAILURE
                    logging.info(self.error_msg)
                    return

        self.status = ChunklistStatus.SUCCESS


    def validate(self) -> None:
        """
        Spawns _validate() thread
        """
        threading.Thread(target=self._validate).start()


#kdk_handler.py:
"""
kdk_handler.py: Module for parsing and determining best Kernel Debug Kit for host OS
"""

import logging
import plistlib
import requests
import tempfile
import subprocess
import packaging.version

from typing import cast
from pathlib import Path

from .. import constants

from ..datasets import os_data
from ..volume   import generate_copy_arguments

from . import (
    network_handler,
    subprocess_wrapper
)

KDK_INSTALL_PATH: str  = "/Library/Developer/KDKs"
KDK_INFO_PLIST:   str  = "KDKInfo.plist"
KDK_API_LINK:     str  = "https://dortania.github.io/KdkSupportPkg/manifest.json"

KDK_ASSET_LIST:   list = None


class KernelDebugKitObject:
    """
    Library for querying and downloading Kernel Debug Kits (KDK) for macOS

    Usage:
        >>> kdk_object = KernelDebugKitObject(constants, host_build, host_version)

        >>> if kdk_object.success:

        >>>     # Query whether a KDK is already installed
        >>>     if kdk_object.kdk_already_installed:
        >>>         # Use the installed KDK
        >>>         kdk_path = kdk_object.kdk_installed_path

        >>>     else:
        >>>         # Get DownloadObject for the KDK
        >>>         # See network_handler.py's DownloadObject documentation for usage
        >>>         kdk_download_object = kdk_object.retrieve_download()

        >>>         # Once downloaded, recommend verifying KDK's checksum
        >>>         valid = kdk_object.validate_kdk_checksum()

    """

    def __init__(self, global_constants: constants.Constants,
                 host_build: str, host_version: str,
                 ignore_installed: bool = False, passive: bool = False,
                 check_backups_only: bool = False
        ) -> None:

        self.constants: constants.Constants = global_constants

        self.host_build:   str = host_build    # ex. 20A5384c
        self.host_version: str = host_version  # ex. 11.0.1

        self.passive: bool = passive  # Don't perform actions requiring elevated privileges

        self.ignore_installed:      bool = ignore_installed   # If True, will ignore any installed KDKs and download the latest
        self.check_backups_only:    bool = check_backups_only # If True, will only check for KDK backups, not KDKs already installed
        self.kdk_already_installed: bool = False

        self.kdk_installed_path: str = ""

        self.kdk_url:         str = ""
        self.kdk_url_build:   str = ""
        self.kdk_url_version: str = ""

        self.kdk_url_expected_size: int = 0

        self.kdk_url_is_exactly_match: bool = False

        self.kdk_closest_match_url:         str = ""
        self.kdk_closest_match_url_build:   str = ""
        self.kdk_closest_match_url_version: str = ""

        self.kdk_closest_match_url_expected_size: int = 0

        self.success: bool = False

        self.error_msg: str = ""

        self._get_latest_kdk()


    def _get_remote_kdks(self) -> list:
        """
        Fetches a list of available KDKs from the KdkSupportPkg API
        Additionally caches the list for future use, avoiding extra API calls

        Returns:
            list: A list of KDKs, sorted by version and date if available. Returns None if the API is unreachable
        """

        global KDK_ASSET_LIST

        logging.info("Pulling KDK list from KdkSupportPkg API")
        if KDK_ASSET_LIST:
            return KDK_ASSET_LIST

        try:
            results = network_handler.NetworkUtilities().get(
                KDK_API_LINK,
                headers={
                    "User-Agent": f"OCLP/{self.constants.patcher_version}"
                },
                timeout=5
            )
        except (requests.exceptions.Timeout, requests.exceptions.TooManyRedirects, requests.exceptions.ConnectionError):
            logging.info("Could not contact KDK API")
            return None

        if results.status_code != 200:
            logging.info("Could not fetch KDK list")
            return None

        KDK_ASSET_LIST = results.json()

        return KDK_ASSET_LIST


    def _get_latest_kdk(self, host_build: str = None, host_version: str = None) -> None:
        """
        Fetches the latest KDK for the current macOS version

        Parameters:
            host_build (str, optional):   The build version of the current macOS version.
                                          If empty, will use the host_build from the class. Defaults to None.
            host_version (str, optional): The version of the current macOS version.
                                          If empty, will use the host_version from the class. Defaults to None.
        """

        if host_build is None and host_version is None:
            host_build   = self.host_build
            host_version = self.host_version

        parsed_version = cast(packaging.version.Version, packaging.version.parse(host_version))

        if os_data.os_conversion.os_to_kernel(str(parsed_version.major)) < os_data.os_data.ventura:
            self.error_msg = "KDKs are not required for macOS Monterey or older"
            logging.warning(f"{self.error_msg}")
            return

        self.kdk_installed_path = self._local_kdk_installed()
        if self.kdk_installed_path:
            logging.info(f"KDK already installed ({Path(self.kdk_installed_path).name}), skipping")
            self.kdk_already_installed = True
            self.success = True
            return

        remote_kdk_version = self._get_remote_kdks()

        if remote_kdk_version is None:
            logging.warning("Failed to fetch KDK list, falling back to local KDK matching")

            # First check if a KDK matching the current macOS version is installed
            # ex. 13.0.1 vs 13.0
            loose_version = f"{parsed_version.major}.{parsed_version.minor}"
            logging.info(f"Checking for KDKs loosely matching {loose_version}")
            self.kdk_installed_path = self._local_kdk_installed(match=loose_version, check_version=True)
            if self.kdk_installed_path:
                logging.info(f"Found matching KDK: {Path(self.kdk_installed_path).name}")
                self.kdk_already_installed = True
                self.success = True
                return

            older_version = f"{parsed_version.major}.{parsed_version.minor - 1 if parsed_version.minor > 0 else 0}"
            logging.info(f"Checking for KDKs matching {older_version}")
            self.kdk_installed_path = self._local_kdk_installed(match=older_version, check_version=True)
            if self.kdk_installed_path:
                logging.info(f"Found matching KDK: {Path(self.kdk_installed_path).name}")
                self.kdk_already_installed = True
                self.success = True
                return

            logging.warning(f"Couldn't find KDK matching {host_version} or {older_version}, please install one manually")

            self.error_msg = f"Could not contact KdkSupportPkg API, and no KDK matching {host_version} ({host_build}) or {older_version} was installed.\nPlease ensure you have a network connection or manually install a KDK."

            return

        # First check exact match
        for kdk in remote_kdk_version:
            if (kdk["build"] != host_build):
                continue
            self.kdk_url = kdk["url"]
            self.kdk_url_build = kdk["build"]
            self.kdk_url_version = kdk["version"]
            self.kdk_url_expected_size = kdk["fileSize"]
            self.kdk_url_is_exactly_match = True
            break

        # If no exact match, check for closest match
        if self.kdk_url == "":
            for kdk in remote_kdk_version:
                kdk_version = cast(packaging.version.Version, packaging.version.parse(kdk["version"]))
                if kdk_version > parsed_version:
                    continue
                if kdk_version.major != parsed_version.major:
                    continue
                if kdk_version.minor not in range(parsed_version.minor - 1, parsed_version.minor + 1):
                    continue

                # The KDK list is already sorted by version then date, so the first match is the closest
                self.kdk_closest_match_url = kdk["url"]
                self.kdk_closest_match_url_build = kdk["build"]
                self.kdk_closest_match_url_version = kdk["version"]
                self.kdk_closest_match_url_expected_size = kdk["fileSize"]
                self.kdk_url_is_exactly_match = False
                break

        if self.kdk_url == "":
            if self.kdk_closest_match_url == "":
                logging.warning(f"No KDKs found for {host_build} ({host_version})")
                self.error_msg = f"No KDKs found for {host_build} ({host_version})"
                return
            logging.info(f"No direct match found for {host_build}, falling back to closest match")
            logging.info(f"Closest Match: {self.kdk_closest_match_url_build} ({self.kdk_closest_match_url_version})")

            self.kdk_url = self.kdk_closest_match_url
            self.kdk_url_build = self.kdk_closest_match_url_build
            self.kdk_url_version = self.kdk_closest_match_url_version
            self.kdk_url_expected_size = self.kdk_closest_match_url_expected_size
        else:
            logging.info(f"Direct match found for {host_build} ({host_version})")


        # Check if this KDK is already installed
        self.kdk_installed_path = self._local_kdk_installed(match=self.kdk_url_build)
        if self.kdk_installed_path:
            logging.info(f"KDK already installed ({Path(self.kdk_installed_path).name}), skipping")
            self.kdk_already_installed = True
            self.success = True
            return

        logging.info("Following KDK is recommended:")
        logging.info(f"- KDK Build: {self.kdk_url_build}")
        logging.info(f"- KDK Version: {self.kdk_url_version}")
        logging.info(f"- KDK URL: {self.kdk_url}")

        self.success = True


    def retrieve_download(self, override_path: str = "") -> network_handler.DownloadObject:
        """
        Returns a DownloadObject for the KDK

        Parameters:
            override_path (str): Override the default download path

        Returns:
            DownloadObject: DownloadObject for the KDK, None if no download required
        """

        self.success = False
        self.error_msg = ""

        if self.kdk_already_installed:
            logging.info("No download required, KDK already installed")
            self.success = True
            return None

        if self.kdk_url == "":
            self.error_msg = "Could not retrieve KDK catalog, no KDK to download"
            logging.error(self.error_msg)
            return None

        logging.info(f"Returning DownloadObject for KDK: {Path(self.kdk_url).name}")
        self.success = True

        kdk_download_path = self.constants.kdk_download_path if override_path == "" else Path(override_path)
        kdk_plist_path = Path(f"{kdk_download_path.parent}/{KDK_INFO_PLIST}") if override_path == "" else Path(f"{Path(override_path).parent}/{KDK_INFO_PLIST}")

        self._generate_kdk_info_plist(kdk_plist_path)
        return network_handler.DownloadObject(self.kdk_url, kdk_download_path)


    def _generate_kdk_info_plist(self, plist_path: str) -> None:
        """
        Generates a KDK Info.plist

        """

        plist_path = Path(plist_path)
        if plist_path.exists():
            plist_path.unlink()

        kdk_dict = {
            "build": self.kdk_url_build,
            "version": self.kdk_url_version,
        }

        try:
            plist_path.touch()
            plistlib.dump(kdk_dict, plist_path.open("wb"), sort_keys=False)
        except Exception as e:
            logging.error(f"Failed to generate KDK Info.plist: {e}")


    def _local_kdk_valid(self, kdk_path: Path) -> bool:
        """
        Validates provided KDK, ensure no corruption

        The reason for this is due to macOS deleting files from the KDK during OS updates,
        similar to how Install macOS.app is deleted during OS updates

        Uses Apple's pkg receipt system to verify the original contents of the KDK

        Parameters:
            kdk_path (Path): Path to KDK

        Returns:
            bool: True if valid, False if invalid
        """

        if not Path(f"{kdk_path}/System/Library/CoreServices/SystemVersion.plist").exists():
            logging.info(f"Corrupted KDK found ({kdk_path.name}), removing due to missing SystemVersion.plist")
            self._remove_kdk(kdk_path)
            return False

        # Get build from KDK
        kdk_plist_data = plistlib.load(Path(f"{kdk_path}/System/Library/CoreServices/SystemVersion.plist").open("rb"))
        if "ProductBuildVersion" not in kdk_plist_data:
            logging.info(f"Corrupted KDK found ({kdk_path.name}), removing due to missing ProductBuildVersion")
            self._remove_kdk(kdk_path)
            return False

        kdk_build = kdk_plist_data["ProductBuildVersion"]

        # Check pkg receipts for this build, will give a canonical list if all files that should be present
        result = subprocess.run(["/usr/sbin/pkgutil", "--files", f"com.apple.pkg.KDK.{kdk_build}"], capture_output=True)
        if result.returncode != 0:
            # If pkg receipt is missing, we'll fallback to legacy validation
            logging.info(f"pkg receipt missing for {kdk_path.name}, falling back to legacy validation")
            return self._local_kdk_valid_legacy(kdk_path)

        # Go through each line of the pkg receipt and ensure it exists
        for line in result.stdout.decode("utf-8").splitlines():
            if not line.startswith("System/Library/Extensions"):
                continue
            if not Path(f"{kdk_path}/{line}").exists():
                logging.info(f"Corrupted KDK found ({kdk_path.name}), removing due to missing file: {line}")
                self._remove_kdk(kdk_path)
                return False

        return True


    def _local_kdk_valid_legacy(self, kdk_path: Path) -> bool:
        """
        Legacy variant of validating provided KDK
        Uses best guess of files that should be present
        This should ideally never be invoked, but used as a fallback

        Parameters:
            kdk_path (Path): Path to KDK

        Returns:
            bool: True if valid, False if invalid
        """

        KEXT_CATALOG = [
            "System.kext/PlugIns/Libkern.kext/Libkern",
            "apfs.kext/Contents/MacOS/apfs",
            "IOUSBHostFamily.kext/Contents/MacOS/IOUSBHostFamily",
            "AMDRadeonX6000.kext/Contents/MacOS/AMDRadeonX6000",
        ]

        for kext in KEXT_CATALOG:
            if not Path(f"{kdk_path}/System/Library/Extensions/{kext}").exists():
                logging.info(f"Corrupted KDK found, removing due to missing: {kdk_path}/System/Library/Extensions/{kext}")
                self._remove_kdk(kdk_path)
                return False

        return True


    def _local_kdk_installed(self, match: str = None, check_version: bool = False) -> str:
        """
        Checks if KDK matching build is installed
        If so, validates it has not been corrupted

        Parameters:
            match (str): string to match against (ex. build or version)
            check_version (bool): If True, match against version, otherwise match against build

        Returns:
            str: Path to KDK if valid, None if not
        """

        if self.ignore_installed is True:
            return None

        if match is None:
            if check_version:
                match = self.host_version
            else:
                match = self.host_build

        if not Path(KDK_INSTALL_PATH).exists():
            return None

        # Installed KDKs only
        if self.check_backups_only is False:
            for kdk_folder in Path(KDK_INSTALL_PATH).iterdir():
                if not kdk_folder.is_dir():
                    continue
                if check_version:
                    if match not in kdk_folder.name:
                        continue
                else:
                    if not kdk_folder.name.endswith(f"{match}.kdk"):
                        continue

                if self._local_kdk_valid(kdk_folder):
                    return kdk_folder

        # If we can't find a KDK, next check if there's a backup present
        # Check for KDK packages in the same directory as the KDK
        for kdk_pkg in Path(KDK_INSTALL_PATH).iterdir():
            if kdk_pkg.is_dir():
                continue
            if not kdk_pkg.name.endswith(".pkg"):
                continue
            if check_version:
                if match not in kdk_pkg.name:
                    continue
            else:
                if not kdk_pkg.name.endswith(f"{match}.pkg"):
                    continue

            logging.info(f"Found KDK backup: {kdk_pkg.name}")
            if self.passive is False:
                logging.info("Attempting KDK restoration")
                if KernelDebugKitUtilities().install_kdk_pkg(kdk_pkg):
                    logging.info("Successfully restored KDK")
                    return self._local_kdk_installed(match=match, check_version=check_version)
            else:
                # When in passive mode, we're just checking if a KDK could be restored
                logging.info("KDK restoration skipped, running in passive mode")
                return kdk_pkg

        return None


    def _remove_kdk(self, kdk_path: str) -> None:
        """
        Removes provided KDK

        Parameters:
            kdk_path (str): Path to KDK
        """

        if self.passive is True:
            return

        if not Path(kdk_path).exists():
            logging.warning(f"KDK does not exist: {kdk_path}")
            return

        rm_args = ["/bin/rm", "-rf" if Path(kdk_path).is_dir() else "-f", kdk_path]

        result = subprocess_wrapper.run_as_root(rm_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.warning(f"Failed to remove KDK: {kdk_path}")
            subprocess_wrapper.log(result)
            return

        logging.info(f"Successfully removed KDK: {kdk_path}")


    def _remove_unused_kdks(self, exclude_builds: list = None) -> None:
        """
        Removes KDKs that are not in use

        Parameters:
            exclude_builds (list, optional): Builds to exclude from removal.
                                             If None, defaults to host and closest match builds.
        """

        if self.passive is True:
            return

        if exclude_builds is None:
            exclude_builds = [
                self.kdk_url_build,
                self.kdk_closest_match_url_build,
            ]

        if self.constants.should_nuke_kdks is False:
            return

        if not Path(KDK_INSTALL_PATH).exists():
            return

        logging.info("Cleaning unused KDKs")
        for kdk_folder in Path(KDK_INSTALL_PATH).iterdir():
            if kdk_folder.name.endswith(".kdk") or kdk_folder.name.endswith(".pkg"):
                should_remove = True
                for build in exclude_builds:
                    if kdk_folder.name.endswith(f"_{build}.kdk") or kdk_folder.name.endswith(f"_{build}.pkg"):
                        should_remove = False
                        break
                if should_remove is False:
                    continue
                self._remove_kdk(kdk_folder)


    def validate_kdk_checksum(self, kdk_dmg_path: str = None) -> bool:
        """
        Validates KDK DMG checksum

        Parameters:
            kdk_dmg_path (str, optional): Path to KDK DMG. Defaults to None.

        Returns:
            bool: True if valid, False if invalid
        """

        self.success = False
        self.error_msg = ""

        if kdk_dmg_path is None:
            kdk_dmg_path = self.constants.kdk_download_path

        if not Path(kdk_dmg_path).exists():
            logging.error(f"KDK DMG does not exist: {kdk_dmg_path}")
            return False

        # TODO: should we use the checksum from the API?
        result = subprocess.run(["/usr/bin/hdiutil", "verify", self.constants.kdk_download_path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            logging.info("Error: Kernel Debug Kit checksum verification failed!")
            subprocess_wrapper.log(result)
            msg = "Kernel Debug Kit checksum verification failed, please try again.\n\nIf this continues to fail, ensure you're downloading on a stable network connection (ie. Ethernet)"
            logging.info(f"{msg}")

            self.error_msg = msg
            return False

        self._remove_unused_kdks()
        self.success = True
        logging.info("Kernel Debug Kit checksum verified")
        return True


class KernelDebugKitUtilities:
    """
    Utilities for KDK handling

    """

    def __init__(self) -> None:
        pass


    def install_kdk_pkg(self, kdk_path: Path) -> bool:
        """
        Installs provided KDK packages

        Parameters:
            kdk_path (Path): Path to KDK package

        Returns:
            bool: True if successful, False if not
        """

        logging.info(f"Installing KDK package: {kdk_path.name}")
        logging.info(f"- This may take a while...")

        # TODO: Check whether enough disk space is available

        result = subprocess_wrapper.run_as_root(["/usr/sbin/installer", "-pkg", kdk_path, "-target", "/"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.info("Failed to install KDK:")
            subprocess_wrapper.log(result)
            return False
        return True


    def install_kdk_dmg(self, kdk_path: Path, only_install_backup: bool = False) -> bool:
        """
        Installs provided KDK disk image

        Parameters:
            kdk_path (Path): Path to KDK disk image

        Returns:
            bool: True if successful, False if not
        """

        logging.info(f"Extracting downloaded KDK disk image")
        with tempfile.TemporaryDirectory() as mount_point:
            result = subprocess_wrapper.run_as_root(["/usr/bin/hdiutil", "attach", kdk_path, "-mountpoint", mount_point, "-nobrowse"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info("Failed to mount KDK:")
                subprocess_wrapper.log(result)
                return False

            kdk_pkg_path = Path(f"{mount_point}/KernelDebugKit.pkg")
            if not kdk_pkg_path.exists():
                logging.warning("Failed to find KDK package in DMG, likely corrupted!!!")
                self._unmount_disk_image(mount_point)
                return False


            if only_install_backup is False:
                if self.install_kdk_pkg(kdk_pkg_path) is False:
                    self._unmount_disk_image(mount_point)
                    return False

            self._create_backup(kdk_pkg_path, Path(f"{kdk_path.parent}/{KDK_INFO_PLIST}"))
            self._unmount_disk_image(mount_point)

        logging.info("Successfully installed KDK")
        return True

    def _unmount_disk_image(self, mount_point) -> None:
        """
        Unmounts provided disk image silently

        Parameters:
            mount_point (Path): Path to mount point
        """
        subprocess.run(["/usr/bin/hdiutil", "detach", mount_point], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _create_backup(self, kdk_path: Path, kdk_info_plist: Path) -> None:
        """
        Creates a backup of the KDK

        Parameters:
            kdk_path (Path): Path to KDK
            kdk_info_plist (Path): Path to KDK Info.plist
        """

        if not kdk_path.exists():
            logging.warning("KDK does not exist, cannot create backup")
            return
        if not kdk_info_plist.exists():
            logging.warning("KDK Info.plist does not exist, cannot create backup")
            return

        kdk_info_dict = plistlib.load(kdk_info_plist.open("rb"))

        if 'version' not in kdk_info_dict or 'build' not in kdk_info_dict:
            logging.warning("Malformed KDK Info.plist provided, cannot create backup")
            return

        if not Path(KDK_INSTALL_PATH).exists():
            subprocess_wrapper.run_as_root(["/bin/mkdir", "-p", KDK_INSTALL_PATH], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        kdk_dst_name = f"KDK_{kdk_info_dict['version']}_{kdk_info_dict['build']}.pkg"
        kdk_dst_path = Path(f"{KDK_INSTALL_PATH}/{kdk_dst_name}")

        logging.info(f"Creating backup: {kdk_dst_name}")
        if kdk_dst_path.exists():
            logging.info("Backup already exists, skipping")
            return

        result = subprocess_wrapper.run_as_root(generate_copy_arguments(kdk_path, kdk_dst_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.info("Failed to create KDK backup:")
            subprocess_wrapper.log(result)

#logging_handler.py:
"""
logging_handler.py: Initialize logging framework for program
"""

import os
import sys
import pprint
import logging
import threading
import traceback
import subprocess
import applescript

from pathlib import Path
from datetime import datetime

from .. import constants

from . import (
    analytics_handler,
    global_settings
)


class InitializeLoggingSupport:
    """
    Initialize logging framework for program

    Primary responsibilities:
    - Determine where to store log file
    - Clean log file if it's near the max file size
    - Initialize logging framework configuration
    - Implement custom traceback handler
    - Implement error handling for file write

    Usage:
    >>> from resources.logging_handler import InitializeLoggingSupport
    >>> InitializeLoggingSupport()

    FOR DEVELOPERS:
    - Do not invoke logging until after '_attempt_initialize_logging_configuration()' has been invoked

    """

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants

        log_time = datetime.now().strftime("%Y-%m-%d_%H-%M-%S-%f")

        self.log_filename: str  = f"OpenCore-Patcher_{self.constants.patcher_version}_{log_time}.log"
        self.log_filepath: Path = None

        self.original_excepthook:        sys       = sys.excepthook
        self.original_thread_excepthook: threading = threading.excepthook

        self.max_file_size:     int = 1024 * 1024               # 1 MB
        self.file_size_redline: int = 1024 * 1024 - 1024 * 100  # 900 KB, when to start cleaning log file

        self._initialize_logging_path()
        self._attempt_initialize_logging_configuration()
        self._start_logging()
        self._implement_custom_traceback_handler()
        self._clean_prior_version_logs()


    def _initialize_logging_path(self) -> None:
        """
        Initialize logging framework storage path
        """

        base_path = Path("~/Library/Logs").expanduser()
        if not base_path.exists() or str(base_path).startswith("/var/root/"):
            # Likely in an installer environment, store in /Users/Shared
            base_path = Path("/Users/Shared")
        else:
            # create Dortania folder if it doesn't exist
            base_path = base_path / "Dortania"
            if not base_path.exists():
                try:
                    base_path.mkdir()
                except Exception as e:
                    print(f"Failed to create Dortania folder: {e}")
                    base_path = Path("/Users/Shared")

        self.log_filepath = Path(f"{base_path}/{self.log_filename}").expanduser()
        self.constants.log_filepath = self.log_filepath

    def _clean_prior_version_logs(self) -> None:
        """
        Clean logs from old Patcher versions

        Keep 10 latest logs
        """

        paths = [
            self.log_filepath.parent,        # ~/Library/Logs/Dortania
            self.log_filepath.parent.parent, # ~/Library/Logs (old location)
        ]

        logs = []

        for path in paths:
            for file in path.glob("OpenCore-Patcher*"):
                if not file.is_file():
                    continue

                if not file.name.endswith(".log"):
                    continue

                if file.name == self.log_filename:
                    continue

                logs.append(file)

        logs.sort(key=lambda x: x.stat().st_mtime, reverse=True)

        for log in logs[9:]:
            try:
                log.unlink()
            except Exception as e:
                logging.error(f"Failed to delete log file: {e}")


    def _initialize_logging_configuration(self, log_to_file: bool = True) -> None:
        """
        Initialize logging framework configuration

        StreamHandler's format is used to mimic the default behavior of print()
        While FileHandler's format is for more in-depth logging

        Parameters:
            log_to_file (bool): Whether to log to file or not

        """

        logging.basicConfig(
            level=logging.NOTSET,
            format="[%(asctime)s] [%(filename)-32s] [%(lineno)-4d]: %(message)s",
            handlers=[
                logging.StreamHandler(stream = sys.stdout),
                logging.FileHandler(self.log_filepath) if log_to_file is True else logging.NullHandler()
            ],
        )
        logging.getLogger().setLevel(logging.INFO)
        logging.getLogger().handlers[0].setFormatter(logging.Formatter("%(message)s"))
        logging.getLogger().handlers[1].maxBytes = self.max_file_size


    def _attempt_initialize_logging_configuration(self) -> None:
        """
        Attempt to initialize logging framework configuration

        If we fail to initialize the logging framework, we will disable logging to file
        """

        try:
            self._initialize_logging_configuration()
        except Exception as e:
            print(f"Failed to initialize logging framework: {e}")
            print("Retrying without logging to file...")
            self._initialize_logging_configuration(log_to_file=False)


    def _start_logging(self):
        """
        Start logging, used as easily identifiable start point in logs
        """

        str_msg = f"# OpenCore Legacy Patcher ({self.constants.patcher_version}) #"
        str_len = len(str_msg)

        logging.info('#' * str_len)
        logging.info(str_msg)
        logging.info('#' * str_len)

        logging.info("Log file set:")
        logging.info(f"  {self.log_filepath}")
        # Display relative path to avoid disclosing user's username
        try:
            path = self.log_filepath.relative_to(Path.home())
            logging.info(f"~/{path}")
        except ValueError:
            logging.info(self.log_filepath)


    def _implement_custom_traceback_handler(self) -> None:
        """
        Reroute traceback to logging module
        """

        def custom_excepthook(type, value, tb) -> None:
            """
            Reroute traceback in main thread to logging module
            """
            logging.error("Uncaught exception in main thread", exc_info=(type, value, tb))
            self._display_debug_properties()

            if "wx/" in "".join(traceback.format_exception(type, value, tb)):
                # Likely a GUI error, don't display error dialog
                return

            if self.constants.cli_mode is True:
                return

            error_msg = f"OpenCore Legacy Patcher encountered the following internal error:\n\n"
            error_msg += f"{type.__name__}: {value}"
            if tb:
                error_msg += f"\n\n{traceback.extract_tb(tb)[-1]}"

            error_msg += "\n\nReveal log file?"

            # Ask user if they want to send crash report
            try:
                result = applescript.AppleScript(f'display dialog "{error_msg}" with title "OpenCore Legacy Patcher ({self.constants.patcher_version})" buttons {{"Yes", "No"}} default button "Yes" with icon caution').run()
            except Exception as e:
                logging.error(f"Failed to display crash report dialog: {e}")
                return

            if result[applescript.AEType(b'bhit')] != "Yes":
                return

            subprocess.run(["/usr/bin/open", "--reveal", self.log_filepath])


        def custom_thread_excepthook(args) -> None:
            """
            Reroute traceback in spawned thread to logging module
            """
            logging.error("Uncaught exception in spawned thread", exc_info=(args))

        sys.excepthook = custom_excepthook
        threading.excepthook = custom_thread_excepthook


    def _restore_original_excepthook(self) -> None:
        """
        Restore original traceback handlers
        """

        sys.excepthook = self.original_excepthook
        threading.excepthook = self.original_thread_excepthook


    def _display_debug_properties(self) -> None:
        """
        Display debug properties, primarily after main thread crash
        """
        logging.info("Host Properties:")
        logging.info(f"  XNU Version: {self.constants.detected_os}.{self.constants.detected_os_minor}")
        logging.info(f"  XNU Build: {self.constants.detected_os_build}")
        logging.info(f"  macOS Version: {self.constants.detected_os_version}")
        logging.info("Debug Properties:")
        logging.info(f"  Effective User ID: {os.geteuid()}")
        logging.info(f"  Effective Group ID: {os.getegid()}")
        logging.info(f"  Real User ID: {os.getuid()}")
        logging.info(f"  Real Group ID: {os.getgid()}")
        logging.info("  Arguments passed to Patcher:")
        for arg in sys.argv:
            logging.info(f"    {arg}")

        logging.info(f"Host Properties:\n{pprint.pformat(self.constants.computer.__dict__, indent=4)}")


#macos_installer_handler.py:
"""
macos_installer_handler.py: Handler for local macOS installers
"""

import logging
import plistlib
import tempfile
import subprocess
import re

from pathlib import Path

from ..datasets import os_data

from . import (
    utilities,
    subprocess_wrapper
)

from ..volume import (
    can_copy_on_write,
    generate_copy_arguments
)


APPLICATION_SEARCH_PATH:  str = "/Applications"

tmp_dir = tempfile.TemporaryDirectory()


class InstallerCreation():

    def __init__(self) -> None:
        pass


    def install_macOS_installer(self, download_path: str) -> bool:
        """
        Installs InstallAssistant.pkg

        Parameters:
            download_path (str): Path to InstallAssistant.pkg

        Returns:
            bool: True if successful, False otherwise
        """

        logging.info("Extracting macOS installer from InstallAssistant.pkg")
        result = subprocess_wrapper.run_as_root(["/usr/sbin/installer", "-pkg", f"{Path(download_path)}/InstallAssistant.pkg", "-target", "/"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            logging.info("Failed to install InstallAssistant")
            subprocess_wrapper.log(result)
            return False

        logging.info("InstallAssistant installed")
        return True


    def generate_installer_creation_script(self, tmp_location: str, installer_path: str, disk: str) -> bool:
        """
        Creates installer.sh to be piped to OCLP-Helper and run as admin

        Script includes:
        - Format provided disk as HFS+ GPT
        - Run createinstallmedia on provided disk

        Implementing this into a single installer.sh script allows us to only call
        OCLP-Helper once to avoid nagging the user about permissions

        Parameters:
            tmp_location (str): Path to temporary directory
            installer_path (str): Path to InstallAssistant.pkg
            disk (str): Disk to install to

        Returns:
            bool: True if successful, False otherwise
        """

        additional_args = ""
        script_location = Path(tmp_location) / Path("Installer.sh")

        # Due to a bug in createinstallmedia, running from '/Applications' may sometimes error:
        #   'Failed to extract AssetData/boot/Firmware/Manifests/InstallerBoot/*'
        # This affects native Macs as well even when manually invoking createinstallmedia

        # To resolve, we'll copy into our temp directory and run from there

        # Create a new tmp directory
        # Our current one is a disk image, thus CoW will not work
        global tmp_dir
        ia_tmp = tmp_dir.name

        logging.info(f"Creating temporary directory at {ia_tmp}")
        # Delete all files in tmp_dir
        for file in Path(ia_tmp).glob("*"):
            subprocess.run(["/bin/rm", "-rf", str(file)])

        # Copy installer to tmp
        if can_copy_on_write(installer_path, ia_tmp) is False:
            # Ensure we have enough space for the duplication when CoW is not supported
            space_available = utilities.get_free_space()
            space_needed = Path(ia_tmp).stat().st_size
            if space_available < space_needed:
                logging.info("Not enough free space to create installer.sh")
                logging.info(f"{utilities.human_fmt(space_available)} available, {utilities.human_fmt(space_needed)} required")
                return False

        subprocess.run(generate_copy_arguments(installer_path, ia_tmp))

        # Adjust installer_path to point to the copied installer
        installer_path = Path(ia_tmp) / Path(Path(installer_path).name)
        if not Path(installer_path).exists():
            logging.info(f"Failed to copy installer to {ia_tmp}")
            return False

        # Verify code signature before executing
        createinstallmedia_path = str(Path(installer_path) / Path("Contents/Resources/createinstallmedia"))
        if subprocess.run(["/usr/bin/codesign", "-v", "-R=anchor apple", createinstallmedia_path]).returncode != 0:
            logging.info(f"Installer has broken code signature")
            return False

        plist_path = str(Path(installer_path) / Path("Contents/Info.plist"))
        if Path(plist_path).exists():
            plist = plistlib.load(Path(plist_path).open("rb"))
            if "DTPlatformVersion" in plist:
                platform_version = plist["DTPlatformVersion"]
                platform_version = platform_version.split(".")[0]
                if platform_version[0] == "10":
                    if int(platform_version[1]) < 13:
                        additional_args = f" --applicationpath '{installer_path}'"

        if script_location.exists():
            script_location.unlink()
        script_location.touch()

        with script_location.open("w") as script:
            script.write(f'''#!/bin/bash
erase_disk='/usr/sbin/diskutil eraseDisk HFS+ OCLP-Installer {disk}'
if $erase_disk; then
    "{createinstallmedia_path}" --volume /Volumes/OCLP-Installer --nointeraction{additional_args}
fi
            ''')
        if Path(script_location).exists():
            return True
        return False


    def list_disk_to_format(self) -> dict:
        """
        List applicable disks for macOS installer creation
        Only lists disks that are:
        - 14GB or larger
        - External

        Current limitations:
        - Does not support PCIe based SD cards readers

        Returns:
            dict: Dictionary of disks
        """

        all_disks:  dict = {}
        list_disks: dict = {}

        # TODO: AllDisksAndPartitions is not supported in Snow Leopard and older
        try:
            # High Sierra and newer
            disks = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "list", "-plist", "physical"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
        except ValueError:
            # Sierra and older
            disks = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "list", "-plist"], stdout=subprocess.PIPE).stdout.decode().strip().encode())

        for disk in disks["AllDisksAndPartitions"]:
            try:
                disk_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", disk["DeviceIdentifier"]], stdout=subprocess.PIPE).stdout.decode().strip().encode())
            except:
                # Chinesium USB can have garbage data in MediaName
                diskutil_output = subprocess.run(["/usr/sbin/diskutil", "info", "-plist", disk["DeviceIdentifier"]], stdout=subprocess.PIPE).stdout.decode().strip()
                ungarbafied_output = re.sub(r'(<key>MediaName</key>\s*<string>).*?(</string>)', r'\1\2', diskutil_output).encode()
                disk_info = plistlib.loads(ungarbafied_output)
            try:
                all_disks[disk["DeviceIdentifier"]] = {"identifier": disk_info["DeviceNode"], "name": disk_info.get("MediaName", "Disk"), "size": disk_info["TotalSize"], "removable": disk_info["Internal"], "partitions": {}}
            except KeyError:
                # Avoid crashing with CDs installed
                continue

        for disk in all_disks:
            # Strip disks that are under 14GB (15,032,385,536 bytes)
            # createinstallmedia isn't great at detecting if a disk has enough space
            if not any(all_disks[disk]['size'] > 15032385536 for partition in all_disks[disk]):
                continue
            # Strip internal disks as well (avoid user formatting their SSD/HDD)
            # Ensure user doesn't format their boot drive
            if not any(all_disks[disk]['removable'] is False for partition in all_disks[disk]):
                continue

            list_disks.update({
                disk: {
                    "identifier": all_disks[disk]["identifier"],
                    "name": all_disks[disk]["name"],
                    "size": all_disks[disk]["size"],
                }
            })

        return list_disks


class LocalInstallerCatalog:
    """
    Finds all macOS installers on the local machine.
    """

    def __init__(self) -> None:
        self.available_apps: dict = self._list_local_macOS_installers()


    def _list_local_macOS_installers(self) -> dict:
        """
        Searches for macOS installers in /Applications

        Returns:
            dict: A dictionary of macOS installers found on the local machine.

            Example:
                "Install macOS Big Sur Beta.app": {
                    "Short Name": "Big Sur Beta",
                    "Version": "11.0",
                    "Build": "20A5343i",
                    "Path": "/Applications/Install macOS Big Sur Beta.app",
                },
                etc...
        """

        application_list: dict = {}

        for application in Path(APPLICATION_SEARCH_PATH).iterdir():
            # Certain Microsoft Applications have strange permissions disabling us from reading them
            try:
                if not (Path(APPLICATION_SEARCH_PATH) / Path(application) / Path("Contents/Resources/createinstallmedia")).exists():
                    continue

                if not (Path(APPLICATION_SEARCH_PATH) / Path(application) / Path("Contents/Info.plist")).exists():
                    continue
            except PermissionError:
                continue

            try:
                application_info_plist = plistlib.load((Path(APPLICATION_SEARCH_PATH) / Path(application) / Path("Contents/Info.plist")).open("rb"))
            except (PermissionError, TypeError, plistlib.InvalidFileException):
                continue

            if "DTPlatformVersion" not in application_info_plist:
                continue
            if "CFBundleDisplayName" not in application_info_plist:
                continue

            app_version:  str = application_info_plist["DTPlatformVersion"]
            clean_name:   str = application_info_plist["CFBundleDisplayName"]
            app_sdk:      str = application_info_plist["DTSDKBuild"] if "DTSDKBuild" in application_info_plist else "Unknown"
            min_required: str = application_info_plist["LSMinimumSystemVersion"] if "LSMinimumSystemVersion" in application_info_plist else "Unknown"

            kernel:       int = 0
            try:
                kernel = int(app_sdk[:2])
            except ValueError:
                pass

            min_required = os_data.os_conversion.os_to_kernel(min_required) if min_required != "Unknown" else 0

            if min_required == os_data.os_data.sierra and kernel == os_data.os_data.ventura:
                # Ventura's installer requires El Capitan minimum
                # Ref: https://github.com/dortania/OpenCore-Legacy-Patcher/discussions/1038
                min_required = os_data.os_data.el_capitan

            # app_version can sometimes report GM instead of the actual version
            # This is a workaround to get the actual version
            if app_version.startswith("GM"):
                if kernel == 0:
                    app_version = "Unknown"
                else:
                    app_version = os_data.os_conversion.kernel_to_os(kernel)

            # Check if App Version is High Sierra or newer
            if kernel < os_data.os_data.high_sierra:
                continue

            results = self._parse_sharedsupport_version(Path(APPLICATION_SEARCH_PATH) / Path(application)/ Path("Contents/SharedSupport/SharedSupport.dmg"))
            if results[0] is not None:
                app_sdk = results[0]
            if results[1] is not None:
                app_version = results[1]

            application_list.update({
                application: {
                    "Short Name": clean_name,
                    "Version": app_version,
                    "Build": app_sdk,
                    "Path": application,
                    "Minimum Host OS": min_required,
                    "OS": kernel
                }
            })

        # Sort Applications by version
        application_list = {k: v for k, v in sorted(application_list.items(), key=lambda item: item[1]["Version"])}
        return application_list


    def _parse_sharedsupport_version(self, sharedsupport_path: Path) -> tuple:
        """
        Determine true version of macOS installer by parsing SharedSupport.dmg
        This is required due to Info.plist reporting the application version, not the OS version

        Parameters:
            sharedsupport_path (Path): Path to SharedSupport.dmg

        Returns:
            tuple: Tuple containing the build and OS version
        """

        detected_build: str = None
        detected_os:    str = None

        if not sharedsupport_path.exists():
            return (detected_build, detected_os)

        if not sharedsupport_path.name.endswith(".dmg"):
            return (detected_build, detected_os)


        # Create temporary directory to extract SharedSupport.dmg to
        with tempfile.TemporaryDirectory() as tmpdir:

            output = subprocess.run(
                [
                    "/usr/bin/hdiutil", "attach", "-noverify", sharedsupport_path,
                    "-mountpoint", tmpdir,
                    "-nobrowse",
                ],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT
            )

            if output.returncode != 0:
                return (detected_build, detected_os)


            ss_info_files = [
                Path("SFR/com_apple_MobileAsset_SFRSoftwareUpdate/com_apple_MobileAsset_SFRSoftwareUpdate.xml"),
                Path("com_apple_MobileAsset_MacSoftwareUpdate/com_apple_MobileAsset_MacSoftwareUpdate.xml")
            ]

            for ss_info in ss_info_files:
                if not Path(tmpdir / ss_info).exists():
                    continue
                plist = plistlib.load((tmpdir / ss_info).open("rb"))
                if "Assets" in plist:
                    if "Build" in plist["Assets"][0]:
                        detected_build = plist["Assets"][0]["Build"]
                    if "OSVersion" in plist["Assets"][0]:
                        detected_os = plist["Assets"][0]["OSVersion"]

            # Unmount SharedSupport.dmg
            subprocess.run(["/usr/bin/hdiutil", "detach", tmpdir], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        return (detected_build, detected_os)

#metalib_handler.py:
"""
metallib_handler.py: Library for handling Metal libraries
"""

import logging
import requests
import subprocess
import packaging.version

from typing  import cast
from pathlib import Path

from .  import network_handler, subprocess_wrapper
from .. import constants

from ..datasets import os_data


METALLIB_INSTALL_PATH: str  = "/Library/Application Support/Dortania/MetallibSupportPkg"
METALLIB_API_LINK:     str  = "https://dortania.github.io/MetallibSupportPkg/manifest.json"

METALLIB_ASSET_LIST:   list = None


class MetalLibraryObject:

    def __init__(self, global_constants: constants.Constants,
                 host_build: str, host_version: str,
                 ignore_installed: bool = False, passive: bool = False
        ) -> None:

        self.constants: constants.Constants = global_constants

        self.host_build:   str = host_build    # ex. 20A5384c
        self.host_version: str = host_version  # ex. 11.0.1

        self.passive: bool = passive  # Don't perform actions requiring elevated privileges

        self.ignore_installed:      bool = ignore_installed   # If True, will ignore any installed MetallibSupportPkg PKGs and download the latest
        self.metallib_already_installed: bool = False

        self.metallib_installed_path: str = ""

        self.metallib_url:         str = ""
        self.metallib_url_build:   str = ""
        self.metallib_url_version: str = ""

        self.metallib_url_is_exactly_match: bool = False

        self.metallib_closest_match_url:         str = ""
        self.metallib_closest_match_url_build:   str = ""
        self.metallib_closest_match_url_version: str = ""

        self.success: bool = False

        self.error_msg: str = ""

        self._get_latest_metallib()


    def _get_remote_metallibs(self) -> dict:
        """
        Get the MetallibSupportPkg list from the API
        """

        global METALLIB_ASSET_LIST

        logging.info("Pulling metallib list from MetallibSupportPkg API")
        if METALLIB_ASSET_LIST:
            return METALLIB_ASSET_LIST

        try:
            results = network_handler.NetworkUtilities().get(
                METALLIB_API_LINK,
                headers={
                    "User-Agent": f"OCLP/{self.constants.patcher_version}"
                },
                timeout=5
            )
        except (requests.exceptions.Timeout, requests.exceptions.TooManyRedirects, requests.exceptions.ConnectionError):
            logging.info("Could not contact MetallibSupportPkg API")
            return None

        if results.status_code != 200:
            logging.info("Could not fetch Metallib list")
            return None

        METALLIB_ASSET_LIST = results.json()

        return METALLIB_ASSET_LIST


    def _get_latest_metallib(self) -> None:
        """
        Get the latest MetallibSupportPkg PKG
        """

        parsed_version = cast(packaging.version.Version, packaging.version.parse(self.host_version))

        if os_data.os_conversion.os_to_kernel(str(parsed_version.major)) < os_data.os_data.sequoia:
            self.error_msg = "MetallibSupportPkg is not required for macOS Sonoma or older"
            logging.warning(f"{self.error_msg}")
            return

        self.metallib_installed_path = self._local_metallib_installed()
        if self.metallib_installed_path:
            logging.info(f"metallib already installed ({Path(self.metallib_installed_path).name}), skipping")
            self.metallib_already_installed = True
            self.success = True
            return

        remote_metallib_version = self._get_remote_metallibs()

        if remote_metallib_version is None:
            logging.warning("Failed to fetch metallib list, falling back to local metallib matching")

            # First check if a metallib matching the current macOS version is installed
            # ex. 13.0.1 vs 13.0
            loose_version = f"{parsed_version.major}.{parsed_version.minor}"
            logging.info(f"Checking for metallibs loosely matching {loose_version}")
            self.metallib_installed_path = self._local_metallib_installed(match=loose_version, check_version=True)
            if self.metallib_installed_path:
                logging.info(f"Found matching metallib: {Path(self.metallib_installed_path).name}")
                self.metallib_already_installed = True
                self.success = True
                return

            older_version = f"{parsed_version.major}.{parsed_version.minor - 1 if parsed_version.minor > 0 else 0}"
            logging.info(f"Checking for metallibs matching {older_version}")
            self.metallib_installed_path = self._local_metallib_installed(match=older_version, check_version=True)
            if self.metallib_installed_path:
                logging.info(f"Found matching metallib: {Path(self.metallib_installed_path).name}")
                self.metallib_already_installed = True
                self.success = True
                return

            logging.warning(f"Couldn't find metallib matching {self.host_version} or {older_version}, please install one manually")

            self.error_msg = f"Could not contact MetallibSupportPkg API, and no metallib matching {self.host_version} ({self.host_build}) or {older_version} was installed.\nPlease ensure you have a network connection or manually install a metallib."

            return


        # First check exact match
        for metallib in remote_metallib_version:
            if (metallib["build"] != self.host_build):
                continue
            self.metallib_url = metallib["url"]
            self.metallib_url_build = metallib["build"]
            self.metallib_url_version = metallib["version"]
            self.metallib_url_is_exactly_match = True
            break

        # If no exact match, check for closest match
        if self.metallib_url == "":
            for metallib in remote_metallib_version:
                metallib_version = cast(packaging.version.Version, packaging.version.parse(metallib["version"]))
                if metallib_version > parsed_version:
                    continue
                if metallib_version.major != parsed_version.major:
                    continue
                if metallib_version.minor not in range(parsed_version.minor - 1, parsed_version.minor + 1):
                    continue

                # The metallib list is already sorted by version then date, so the first match is the closest
                self.metallib_closest_match_url = metallib["url"]
                self.metallib_closest_match_url_build = metallib["build"]
                self.metallib_closest_match_url_version = metallib["version"]
                self.metallib_url_is_exactly_match = False
                break

        if self.metallib_url == "":
            if self.metallib_closest_match_url == "":
                logging.warning(f"No metallibs found for {self.host_build} ({self.host_version})")
                self.error_msg = f"No metallibs found for {self.host_build} ({self.host_version})"
                return
            logging.info(f"No direct match found for {self.host_build}, falling back to closest match")
            logging.info(f"Closest Match: {self.metallib_closest_match_url_build} ({self.metallib_closest_match_url_version})")

            self.metallib_url = self.metallib_closest_match_url
            self.metallib_url_build = self.metallib_closest_match_url_build
            self.metallib_url_version = self.metallib_closest_match_url_version
        else:
            logging.info(f"Direct match found for {self.host_build} ({self.host_version})")


        # Check if this metallib is already installed
        self.metallib_installed_path = self._local_metallib_installed(match=self.metallib_url_build)
        if self.metallib_installed_path:
            logging.info(f"metallib already installed ({Path(self.metallib_installed_path).name}), skipping")
            self.metallib_already_installed = True
            self.success = True
            return

        logging.info("Following metallib is recommended:")
        logging.info(f"- metallib Build: {self.metallib_url_build}")
        logging.info(f"- metallib Version: {self.metallib_url_version}")
        logging.info(f"- metallib URL: {self.metallib_url}")

        self.success = True


    def _local_metallib_installed(self, match: str = None, check_version: bool = False) -> str:
        """
        Check if a metallib is already installed
        """

        if self.ignore_installed:
            return None

        if not Path(METALLIB_INSTALL_PATH).exists():
            return None

        for metallib_folder in Path(METALLIB_INSTALL_PATH).iterdir():
            if not metallib_folder.is_dir():
                continue
            if check_version:
                if match not in metallib_folder.name:
                    continue
            else:
                if not metallib_folder.name.endswith(f"-{match}"):
                    continue

            return metallib_folder

        return None


    def retrieve_download(self, override_path: str = "") -> network_handler.DownloadObject:
        """
        Retrieve MetallibSupportPkg PKG download object
        """

        self.success = False
        self.error_msg = ""

        if self.metallib_already_installed:
            logging.info("No download required, metallib already installed")
            self.success = True
            return None

        if self.metallib_url == "":
            self.error_msg = "Could not retrieve metallib catalog, no metallib to download"
            logging.error(self.error_msg)
            return None

        logging.info(f"Returning DownloadObject for metallib: {Path(self.metallib_url).name}")
        self.success = True

        metallib_download_path = self.constants.metallib_download_path if override_path == "" else Path(override_path)
        return network_handler.DownloadObject(self.metallib_url, metallib_download_path)


    def install_metallib(self, metallib: str = None) -> None:
        """
        Install MetallibSupportPkg PKG
        """

        if not self.success:
            logging.error("Cannot install metallib, no metallib was successfully retrieved")
            return False

        if self.metallib_already_installed:
            logging.info("No installation required, metallib already installed")
            return True

        result = subprocess_wrapper.run_as_root([
            "/usr/sbin/installer", "-pkg", metallib if metallib else self.constants.metallib_download_path, "-target", "/"
        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            subprocess_wrapper.log(result)
            return False

        return True

#network_handler.py:
"""
network_handler.py: Library dedicated to Network Handling tasks including downloading files

Primarily based around the DownloadObject class, which provides a simple
object for libraries to query download progress and status
"""

import time
import requests
import threading
import logging
import enum
import hashlib
import atexit

from typing import Union
from pathlib import Path

from . import utilities

SESSION = requests.Session()


class DownloadStatus(enum.Enum):
    """
    Enum for download status
    """

    INACTIVE:    str = "Inactive"
    DOWNLOADING: str = "Downloading"
    ERROR:       str = "Error"
    COMPLETE:    str = "Complete"


class NetworkUtilities:
    """
    Utilities for network related tasks, primarily used for downloading files
    """

    def __init__(self, url: str = None) -> None:
        self.url: str = url

        if self.url is None:
            self.url = "https://github.com"


    def verify_network_connection(self) -> bool:
        """
        Verifies that the network is available

        Returns:
            bool: True if network is available, False otherwise
        """

        try:
            requests.head(self.url, timeout=5, allow_redirects=True)
            return True
        except (
            requests.exceptions.Timeout,
            requests.exceptions.TooManyRedirects,
            requests.exceptions.ConnectionError,
            requests.exceptions.HTTPError
        ):
            return False

    def validate_link(self) -> bool:
        """
        Check for 404 error

        Returns:
            bool: True if link is valid, False otherwise
        """
        try:
            response = SESSION.head(self.url, timeout=5, allow_redirects=True)
            if response.status_code == 404:
                return False
            else:
                return True
        except (
            requests.exceptions.Timeout,
            requests.exceptions.TooManyRedirects,
            requests.exceptions.ConnectionError,
            requests.exceptions.HTTPError
        ):
            return False


    def get(self, url: str, **kwargs) -> requests.Response:
        """
        Wrapper for requests's get method
        Implement additional error handling

        Parameters:
            url (str): URL to get
            **kwargs: Additional parameters for requests.get

        Returns:
            requests.Response: Response object from requests.get
        """

        result: requests.Response = None

        try:
            result = SESSION.get(url, **kwargs)
        except (
            requests.exceptions.Timeout,
            requests.exceptions.TooManyRedirects,
            requests.exceptions.ConnectionError,
            requests.exceptions.HTTPError
        ) as error:
            logging.warn(f"Error calling requests.get: {error}")
            # Return empty response object
            return requests.Response()

        return result

    def post(self, url: str, **kwargs) -> requests.Response:
        """
        Wrapper for requests's post method
        Implement additional error handling

        Parameters:
            url (str): URL to post
            **kwargs: Additional parameters for requests.post

        Returns:
            requests.Response: Response object from requests.post
        """

        result: requests.Response = None

        try:
            result = SESSION.post(url, **kwargs)
        except (
            requests.exceptions.Timeout,
            requests.exceptions.TooManyRedirects,
            requests.exceptions.ConnectionError,
            requests.exceptions.HTTPError
        ) as error:
            logging.warn(f"Error calling requests.post: {error}")
            # Return empty response object
            return requests.Response()

        return result


class DownloadObject:
    """
    Object for downloading files from the network

    Usage:
        >>> download_object = DownloadObject(url, path)
        >>> download_object.download(display_progress=True)

        >>> if download_object.is_active():
        >>>     print(download_object.get_percent())

        >>> if not download_object.download_complete:
        >>>     print("Download failed")

        >>> print("Download complete"")

    """

    def __init__(self, url: str, path: str) -> None:
        self.url:       str = url
        self.status:    str = DownloadStatus.INACTIVE
        self.error_msg: str = ""
        self.filename:  str = self._get_filename()

        self.filepath:  Path = Path(path)

        self.total_file_size:      float = 0.0
        self.downloaded_file_size: float = 0.0
        self.start_time:           float = time.time()

        self.error:             bool = False
        self.should_stop:       bool = False
        self.download_complete: bool = False
        self.has_network:       bool = NetworkUtilities(self.url).verify_network_connection()

        self.active_thread: threading.Thread = None

        self.should_checksum: bool = False

        self.checksum = None
        self._checksum_storage: hash = None

        if self.has_network:
            self._populate_file_size()


    def __del__(self) -> None:
        self.stop()


    def download(self, display_progress: bool = False, spawn_thread: bool = True, verify_checksum: bool = False) -> None:
        """
        Download the file

        Spawns a thread to download the file, so that the main thread can continue
        Note sleep is disabled while the download is active

        Parameters:
            display_progress (bool): Display progress in console
            spawn_thread (bool): Spawn a thread to download the file, otherwise download in the current thread
            verify_checksum (bool): Calculate checksum of downloaded file if True

        """
        self.status = DownloadStatus.DOWNLOADING
        logging.info(f"Starting download: {self.filename}")
        if spawn_thread:
            if self.active_thread:
                logging.error("Download already in progress")
                return
            self.should_checksum = verify_checksum
            self.active_thread = threading.Thread(target=self._download, args=(display_progress,))
            self.active_thread.start()
            return

        self.should_checksum = verify_checksum
        self._download(display_progress)


    def download_simple(self, verify_checksum: bool = False) -> Union[str, bool]:
        """
        Alternative to download(), mimics  utilities.py's old download_file() function

        Parameters:
            verify_checksum (bool): Return checksum of downloaded file if True

        Returns:
            If verify_checksum is True, returns the checksum of the downloaded file
            Otherwise, returns True if download was successful, False otherwise
        """

        if verify_checksum:
            self.should_checksum = True
            self.checksum = hashlib.sha256()

        self.download(spawn_thread=False)

        if not self.download_complete:
            return False

        return self.checksum.hexdigest() if self.checksum else True


    def _get_filename(self) -> str:
        """
        Get the filename from the URL

        Returns:
            str: Filename
        """

        return Path(self.url).name


    def _populate_file_size(self) -> None:
        """
        Get the file size of the file to be downloaded

        If unable to get file size, set to zero
        """

        try:
            result = SESSION.head(self.url, allow_redirects=True, timeout=5)
            if 'Content-Length' in result.headers:
                self.total_file_size = float(result.headers['Content-Length'])
            else:
                raise Exception("Content-Length missing from headers")
        except Exception as e:
            logging.error(f"Error determining file size {self.url}: {str(e)}")
            logging.error("Assuming file size is 0")
            self.total_file_size = 0.0


    def _update_checksum(self, chunk: bytes) -> None:
        """
        Update checksum with new chunk

        Parameters:
            chunk (bytes): Chunk to update checksum with
        """
        self._checksum_storage.update(chunk)


    def _prepare_working_directory(self, path: Path) -> bool:
        """
        Validates working enviroment, including free space and removing existing files

        Parameters:
            path (str): Path to the file

        Returns:
            bool: True if successful, False if not
        """

        try:
            if Path(path).exists():
                logging.info(f"Deleting existing file: {path}")
                Path(path).unlink()
                return True

            if not Path(path).parent.exists():
                logging.info(f"Creating directory: {Path(path).parent}")
                Path(path).parent.mkdir(parents=True, exist_ok=True)

            available_space = utilities.get_free_space(Path(path).parent)
            if self.total_file_size > available_space:
                msg = f"Not enough free space to download {self.filename}, need {utilities.human_fmt(self.total_file_size)}, have {utilities.human_fmt(available_space)}"
                logging.error(msg)
                raise Exception(msg)

        except Exception as e:
            self.error = True
            self.error_msg = str(e)
            self.status = DownloadStatus.ERROR
            logging.error(f"Error preparing working directory {path}: {self.error_msg}")
            return False

        logging.info(f"- Directory ready: {path}")
        return True


    def _download(self, display_progress: bool = False) -> None:
        """
        Download the file

        Libraries should invoke download() instead of this method

        Parameters:
            display_progress (bool): Display progress in console
        """

        utilities.disable_sleep_while_running()

        try:
            if not self.has_network:
                raise Exception("No network connection")

            if self._prepare_working_directory(self.filepath) is False:
                raise Exception(self.error_msg)

            response = NetworkUtilities().get(self.url, stream=True, timeout=10)

            with open(self.filepath, 'wb') as file:
                atexit.register(self.stop)
                for i, chunk in enumerate(response.iter_content(1024 * 1024 * 4)):
                    if self.should_stop:
                        raise Exception("Download stopped")
                    if chunk:
                        file.write(chunk)
                        self.downloaded_file_size += len(chunk)
                        if self.should_checksum:
                            self._update_checksum(chunk)
                        if display_progress and i % 100:
                            # Don't use logging here, as we'll be spamming the log file
                            if self.total_file_size == 0.0:
                                print(f"Downloaded {utilities.human_fmt(self.downloaded_file_size)} of {self.filename}")
                            else:
                                print(f"Downloaded {self.get_percent():.2f}% of {self.filename} ({utilities.human_fmt(self.get_speed())}/s) ({self.get_time_remaining():.2f} seconds remaining)")
                self.download_complete = True
                logging.info(f"Download complete: {self.filename}")
                logging.info("Stats:")
                logging.info(f"- Downloaded size: {utilities.human_fmt(self.downloaded_file_size)}")
                logging.info(f"- Time elapsed: {(time.time() - self.start_time):.2f} seconds")
                logging.info(f"- Speed: {utilities.human_fmt(self.downloaded_file_size / (time.time() - self.start_time))}/s")
                logging.info(f"- Location: {self.filepath}")
        except Exception as e:
            self.error = True
            self.error_msg = str(e)
            self.status = DownloadStatus.ERROR
            logging.error(f"Error downloading {self.url}: {self.error_msg}")

        self.status = DownloadStatus.COMPLETE
        utilities.enable_sleep_after_running()


    def get_percent(self) -> float:
        """
        Query the download percent

        Returns:
            float: The download percent, or -1 if unknown
        """

        if self.total_file_size == 0.0:
            return -1
        return self.downloaded_file_size / self.total_file_size * 100


    def get_speed(self) -> float:
        """
        Query the download speed

        Returns:
            float: The download speed in bytes per second
        """

        return self.downloaded_file_size / (time.time() - self.start_time)


    def get_time_remaining(self) -> float:
        """
        Query the time remaining for the download

        Returns:
            float: The time remaining in seconds, or -1 if unknown
        """

        if self.total_file_size == 0.0:
            return -1
        speed = self.get_speed()
        if speed <= 0:
            return -1
        return (self.total_file_size - self.downloaded_file_size) / speed


    def get_file_size(self) -> float:
        """
        Query the file size of the file to be downloaded

        Returns:
            float: The file size in bytes, or 0.0 if unknown
        """

        return self.total_file_size


    def is_active(self) -> bool:
        """
        Query if the download is active

        Returns:
            boolean: True if active, False if completed, failed, stopped, or inactive
        """

        if self.status == DownloadStatus.DOWNLOADING:
            return True
        return False


    def stop(self) -> None:
        """
        Stop the download

        If the download is active, this function will hold the thread until stopped
        """

        self.should_stop = True
        if self.active_thread:
            while self.active_thread.is_alive():
                time.sleep(1)

#reroute_payloads.py:
"""
reroute_payloads.py: Reroute binaries to tmp directory, and mount a disk image of the payloads
Implements a shadowfile to avoid direct writes to the dmg
"""

import atexit
import plistlib
import tempfile
import subprocess

import logging

from pathlib import Path

from . import subprocess_wrapper

from .. import constants


class RoutePayloadDiskImage:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants

        self._setup_tmp_disk_image()


    def _setup_tmp_disk_image(self) -> None:
        """
        Initialize temp directory and mount payloads.dmg
        Create overlay for patcher to write to

        Currently only applicable for GUI variant and not running from source
        """

        if self.constants.wxpython_variant is True and not self.constants.launcher_script:
            logging.info("Running in compiled binary, switching to tmp directory")
            self.temp_dir = tempfile.TemporaryDirectory()
            logging.info(f"New payloads location: {self.temp_dir.name}")
            logging.info("Creating payloads directory")
            Path(self.temp_dir.name / Path("payloads")).mkdir(parents=True, exist_ok=True)
            self._unmount_active_dmgs(unmount_all_active=False)
            output = subprocess.run(
                [
                    "/usr/bin/hdiutil", "attach", "-noverify", f"{self.constants.payload_path_dmg}",
                    "-mountpoint", Path(self.temp_dir.name / Path("payloads")),
                    "-nobrowse",
                    "-shadow", Path(self.temp_dir.name / Path("payloads_overlay")),
                    "-passphrase", "password"
                ],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT
            )
            if output.returncode == 0:
                logging.info("Mounted payloads.dmg")
                self.constants.current_path = Path(self.temp_dir.name)
                self.constants.payload_path = Path(self.temp_dir.name) / Path("payloads")
                atexit.register(self._unmount_active_dmgs, unmount_all_active=False)
            else:
                logging.info("Failed to mount payloads.dmg")
                subprocess_wrapper.log(output)


    def _unmount_active_dmgs(self, unmount_all_active: bool = True) -> None:
        """
        Unmounts disk images associated with OCLP

        Finds all DMGs that are mounted, and forcefully unmount them
        If our disk image was previously mounted, we need to unmount it to use again
        This can happen if we crash during a previous secession, however 'atexit' class should hopefully avoid this

        Parameters:
            unmount_all_active (bool): If True, unmount all active DMGs, otherwise only unmount our own DMG
        """

        dmg_info = subprocess.run(["/usr/bin/hdiutil", "info", "-plist"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        dmg_info = plistlib.loads(dmg_info.stdout)


        for variant in ["DortaniaInternalResources.dmg", "Universal-Binaries.dmg", "payloads.dmg"]:
            for image in dmg_info["images"]:
                if image["image-path"].endswith(variant):
                    if unmount_all_active is False:
                        # Check that only our personal payloads.dmg is unmounted
                        if "shadow-path" in image:
                            if self.temp_dir.name in image["shadow-path"]:
                                logging.info(f"Unmounting personal {variant}")
                                subprocess.run(
                                    ["/usr/bin/hdiutil", "detach", image["system-entities"][0]["dev-entry"], "-force"],
                                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT
                                )
                    else:
                        logging.info(f"Unmounting {variant} at: {image['system-entities'][0]['dev-entry']}")
                        subprocess.run(
                            ["/usr/bin/hdiutil", "detach", image["system-entities"][0]["dev-entry"], "-force"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
                        )

#subprocess_wrapper.py:
"""
subprocess_wrapper.py: Wrapper for subprocess module to better handle errors and output
                       Additionally handles our Privileged Helper Tool
"""

import enum
import logging
import subprocess

from pathlib import Path


OCLP_PRIVILEGED_HELPER = "/Library/PrivilegedHelperTools/com.dortania.opencore-legacy-patcher.privileged-helper"


class PrivilegedHelperErrorCodes(enum.IntEnum):
    """
    Error codes for Privileged Helper Tool.

    Reference:
        payloads/Tools/PrivilegedHelperTool/main.m
    """
    OCLP_PHT_ERROR_MISSING_ARGUMENTS           = 160
    OCLP_PHT_ERROR_SET_UID_MISSING             = 161
    OCLP_PHT_ERROR_SET_UID_FAILED              = 162
    OCLP_PHT_ERROR_SELF_PATH_MISSING           = 163
    OCLP_PHT_ERROR_PARENT_PATH_MISSING         = 164
    OCLP_PHT_ERROR_SIGNING_INFORMATION_MISSING = 165
    OCLP_PHT_ERROR_INVALID_TEAM_ID             = 166
    OCLP_PHT_ERROR_INVALID_CERTIFICATES        = 167
    OCLP_PHT_ERROR_COMMAND_MISSING             = 168
    OCLP_PHT_ERROR_COMMAND_FAILED              = 169
    OCLP_PHT_ERROR_CATCH_ALL                   = 170


def run(*args, **kwargs) -> subprocess.CompletedProcess:
    """
    Basic subprocess.run wrapper.
    """
    return subprocess.run(*args, **kwargs)


def run_as_root(*args, **kwargs) -> subprocess.CompletedProcess:
    """
    Run subprocess as root.

    Note: Full path to first argument is required.
    Helper tool does not resolve PATH.
    """
    # Check if first argument exists
    if not Path(args[0][0]).exists():
        raise FileNotFoundError(f"File not found: {args[0][0]}")

    return subprocess.run([OCLP_PRIVILEGED_HELPER] + [args[0][0]] + args[0][1:], **kwargs)


def verify(process_result: subprocess.CompletedProcess) -> None:
    """
    Verify process result and raise exception if failed.
    """
    if process_result.returncode == 0:
        return

    log(process_result)

    raise Exception(f"Process failed with exit code {process_result.returncode}")


def run_and_verify(*args, **kwargs) -> None:
    """
    Run subprocess and verify result.

    Asserts on failure.
    """
    verify(run(*args, **kwargs))


def run_as_root_and_verify(*args, **kwargs) -> None:
    """
    Run subprocess as root and verify result.

    Asserts on failure.
    """
    verify(run_as_root(*args, **kwargs))


def log(process: subprocess.CompletedProcess) -> None:
    """
    Display subprocess error output in formatted string.
    """
    for line in generate_log(process).split("\n"):
        logging.error(line)


def generate_log(process: subprocess.CompletedProcess) -> str:
    """
    Display subprocess error output in formatted string.
    Note this function is still used for zero return code errors, since
    some software don't ever return non-zero regardless of success.

    Format:

        Command: <command>
        Return Code: <return code>
        Standard Output:
            <standard output line 1>
            <standard output line 2>
            ...
        Standard Error:
            <standard error line 1>
            <standard error line 2>
            ...
    """
    output = "Subprocess failed.\n"
    output += f"    Command: {process.args}\n"
    output += f"    Return Code: {process.returncode}\n"
    _returned_error = __resolve_privileged_helper_errors(process.returncode)
    if _returned_error:
        output += f"        Likely Enum: {_returned_error}\n"
    output += f"    Standard Output:\n"
    if process.stdout:
        output += __format_output(process.stdout.decode("utf-8"))
    else:
        output += "        None\n"
    output += f"    Standard Error:\n"
    if process.stderr:
        output += __format_output(process.stderr.decode("utf-8"))
    else:
        output += "        None\n"

    return output


def __resolve_privileged_helper_errors(return_code: int) -> str:
    """
    Attempt to resolve Privileged Helper Tool error codes.
    """
    if return_code not in [error_code.value for error_code in PrivilegedHelperErrorCodes]:
        return None

    return PrivilegedHelperErrorCodes(return_code).name


def __format_output(output: str) -> str:
    """
    Format output.
    """
    if not output:
        # Shouldn't happen, but just in case
        return "        None\n"

    _result = "\n".join([f"        {line}" for line in output.split("\n") if line not in ["", "\n"]])
    if not _result.endswith("\n"):
        _result += "\n"

    return _result

#updates.py:
"""
updates.py: Check for OpenCore Legacy Patcher binary updates

Call check_binary_updates() to determine if any updates are available
Returns dict with Link and Version of the latest binary update if available
"""

import logging

from typing import Optional, Union
from packaging import version

from . import network_handler

from .. import constants


REPO_LATEST_RELEASE_URL: str = "https://api.github.com/repos/dortania/OpenCore-Legacy-Patcher/releases/latest"


class CheckBinaryUpdates:
    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants
        try:
            self.binary_version = version.parse(self.constants.patcher_version)
        except version.InvalidVersion:
            assert self.constants.special_build is True, "Invalid version number for binary"
            # Special builds will not have a proper version number
            self.binary_version = version.parse("0.0.0")

        self.latest_details = None

    def check_if_newer(self, version: Union[str, version.Version]) -> bool:
        """
        Check if the provided version is newer than the local version

        Parameters:
            version (str): Version to compare against

        Returns:
            bool: True if the provided version is newer, False if not
        """
        if self.constants.special_build is True:
            return False

        return self._check_if_build_newer(version, self.binary_version)

    def _check_if_build_newer(self, first_version: Union[str, version.Version], second_version: Union[str, version.Version]) -> bool:
        """
        Check if the first version is newer than the second version

        Parameters:
            first_version_str (str): First version to compare against (generally local)
            second_version_str (str): Second version to compare against (generally remote)

        Returns:
            bool: True if first version is newer, False if not
        """

        if not isinstance(first_version, version.Version):
            try:
                first_version = version.parse(first_version)
            except version.InvalidVersion:
                # Special build > release build: assume special build is newer
                return True

        if not isinstance(second_version, version.Version):
            try:
                second_version = version.parse(second_version)
            except version.InvalidVersion:
                # Release build > special build: assume special build is newer
                return False

        if first_version == second_version:
            if not self.constants.commit_info[0].startswith("refs/tags"):
                # Check for nightly builds
                return True

        return first_version > second_version


    def check_binary_updates(self) -> Optional[dict]:
        """
        Check if any updates are available for the OpenCore Legacy Patcher binary

        Returns:
            dict: Dictionary with Link and Version of the latest binary update if available
        """

        if self.constants.special_build is True:
            # Special builds do not get updates through the updater
            return None

        if self.latest_details:
            # We already checked
            return self.latest_details

        if not network_handler.NetworkUtilities(REPO_LATEST_RELEASE_URL).verify_network_connection():
            return None

        response = network_handler.NetworkUtilities().get(REPO_LATEST_RELEASE_URL)
        data_set = response.json()

        if "tag_name" not in data_set:
            return None

        # The release marked as latest will always be stable, and thus, have a proper version number
        # But if not, let's not crash the program
        try:
            latest_remote_version = version.parse(data_set["tag_name"])
        except version.InvalidVersion:
            return None

        if not self._check_if_build_newer(latest_remote_version, self.binary_version):
            return None

        for asset in data_set["assets"]:
            logging.info(f"Found asset: {asset['name']}")
            if asset["name"] == "OpenCore-Patcher.pkg":
                self.latest_details = {
                    "Name": asset["name"],
                    "Version": latest_remote_version,
                    "Link": asset["browser_download_url"],
                    "Github Link": f"https://github.com/dortania/OpenCore-Legacy-Patcher/releases/{latest_remote_version}",
                }
                return self.latest_details

        return None


#utilities.py:
"""
utilities.py: Utility functions for OpenCore Legacy Patcher
"""

import os
import re
import math
import atexit
import shutil
import logging
import argparse
import binascii
import plistlib
import subprocess
import py_sip_xnu

from pathlib import Path

from .. import constants

from ..detections import ioreg

from ..datasets import (
    os_data,
    sip_data
)


def hexswap(input_hex: str):
    hex_pairs = [input_hex[i : i + 2] for i in range(0, len(input_hex), 2)]
    hex_rev = hex_pairs[::-1]
    hex_str = "".join(["".join(x) for x in hex_rev])
    return hex_str.upper()


def string_to_hex(input_string):
    if not (len(input_string) % 2) == 0:
        input_string = "0" + input_string
    input_string = hexswap(input_string)
    input_string = binascii.unhexlify(input_string)
    return input_string


def human_fmt(num):
    for unit in ["B", "KB", "MB", "GB", "TB", "PB"]:
        if abs(num) < 1000.0:
            return "%3.1f %s" % (num, unit)
        num /= 1000.0
    return "%.1f %s" % (num, "EB")


def seconds_to_readable_time(seconds) -> str:
    """
    Convert seconds to a readable time format

    Parameters:
        seconds (int | float | str): Seconds to convert

    Returns:
        str: Readable time format
    """
    seconds = int(seconds)
    time = ""

    if 0 <= seconds < 60:
        return "Less than a minute "
    if seconds < 0:
        return "Indeterminate time "

    years, seconds = divmod(seconds, 31536000)
    days, seconds = divmod(seconds, 86400)
    hours, seconds = divmod(seconds, 3600)
    minutes, seconds = divmod(seconds, 60)

    if years > 0:
        return "Over a year"
    if days > 0:
        if days > 31:
            return "Over a month"
        time += f"{days}d "
    if hours > 0:
        time += f"{hours}h "
    if minutes > 0:
        time += f"{minutes}m "
    #if seconds > 0:
    #    time += f"{seconds}s"
    return time


def header(lines):
    lines = [i for i in lines if i is not None]
    total_length = len(max(lines, key=len)) + 4
    logging.info("#" * (total_length))
    for line in lines:
        left_side = math.floor(((total_length - 2 - len(line.strip())) / 2))
        logging.info("#" + " " * left_side + line.strip() + " " * (total_length - len("#" + " " * left_side + line.strip()) - 1) + "#")
    logging.info("#" * total_length)


RECOVERY_STATUS = None


def check_recovery():
    global RECOVERY_STATUS  # pylint: disable=global-statement # We need to cache the result

    if RECOVERY_STATUS is None:
        RECOVERY_STATUS = Path("/System/Library/BaseSystem").exists()

    return RECOVERY_STATUS


def get_disk_path():
    root_partition_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", "/"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
    root_mount_path = root_partition_info["DeviceIdentifier"]
    root_mount_path = root_mount_path[:-2] if root_mount_path.count("s") > 1 else root_mount_path
    return root_mount_path


def check_if_root_is_apfs_snapshot():
    root_partition_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", "/"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
    try:
        is_snapshotted = root_partition_info["APFSSnapshot"]
    except KeyError:
        is_snapshotted = False
    return is_snapshotted


def check_seal():
    # 'Snapshot Sealed' property is only listed on booted snapshots
    sealed = subprocess.run(["/usr/sbin/diskutil", "apfs", "list"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if "Snapshot Sealed:           Yes" in sealed.stdout.decode():
        return True
    else:
        return False

def check_filesystem_type():
    # Expected to return 'apfs' or 'hfs'
    filesystem_type = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", "/"], stdout=subprocess.PIPE).stdout.decode().strip().encode())
    return filesystem_type["FilesystemType"]


def csr_decode(os_sip):
    sip_int = py_sip_xnu.SipXnu().get_sip_status().value
    for i,  current_sip_bit in enumerate(sip_data.system_integrity_protection.csr_values):
        if sip_int & (1 << i):
            sip_data.system_integrity_protection.csr_values[current_sip_bit] = True

    # Can be adjusted to whatever OS needs patching
    sip_needs_change = all(sip_data.system_integrity_protection.csr_values[i] for i in os_sip)
    if sip_needs_change is True:
        return False
    else:
        return True


def friendly_hex(integer: int):
    return "{:02X}".format(integer)

sleep_process = None

def disable_sleep_while_running():
    global sleep_process
    logging.info("Disabling Idle Sleep")
    if sleep_process is None:
        # If sleep_process is active, we'll just keep it running
        sleep_process = subprocess.Popen(["/usr/bin/caffeinate", "-d", "-i", "-s"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # Ensures that if we don't properly close the process, 'atexit' will for us
    atexit.register(enable_sleep_after_running)

def enable_sleep_after_running():
    global sleep_process
    if sleep_process:
        logging.info("Re-enabling Idle Sleep")
        sleep_process.kill()
        sleep_process = None


def check_kext_loaded(bundle_id: str) -> str:
    """
    Checks if a kext is loaded

    Parameters:
        bundle_id (str): The bundle ID of the kext to check

    Returns:
        str: The version of the kext if it is loaded, or "" if it is not loaded
    """
    # Name (Version) UUID <Linked Against>
    # no UUID for kextstat
    pattern = re.compile(re.escape(bundle_id) + r"\s+\((?P<version>.+)\)")

    args = ["/usr/sbin/kextstat", "-list-only", "-bundle-id", bundle_id]

    if Path("/usr/bin/kmutil").exists():
        args = ["/usr/bin/kmutil", "showloaded", "--list-only", "--variant-suffix", "release", "--optional-identifier", bundle_id]

    kext_loaded = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if kext_loaded.returncode != 0:
        return ""
    output = kext_loaded.stdout.decode()
    if not output.strip():
        return ""
    match = pattern.search(output)
    if match:
        return match.group("version")
    return ""


def check_oclp_boot():
    if get_nvram("OCLP-Version", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True):
        return True
    else:
        return False


def check_monterey_wifi():
    IO80211ElCap = "com.apple.iokit.IO80211ElCap"
    CoreCaptureElCap = "com.apple.driver.corecaptureElCap"
    loaded_kexts: str = subprocess.run(["/usr/sbin/kextcache"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode()
    if IO80211ElCap in loaded_kexts and CoreCaptureElCap in loaded_kexts:
        return True
    else:
        return False


def check_metal_support(device_probe, computer):
    if computer.gpus:
        for gpu in computer.gpus:
            if (
                (gpu.arch in [
                    device_probe.NVIDIA.Archs.Tesla,
                    device_probe.NVIDIA.Archs.Fermi,
                    device_probe.NVIDIA.Archs.Maxwell,
                    device_probe.NVIDIA.Archs.Pascal,
                    device_probe.AMD.Archs.TeraScale_1,
                    device_probe.AMD.Archs.TeraScale_2,
                    device_probe.Intel.Archs.Iron_Lake,
                    device_probe.Intel.Archs.Sandy_Bridge
                    ]
                )
            ):
                return False
    return True


def check_filevault_skip():
    # Check whether we can skip FileVault check with Root Patching
    nvram = get_nvram("OCLP-Settings", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
    if nvram:
        if "-allow_fv" in nvram:
            return True
    return False


def check_secure_boot_model():
    sbm_byte = get_nvram("HardwareModel", "94B73556-2197-4702-82A8-3E1337DAFBFB", decode=False)
    if sbm_byte:
        sbm_byte = sbm_byte.replace(b"\x00", b"")
        sbm_string = sbm_byte.decode("utf-8")
        return sbm_string
    return None

def check_ap_security_policy():
    ap_security_policy_byte = get_nvram("AppleSecureBootPolicy", "94B73556-2197-4702-82A8-3E1337DAFBFB", decode=False)
    if ap_security_policy_byte:
        # Supported Apple Secure Boot Policy values:
        #     AppleImg4SbModeDisabled = 0,
        #     AppleImg4SbModeMedium   = 1,
        #     AppleImg4SbModeFull     = 2
        # Ref: https://github.com/acidanthera/OpenCorePkg/blob/f7c1a3d483fa2535b6a62c25a4f04017bfeee09a/Include/Apple/Protocol/AppleImg4Verification.h#L27-L31
        return int.from_bytes(ap_security_policy_byte, byteorder="little")
    return 0

def check_secure_boot_level():
    if check_secure_boot_model() in constants.Constants().sbm_values:
        # OpenCorePkg logic:
        #   - If a T2 Unit is used with ApECID, will return 2
        #   - Either x86legacy or T2 without ApECID, returns 1
        #   - Disabled, returns 0
        # Ref: https://github.com/acidanthera/OpenCorePkg/blob/f7c1a3d483fa2535b6a62c25a4f04017bfeee09a/Library/OcMainLib/OpenCoreUefi.c#L490-L502
        #
        # Genuine Mac logic:
        #   - On genuine non-T2 Macs, they always return 0
        #   - T2 Macs will return based on their Startup Policy (Full(2), Medium(1), Disabled(0))
        # Ref: https://support.apple.com/en-us/HT208198
        if check_ap_security_policy() != 0:
            return True
        else:
            return False
    return False


def patching_status(os_sip, os):
    # Detection for Root Patching
    sip_enabled = True  #  System Integrity Protection
    sbm_enabled = True  #  Secure Boot Status (SecureBootModel)
    fv_enabled = True  #   FileVault
    dosdude_patched = True

    gen6_kext = "/System/Library/Extension/AppleIntelHDGraphics.kext"
    gen7_kext = "/System/Library/Extension/AppleIntelHD3000Graphics.kext"


    sbm_enabled = check_secure_boot_level()

    if os > os_data.os_data.yosemite:
        sip_enabled = csr_decode(os_sip)
    else:
        sip_enabled = False

    if os > os_data.os_data.catalina and not check_filevault_skip():
        # Assume non-OCLP Macs do not have our APFS seal patch
        fv_status: str = subprocess.run(["/usr/bin/fdesetup", "status"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode()
        if "FileVault is Off" in fv_status:
            fv_enabled = False
    else:
        fv_enabled = False

    if not (Path(gen6_kext).exists() and Path(gen7_kext).exists()):
        dosdude_patched = False

    return sip_enabled, sbm_enabled, fv_enabled, dosdude_patched


clear = True


def disable_cls():
    global clear
    clear = False


def cls():
    global clear
    if not clear:
        return
    if check_cli_args() is None:
        # Our GUI does not support clear screen
        if not check_recovery():
            os.system("cls" if os.name == "nt" else "clear")
        else:
            logging.info("\u001Bc")

def check_command_line_tools():
    # Determine whether Command Line Tools exist
    xcode_select = subprocess.run(["/usr/bin/xcode-select", "--print-path"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if xcode_select.returncode == 0:
        return True
    else:
        return False

def get_nvram(variable: str, uuid: str = None, *, decode: bool = False):
    # TODO: Properly fix for El Capitan, which does not print the XML representation even though we say to

    if uuid is not None:
        uuid += ":"
    else:
        uuid = ""

    nvram = ioreg.IORegistryEntryFromPath(ioreg.kIOMasterPortDefault, "IODeviceTree:/options".encode())

    value = ioreg.IORegistryEntryCreateCFProperty(nvram, f"{uuid}{variable}", ioreg.kCFAllocatorDefault, ioreg.kNilOptions)

    ioreg.IOObjectRelease(nvram)

    if not value:
        return None

    value = ioreg.corefoundation_to_native(value)

    if decode:
        if isinstance(value, bytes):
            try:
                value = value.strip(b"\0").decode()
            except UnicodeDecodeError:
                # Some sceanrios the firmware will throw garbage in
                # ie. iMac12,2 with FireWire boot-path
                value = None
        elif isinstance(value, str):
            value = value.strip("\0")
    return value


def get_rom(variable: str, *, decode: bool = False):
    # TODO: Properly fix for El Capitan, which does not print the XML representation even though we say to

    rom = ioreg.IORegistryEntryFromPath(ioreg.kIOMasterPortDefault, "IODeviceTree:/rom".encode())

    value = ioreg.IORegistryEntryCreateCFProperty(rom, variable, ioreg.kCFAllocatorDefault, ioreg.kNilOptions)

    ioreg.IOObjectRelease(rom)

    if not value:
        return None

    value = ioreg.corefoundation_to_native(value)

    if decode and isinstance(value, bytes):
        value = value.strip(b"\0").decode()
    return value

def get_firmware_vendor(*, decode: bool = False):
    efi = ioreg.IORegistryEntryFromPath(ioreg.kIOMasterPortDefault, "IODeviceTree:/efi".encode())
    value = ioreg.IORegistryEntryCreateCFProperty(efi, "firmware-vendor", ioreg.kCFAllocatorDefault, ioreg.kNilOptions)
    ioreg.IOObjectRelease(efi)

    if not value:
        return None

    value = ioreg.corefoundation_to_native(value)
    if decode:
        if isinstance(value, bytes):
            value = value.strip(b"\0").decode()
        elif isinstance(value, str):
            value = value.strip("\0")
    return value


def find_apfs_physical_volume(device):
    # ex: disk3s1s1
    # return: [disk0s2]
    disk_list = None
    physical_disks = []
    try:
        disk_list = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", device], stdout=subprocess.PIPE).stdout)
    except TypeError:
        pass

    if disk_list:
        try:
            # Note: Fusion Drive Macs return multiple APFSPhysicalStores:
            # APFSPhysicalStores:
            #  - 0:
            #      APFSPhysicalStore: disk0s2
            #  - 1:
            #      APFSPhysicalStore: disk3s2
            for disk in disk_list["APFSPhysicalStores"]:
                physical_disks.append(disk["APFSPhysicalStore"])
        except KeyError:
            pass
    return physical_disks

def clean_device_path(device_path: str):
    # ex:
    #   'PciRoot(0x0)/Pci(0xA,0x0)/Sata(0x0,0x0,0x0)/HD(1,GPT,C0778F23-3765-4C8E-9BFA-D60C839E7D2D,0x28,0x64000)/EFI\OC\OpenCore.efi'
    #   'PciRoot(0x0)/Pci(0x1A,0x7)/USB(0x0,0x0)/USB(0x2,0x0)/HD(2,GPT,4E929909-2074-43BA-9773-61EBC110A670,0x64800,0x38E3000)/EFI\OC\OpenCore.efi'
    #   'PciRoot(0x0)/Pci(0x1A,0x7)/USB(0x0,0x0)/USB(0x1,0x0)/\EFI\OC\OpenCore.efi'
    # return:
    #   'C0778F23-3765-4C8E-9BFA-D60C839E7D2D'
    #   '4E929909-2074-43BA-9773-61EBC110A670'
    #   'None'

    if device_path:
        if not any(partition in device_path for partition in ["GPT", "MBR"]):
            return None
        device_path_array = device_path.split("/")
        # we can always assume [-1] is 'EFI\OC\OpenCore.efi'
        if len(device_path_array) >= 2:
            device_path_stripped = device_path_array[-2]
            device_path_root_array = device_path_stripped.split(",")
            if len(device_path_root_array) > 2:
                return device_path_root_array[2]
    return None


def find_disk_off_uuid(uuid):
    # Find disk by UUID
    disk_list = None
    try:
        disk_list = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", uuid], stdout=subprocess.PIPE).stdout)
    except TypeError:
        pass
    if disk_list:
        try:
            return disk_list["DeviceIdentifier"]
        except KeyError:
            pass
    return None

def get_free_space(disk=None):
    """
    Get free space on disk in bytes

    Parameters:
        disk (str): Path to mounted disk (or folder on disk)

    Returns:
        int: Free space in bytes
    """
    if disk is None:
        disk = "/"

    total, used, free = shutil.disk_usage(disk)
    return free

def grab_mount_point_from_disk(disk):
    data = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", disk], stdout=subprocess.PIPE).stdout.decode().strip().encode())
    return data["MountPoint"]

def monitor_disk_output(disk):
    # Returns MB written on drive
    output = subprocess.check_output(["/usr/sbin/iostat", "-Id", disk])
    output = output.decode("utf-8")
    #  Grab second last entry (last is \n)
    output = output.split(" ")
    output = output[-2]
    return output


def get_preboot_uuid() -> str:
    """
    Get the UUID of the Preboot volume
    """
    args = ["/usr/sbin/ioreg", "-a", "-n", "chosen", "-p", "IODeviceTree", "-r"]
    output = plistlib.loads(subprocess.run(args, stdout=subprocess.PIPE).stdout)
    return output[0]["apfs-preboot-uuid"].strip(b"\0").decode()


def block_os_updaters():
    # Disables any processes that would be likely to mess with
    # the root volume while we're working with it.
    bad_processes = [
        "softwareupdate",
        "SoftwareUpdate",
        "Software Update",
        "MobileSoftwareUpdate",
    ]
    output = subprocess.check_output(["/bin/ps", "-ax"])
    lines = output.splitlines()
    for line in lines:
        entry = line.split()
        pid = entry[0].decode()
        current_process = entry[3].decode()
        for bad_process in bad_processes:
            if bad_process in current_process:
                if pid != "":
                    logging.info(f"Killing Process: {pid} - {current_process.split('/')[-1]}")
                    subprocess.run(["/bin/kill", "-9", pid])
                    break

def check_boot_mode():
    # Check whether we're in Safe Mode or not
    try:
        sys_plist = plistlib.loads(subprocess.run(["/usr/sbin/system_profiler", "SPSoftwareDataType"], stdout=subprocess.PIPE).stdout)
        return sys_plist[0]["_items"][0]["boot_mode"]
    except (KeyError, TypeError, plistlib.InvalidFileException):
        return None


def fetch_staged_update(variant: str = "Update") -> tuple[str, str]:
    """
    Check for staged macOS update
    Supported variants:
    - Preflight
    - Update
    """

    os_build   = None
    os_version = None

    update_config = f"/System/Volumes/Update/{variant}.plist"
    if not Path(update_config).exists():
        return (None, None)
    try:
        update_staged = plistlib.load(open(update_config, "rb"))
    except:
        return (None, None)
    if "update-asset-attributes" not in update_staged:
        return (None, None)

    os_build   = update_staged["update-asset-attributes"]["Build"]
    os_version = update_staged["update-asset-attributes"]["OSVersion"]

    return os_version, os_build


def check_cli_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--build", help="Build OpenCore", action="store_true", required=False)
    parser.add_argument("--verbose", help="Enable verbose boot", action="store_true", required=False)
    parser.add_argument("--debug_oc", help="Enable OpenCore DEBUG", action="store_true", required=False)
    parser.add_argument("--debug_kext", help="Enable kext DEBUG", action="store_true", required=False)
    parser.add_argument("--hide_picker", help="Hide OpenCore picker", action="store_true", required=False)
    parser.add_argument("--disable_sip", help="Disable SIP", action="store_true", required=False)
    parser.add_argument("--disable_smb", help="Disable SecureBootModel", action="store_true", required=False)
    parser.add_argument("--vault", help="Enable OpenCore Vaulting", action="store_true", required=False)
    parser.add_argument("--support_all", help="Allow OpenCore on natively supported Models", action="store_true", required=False)
    parser.add_argument("--firewire", help="Enable FireWire Booting", action="store_true", required=False)
    parser.add_argument("--nvme", help="Enable NVMe Booting", action="store_true", required=False)
    parser.add_argument("--wlan", help="Enable Wake on WLAN support", action="store_true", required=False)
    # parser.add_argument("--disable_amfi", help="Disable AMFI", action="store_true", required=False)
    parser.add_argument("--moderate_smbios", help="Moderate SMBIOS Patching", action="store_true", required=False)
    parser.add_argument("--disable_tb", help="Disable Thunderbolt on 2013-2014 MacBook Pros", action="store_true", required=False)
    parser.add_argument("--force_surplus", help="Force SurPlus in all newer OSes", action="store_true", required=False)

    # Building args requiring value values (ie. --model iMac12,2)
    parser.add_argument("--model", action="store", help="Set custom model", required=False)
    parser.add_argument("--disk", action="store", help="Specifies disk to install to", required=False)
    parser.add_argument("--smbios_spoof", action="store", help="Set SMBIOS patching mode", required=False)

    # sys_patch args
    parser.add_argument("--patch_sys_vol", help="Patches root volume", action="store_true", required=False)
    parser.add_argument("--unpatch_sys_vol", help="Unpatches root volume, EXPERIMENTAL", action="store_true", required=False)
    parser.add_argument("--prepare_for_update", help="Prepares host for macOS update, ex. clean /Library/Extensions", action="store_true", required=False)
    parser.add_argument("--cache_os", help="Caches patcher files (ex. KDKs) for incoming OS in Preflight.plist", action="store_true", required=False)

    # validation args
    parser.add_argument("--validate", help="Runs Validation Tests for CI", action="store_true", required=False)

    # GUI args
    parser.add_argument("--gui_patch", help="Starts GUI in Root Patcher", action="store_true", required=False)
    parser.add_argument("--gui_unpatch", help="Starts GUI in Root Unpatcher", action="store_true", required=False)
    parser.add_argument("--auto_patch", help="Check if patches are needed and prompt user", action="store_true", required=False)
    parser.add_argument("--update_installed", help="Prompt user to finish updating via GUI", action="store_true", required=False)

    args = parser.parse_args()
    if not (
        args.build or
        args.patch_sys_vol or
        args.unpatch_sys_vol or
        args.validate or
        args.auto_patch or
        args.prepare_for_update or
        args.cache_os
    ):
        return None
    else:
        return args


#validation.py:
"""
validation.py: Validation class for the patcher
"""

import atexit
import logging
import subprocess

from pathlib import Path

from . import network_handler

from .. import constants

from ..sys_patch import sys_patch_helpers
from ..efi_builder import build
from ..support import subprocess_wrapper

from ..datasets import (
    example_data,
    model_array,
    os_data
)
from ..sys_patch.patchsets import (
    HardwarePatchsetDetection,
    PatchType,
    DynamicPatchset
)


class PatcherValidation:
    """
    Validation class for the patcher

    Primarily for Continuous Integration
    """

    def __init__(self, global_constants: constants.Constants, verify_unused_files: bool = False) -> None:
        self.constants: constants.Constants = global_constants
        self.verify_unused_files = verify_unused_files
        self.active_patchset_files = []

        self.constants.validate = True

        self.valid_dumps = [
            example_data.MacBookPro.MacBookPro92_Stock,
            example_data.MacBookPro.MacBookPro111_Stock,
            example_data.MacBookPro.MacBookPro133_Stock,

            example_data.Macmini.Macmini52_Stock,
            example_data.Macmini.Macmini61_Stock,
            example_data.Macmini.Macmini71_Stock,

            example_data.iMac.iMac81_Stock,
            example_data.iMac.iMac112_Stock,
            example_data.iMac.iMac122_Upgraded,
            example_data.iMac.iMac122_Upgraded_Nvidia,
            example_data.iMac.iMac151_Stock,

            example_data.MacPro.MacPro31_Stock,
            example_data.MacPro.MacPro31_Upgrade,
            example_data.MacPro.MacPro31_Modern_AMD,
            example_data.MacPro.MacPro31_Modern_Kepler,
            example_data.MacPro.MacPro41_Upgrade,
            example_data.MacPro.MacPro41_Modern_AMD,
            example_data.MacPro.MacPro41_51__Flashed_Modern_AMD,
            example_data.MacPro.MacPro41_51_Flashed_NVIDIA_WEB_DRIVERS,
        ]

        self.valid_dumps_native = [
            example_data.iMac.iMac201_Stock,
            example_data.MacBookPro.MacBookPro141_SSD_Upgrade,
        ]

        self._validate_configs()
        self._validate_sys_patch()


    def _build_prebuilt(self) -> None:
        """
        Generate a build for each predefined model
        Then validate against ocvalidate
        """

        for model in model_array.SupportedSMBIOS:
            logging.info(f"Validating predefined model: {model}")
            self.constants.custom_model = model
            build.BuildOpenCore(self.constants.custom_model, self.constants)
            result = subprocess.run([self.constants.ocvalidate_path, f"{self.constants.opencore_release_folder}/EFI/OC/config.plist"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info("Error on build!")
                subprocess_wrapper.log(result)
                raise Exception(f"Validation failed for predefined model: {model}")
            else:
                logging.info(f"Validation succeeded for predefined model: {model}")


    def _build_dumps(self) -> None:
        """
        Generate a build for each predefined model
        Then validate against ocvalidate
        """

        for model in self.valid_dumps:
            self.constants.computer = model
            self.constants.custom_model = ""
            logging.info(f"Validating dumped model: {self.constants.computer.real_model}")
            build.BuildOpenCore(self.constants.computer.real_model, self.constants)
            result = subprocess.run([self.constants.ocvalidate_path, f"{self.constants.opencore_release_folder}/EFI/OC/config.plist"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info("Error on build!")
                subprocess_wrapper.log(result)
                raise Exception(f"Validation failed for predefined model: {self.constants.computer.real_model}")
            else:
                logging.info(f"Validation succeeded for predefined model: {self.constants.computer.real_model}")


    def _validate_root_patch_files(self, major_kernel: int, minor_kernel: int) -> None:
        """
        Validate that all files in the patchset are present in the payload

        Parameters:
            major_kernel (int): Major kernel version
            minor_kernel (int): Minor kernel version
        """

        patch_type_merge_exempt     = ["MechanismPlugins", "ModulePlugins"]
        patch_type_overwrite_exempt = []

        patchset = HardwarePatchsetDetection(self.constants, xnu_major=major_kernel, xnu_minor=minor_kernel, validation=True).patches

        for patch_core in patchset:
            # Check if any unknown PathType is present
            for install_type in patchset[patch_core]:
                if install_type not in PatchType:
                    raise Exception(f"Unknown PatchType: {install_type}")

            for install_type in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.OVERWRITE_DATA_VOLUME, PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
                if install_type in patchset[patch_core]:
                    for install_directory in patchset[patch_core][install_type]:
                        for install_file in patchset[patch_core][install_type][install_directory]:
                            try:
                                if patchset[patch_core][install_type][install_directory][install_file] in DynamicPatchset:
                                    continue
                            except TypeError:
                                pass

                            # Technically there is nothing wrong with using a .framework with OVERWRITE, but it's a good indicator of a mistake
                            if install_type in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.OVERWRITE_DATA_VOLUME]:
                                if install_file.endswith(".framework") and install_file not in patch_type_overwrite_exempt:
                                    raise Exception(f"{install_file} used with {install_type}, are you certain this is correct?")
                            elif install_type in [PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
                                if not install_file.endswith(".framework") and install_file not in patch_type_merge_exempt:
                                    raise Exception(f"{install_file} used with {install_type}, are you certain this is correct?")

                            source_file = str(self.constants.payload_local_binaries_root_path) + "/" + patchset[patch_core][install_type][install_directory][install_file] + install_directory + "/" + install_file
                            if not Path(source_file).exists():
                                logging.info(f"File not found: {source_file}")
                                raise Exception(f"Failed to find {source_file}")
                            if self.verify_unused_files is True:
                                if source_file not in self.active_patchset_files:
                                    self.active_patchset_files.append(source_file)

        logging.info(f"Validating against Darwin {major_kernel}.{minor_kernel}")
        if not sys_patch_helpers.SysPatchHelpers(self.constants).generate_patchset_plist(patchset, f"OpenCore-Legacy-Patcher-{major_kernel}.{minor_kernel}.plist", None, None):
            raise Exception("Failed to generate patchset plist")

        # Remove the plist file after validation
        Path(self.constants.payload_path / f"OpenCore-Legacy-Patcher-{major_kernel}.{minor_kernel}.plist").unlink()


    def _unmount_dmg(self) -> None:
        """
        Unmounts the Universal-Binaries.dmg
        """
        if Path(self.constants.payload_path / Path("Universal-Binaries_overlay")).exists():
            subprocess.run(
                [
                    "/bin/rm", "-f", Path(self.constants.payload_path / Path("Universal-Binaries_overlay"))
                ],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT
            )
        if Path(self.constants.payload_path / Path("Universal-Binaries")).exists():
            output = subprocess.run(
                [
                    "/usr/bin/hdiutil", "detach", Path(self.constants.payload_path / Path("Universal-Binaries")),
                    "-force"
                ],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT
            )

            if output.returncode != 0:
                logging.info("Failed to unmount Universal-Binaries.dmg")
                subprocess_wrapper.log(output)

                raise Exception("Failed to unmount Universal-Binaries.dmg")


    def _validate_sys_patch(self) -> None:
        """
        Validates sys_patch modules
        """

        if not Path(self.constants.payload_local_binaries_root_path_dmg).exists():
            dl_obj = network_handler.DownloadObject(f"https://github.com/dortania/PatcherSupportPkg/releases/download/{self.constants.patcher_support_pkg_version}/Universal-Binaries.dmg", self.constants.payload_local_binaries_root_path_dmg)
            dl_obj.download(spawn_thread=False)
            if dl_obj.download_complete is False:
                logging.info("Failed to download Universal-Binaries.dmg")
                raise Exception("Failed to download Universal-Binaries.dmg")

        logging.info("Validating Root Patch File integrity")

        self._unmount_dmg()

        output = subprocess.run(
            [
                "/usr/bin/hdiutil", "attach", "-noverify", f"{self.constants.payload_local_binaries_root_path_dmg}",
                "-mountpoint", Path(self.constants.payload_path / Path("Universal-Binaries")),
                "-nobrowse",
                "-shadow", Path(self.constants.payload_path / Path("Universal-Binaries_overlay")),
                "-passphrase", "password"
            ],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )

        if output.returncode != 0:
            logging.info("Failed to mount Universal-Binaries.dmg")
            subprocess_wrapper.log(output)

            raise Exception("Failed to mount Universal-Binaries.dmg")

        logging.info("Mounted Universal-Binaries.dmg")

        atexit.register(self._unmount_dmg)

        for supported_os in [os_data.os_data.big_sur, os_data.os_data.monterey, os_data.os_data.ventura, os_data.os_data.sonoma, os_data.os_data.sequoia]:
            for i in range(0, 10):
                self._validate_root_patch_files(supported_os, i)

        logging.info("Validating SNB Board ID patcher")
        self.constants.computer.reported_board_id = "Mac-7BA5B2DFE22DDD8C"
        sys_patch_helpers.SysPatchHelpers(self.constants).snb_board_id_patch(self.constants.payload_local_binaries_root_path)

        if self.verify_unused_files is True:
            self._find_unused_files()

        # unmount the dmg
        output = subprocess.run(
            [
                "/usr/bin/hdiutil", "detach", Path(self.constants.payload_path / Path("Universal-Binaries")),
                "-force"
            ],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )

        if output.returncode != 0:
            logging.info("Failed to unmount Universal-Binaries.dmg")
            subprocess_wrapper.log(output)

            raise Exception("Failed to unmount Universal-Binaries.dmg")

        subprocess.run(
            [
                "/bin/rm", "-f", Path(self.constants.payload_path / Path("Universal-Binaries_overlay"))
            ],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )


    def _find_unused_files(self) -> None:
        """
        Find PatcherSupportPkg files that are unused by the patcher

        Note this function is extremely slow, so only manually run when needed
        """
        if self.active_patchset_files == []:
            return

        unused_files = []

        for file in Path(self.constants.payload_local_binaries_root_path).rglob("*"):
            if file.is_dir():
                continue

            relative_path = Path(file).relative_to(self.constants.payload_local_binaries_root_path)

            if relative_path.name == ".DS_Store":
                continue

            if str(relative_path) in [".fseventsd/fseventsd-uuid", ".signed"]:
                continue

            is_used = False
            for used_file in self.active_patchset_files:
                used_relative_path = Path(used_file).relative_to(self.constants.payload_local_binaries_root_path)
                if str(relative_path) in str(used_relative_path):
                    is_used = True
                    break
                if str(used_relative_path) in str(relative_path):
                    is_used = True
                    break

            if is_used:
                continue

            unused_files.append(relative_path)

        if len(unused_files) > 0:
            logging.info("Unused files found:")
            for file in unused_files:
                logging.info(f"  {file}")


    def _validate_configs(self) -> None:
        """
        Validates build modules
        """

        # First run is with default settings
        self._build_prebuilt()
        self._build_dumps()

        # Second run, flip all settings
        self.constants.verbose_debug = True
        self.constants.opencore_debug = True
        self.constants.kext_debug = True
        self.constants.kext_variant = "DEBUG"
        self.constants.kext_debug = True
        self.constants.showpicker = False
        self.constants.sip_status = False
        self.constants.secure_status = True
        self.constants.firewire_boot = True
        self.constants.nvme_boot = True
        self.constants.enable_wake_on_wlan = True
        self.constants.disable_tb = True
        self.constants.force_surplus = True
        self.constants.software_demux = True
        self.constants.serial_settings = "Minimal"

        self._build_prebuilt()
        self._build_dumps()

        subprocess.run(["/bin/rm", "-rf", self.constants.build_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

#sys_patch
#auto_patcher
__init__.py:

"""
auto_patcher: Automatic system volume patching after updates, etc.

Usage:

>>> # Installing launch services
>>> from auto_patcher import InstallAutomaticPatchingServices
>>> InstallAutomaticPatchingServices(self.constants).install_auto_patcher_launch_agent()


>>> # When patching the system volume (ex. launch service)
>>> from auto_patcher import StartAutomaticPatching
>>> StartAutomaticPatching(self.constants).start_auto_patch()
"""

from .install import InstallAutomaticPatchingServices
from .start   import StartAutomaticPatching


#install.py:
"""
install.py: Install the auto patcher launch services
"""

import hashlib
import logging
import plistlib
import subprocess

from pathlib import Path

from ... import constants

from ...volume import generate_copy_arguments

from ...support import (
    utilities,
    subprocess_wrapper
)


class InstallAutomaticPatchingServices:
    """
    Install the auto patcher launch services
    """

    def __init__(self, global_constants: constants.Constants):
        self.constants: constants.Constants = global_constants


    def install_auto_patcher_launch_agent(self, kdk_caching_needed: bool = False):
        """
        Install patcher launch services

        See start_auto_patch() comments for more info
        """

        if self.constants.launcher_script is not None:
            logging.info("- Skipping Auto Patcher Launch Agent, not supported when running from source")
            return

        services = {
            self.constants.auto_patch_launch_agent_path:        "/Library/LaunchAgents/com.dortania.opencore-legacy-patcher.auto-patch.plist",
            self.constants.update_launch_daemon_path:           "/Library/LaunchDaemons/com.dortania.opencore-legacy-patcher.macos-update.plist",
            **({ self.constants.rsr_monitor_launch_daemon_path: "/Library/LaunchDaemons/com.dortania.opencore-legacy-patcher.rsr-monitor.plist" } if self._create_rsr_monitor_daemon() else {}),
            **({ self.constants.kdk_launch_daemon_path:         "/Library/LaunchDaemons/com.dortania.opencore-legacy-patcher.os-caching.plist" } if kdk_caching_needed is True else {} ),
        }

        for service in services:
            name = Path(service).name
            logging.info(f"- Installing {name}")
            if Path(services[service]).exists():
                if hashlib.sha256(open(service, "rb").read()).hexdigest() == hashlib.sha256(open(services[service], "rb").read()).hexdigest():
                    logging.info(f"  - {name} checksums match, skipping")
                    continue
                logging.info(f"  - Existing service found, removing")
                subprocess_wrapper.run_as_root_and_verify(["/bin/rm", services[service]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            # Create parent directories
            if not Path(services[service]).parent.exists():
                logging.info(f"  - Creating {Path(services[service]).parent} directory")
                subprocess_wrapper.run_as_root_and_verify(["/bin/mkdir", "-p", Path(services[service]).parent], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            subprocess_wrapper.run_as_root_and_verify(generate_copy_arguments(service, services[service]), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

            # Set the permissions on the service
            subprocess_wrapper.run_as_root_and_verify(["/bin/chmod", "644", services[service]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            subprocess_wrapper.run_as_root_and_verify(["/usr/sbin/chown", "root:wheel", services[service]], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _create_rsr_monitor_daemon(self) -> bool:
        # Get kext list in /Library/Extensions that have the 'GPUCompanionBundles' property
        # This is used to determine if we need to run the RSRMonitor
        logging.info("- Checking if RSRMonitor is needed")

        cryptex_path = f"/System/Volumes/Preboot/{utilities.get_preboot_uuid()}/cryptex1/current/OS.dmg"
        if not Path(cryptex_path).exists():
            logging.info("- No OS.dmg, skipping RSRMonitor")
            return False

        kexts = []
        for kext in Path("/Library/Extensions").glob("*.kext"):
            try:
                if not Path(f"{kext}/Contents/Info.plist").exists():
                    continue
            except Exception as e:
                logging.info(f"  - Failed to check if {kext.name} is a directory: {e}")
                continue
            try:
                kext_plist = plistlib.load(open(f"{kext}/Contents/Info.plist", "rb"))
            except Exception as e:
                logging.info(f"  - Failed to load plist for {kext.name}: {e}")
                continue
            if "GPUCompanionBundles" not in kext_plist:
                continue
            logging.info(f"  - Found kext with GPUCompanionBundles: {kext.name}")
            kexts.append(kext.name)

        # If we have no kexts, we don't need to run the RSRMonitor
        if not kexts:
            logging.info("- No kexts found with GPUCompanionBundles, skipping RSRMonitor")
            return False

        # Load the RSRMonitor plist
        rsr_monitor_plist = plistlib.load(open(self.constants.rsr_monitor_launch_daemon_path, "rb"))

        arguments = ["/bin/rm", "-Rfv"]
        arguments += [f"/Library/Extensions/{kext}" for kext in kexts]

        # Add the arguments to the RSRMonitor plist
        rsr_monitor_plist["ProgramArguments"] = arguments

        # Next add monitoring for '/System/Volumes/Preboot/{UUID}/cryptex1/OS.dmg'
        logging.info(f"  - Adding monitor: {cryptex_path}")
        rsr_monitor_plist["WatchPaths"] = [
            cryptex_path,
        ]

        # Write the RSRMonitor plist
        plistlib.dump(rsr_monitor_plist, Path(self.constants.rsr_monitor_launch_daemon_path).open("wb"))

        return True


#start.py:
"""
start.py: Start automatic patching of host
"""

import wx
import wx.html2

import logging
import plistlib
import requests
import markdown2
import subprocess
import webbrowser


from ... import constants

from ...datasets import css_data

from ...wx_gui import (
    gui_entry,
    gui_support
)
from ...support import (
    utilities,
    updates,
    global_settings,
    network_handler,
)
from ..patchsets import (
    HardwarePatchsetDetection,
    HardwarePatchsetValidation
)


class StartAutomaticPatching:
    """
    Start automatic patching of host
    """

    def __init__(self, global_constants: constants.Constants):
        self.constants: constants.Constants = global_constants


    def start_auto_patch(self):
        """
        Initiates automatic patching

        Auto Patching's main purpose is to try and tell the user they're missing root patches
        New users may not realize OS updates remove our patches, so we try and run when nessasary

        Conditions for running:
            - Verify running GUI (TUI users can write their own scripts)
            - Verify the Snapshot Seal is intact (if not, assume user is running patches)
            - Verify this model needs patching (if not, assume user upgraded hardware and OCLP was not removed)
            - Verify there are no updates for OCLP (ensure we have the latest patch sets)

        If all these tests pass, start Root Patcher

        """

        logging.info("- Starting Automatic Patching")
        if self.constants.wxpython_variant is False:
            logging.info("- Auto Patch option is not supported on TUI, please use GUI")
            return

        dict = updates.CheckBinaryUpdates(self.constants).check_binary_updates()
        if dict:
            version = dict["Version"]
            logging.info(f"- Found new version: {version}")

            app = wx.App()
            mainframe = wx.Frame(None, -1, "OpenCore Legacy Patcher")

            ID_GITHUB = wx.NewId()
            ID_UPDATE = wx.NewId()

            url = "https://api.github.com/repos/dortania/OpenCore-Legacy-Patcher/releases/latest"
            response = requests.get(url).json()
            try:
                changelog = response["body"].split("## Asset Information")[0]
            except: #if user constantly checks for updates, github will rate limit them
                changelog = """## Unable to fetch changelog

Please check the Github page for more information about this release."""

            html_markdown = markdown2.markdown(changelog, extras=["tables"])
            html_css = css_data.updater_css
            frame = wx.Dialog(None, -1, title="", size=(650, 500))
            frame.SetMinSize((650, 500))
            frame.SetWindowStyle(wx.STAY_ON_TOP)
            panel = wx.Panel(frame)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.AddSpacer(10)
            self.title_text = wx.StaticText(panel, label="A new version of OpenCore Legacy Patcher is available!")
            self.description = wx.StaticText(panel, label=f"OpenCore Legacy Patcher {version} is now available - You have {self.constants.patcher_version}{' (Nightly)' if not self.constants.commit_info[0].startswith('refs/tags') else ''}. Would you like to update?")
            self.title_text.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
            self.description.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            self.web_view = wx.html2.WebView.New(panel, style=wx.BORDER_SUNKEN)
            html_code = f'''
<html>
    <head>
        <style>
            {html_css}
        </style>
    </head>
    <body class="markdown-body">
        {html_markdown.replace("<a href=", "<a target='_blank' href=")}
    </body>
</html>
'''
            self.web_view.SetPage(html_code, "")
            self.web_view.Bind(wx.html2.EVT_WEBVIEW_NEWWINDOW, self._onWebviewNav)
            self.web_view.EnableContextMenu(False)
            self.close_button = wx.Button(panel, label="Ignore")
            self.close_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(wx.ID_CANCEL))
            self.view_button = wx.Button(panel, ID_GITHUB, label="View on GitHub")
            self.view_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(ID_GITHUB))
            self.install_button = wx.Button(panel, label="Download and Install")
            self.install_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(ID_UPDATE))
            self.install_button.SetDefault()

            buttonsizer = wx.BoxSizer(wx.HORIZONTAL)
            buttonsizer.Add(self.close_button, 0, wx.ALIGN_CENTRE | wx.RIGHT, 5)
            buttonsizer.Add(self.view_button, 0, wx.ALIGN_CENTRE | wx.LEFT|wx.RIGHT, 5)
            buttonsizer.Add(self.install_button, 0, wx.ALIGN_CENTRE | wx.LEFT, 5)
            sizer = wx.BoxSizer(wx.VERTICAL)
            sizer.Add(self.title_text, 0, wx.ALIGN_CENTRE | wx.TOP, 20)
            sizer.Add(self.description, 0, wx.ALIGN_CENTRE | wx.BOTTOM, 20)
            sizer.Add(self.web_view, 1, wx.EXPAND | wx.LEFT|wx.RIGHT, 10)
            sizer.Add(buttonsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 20)
            panel.SetSizer(sizer)
            frame.Centre()

            result = frame.ShowModal()


            if result == ID_GITHUB:
                webbrowser.open(dict["Github Link"])
            elif result == ID_UPDATE:
                gui_entry.EntryPoint(self.constants).start(entry=gui_entry.SupportedEntryPoints.UPDATE_APP)


            return

        if utilities.check_seal() is True:
            logging.info("- Detected Snapshot seal intact, detecting patches")
            patches = HardwarePatchsetDetection(self.constants).device_properties
            if not any(not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True for patch in patches):
                patches = {}
            if patches:
                logging.info("- Detected applicable patches, determining whether possible to patch")
                if patches[HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE] is True:
                    logging.info("- Cannot run patching")
                    return

                logging.info("- Determined patching is possible, checking for OCLP updates")
                patch_string = ""
                for patch in patches:
                    if patches[patch] is True and not patch.startswith("Settings") and not patch.startswith("Validation"):
                        patch_string += f"- {patch}\n"

                logging.info("- No new binaries found on Github, proceeding with patching")

                warning_str = ""
                if network_handler.NetworkUtilities("https://api.github.com/repos/dortania/OpenCore-Legacy-Patcher/releases/latest").verify_network_connection() is False:
                    warning_str = f"""\n\nWARNING: We're unable to verify whether there are any new releases of OpenCore Legacy Patcher on Github. Be aware that you may be using an outdated version for this OS. If you're unsure, verify on Github that OpenCore Legacy Patcher {self.constants.patcher_version} is the latest official release"""

                args = [
                    "/usr/bin/osascript",
                    "-e",
                    f"""display dialog "OpenCore Legacy Patcher has detected you're running without Root Patches, and would like to install them.\n\nmacOS wipes all root patches during OS installs and updates, so they need to be reinstalled.\n\nFollowing Patches have been detected for your system: \n{patch_string}\nWould you like to apply these patches?{warning_str}" """
                    f'with icon POSIX file "{self.constants.app_icon_path}"',
                ]
                output = subprocess.run(
                    args,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT
                )
                if output.returncode == 0:
                    gui_entry.EntryPoint(self.constants).start(entry=gui_entry.SupportedEntryPoints.SYS_PATCH, start_patching=True)
                return

            else:
                logging.info("- No patches detected")
        else:
            logging.info("- Detected Snapshot seal not intact, skipping")

        if self._determine_if_versions_match():
            self._determine_if_boot_matches()


    def _onWebviewNav(self, event):
        url = event.GetURL()
        webbrowser.open(url)


    def _determine_if_versions_match(self):
        """
        Determine if the booted version of OCLP matches the installed version

        ie. Installed app is 0.2.0, but EFI version is 0.1.0

        Returns:
            bool: True if versions match, False if not
        """

        logging.info("- Checking booted vs installed OCLP Build")
        if self.constants.computer.oclp_version is None:
            logging.info("- Booted version not found")
            return True

        if self.constants.computer.oclp_version == self.constants.patcher_version:
            logging.info("- Versions match")
            return True

        if self.constants.special_build is True:
            # Version doesn't match and we're on a special build
            # Special builds don't have good ways to compare versions
            logging.info("- Special build detected, assuming installed is older")
            return False

        # Check if installed version is newer than booted version
        if updates.CheckBinaryUpdates(self.constants).check_if_newer(self.constants.computer.oclp_version):
            logging.info("- Installed version is newer than booted version")
            return True

        args = [
            "/usr/bin/osascript",
            "-e",
            f"""display dialog "OpenCore Legacy Patcher has detected that you are booting {'a different' if self.constants.special_build else 'an outdated'} OpenCore build\n- Booted: {self.constants.computer.oclp_version}\n- Installed: {self.constants.patcher_version}\n\nWould you like to update the OpenCore bootloader?" """
            f'with icon POSIX file "{self.constants.app_icon_path}"',
        ]
        output = subprocess.run(
            args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT
        )
        if output.returncode == 0:
            logging.info("- Launching GUI's Build/Install menu")
            self.constants.start_build_install = True
            gui_entry.EntryPoint(self.constants).start(entry=gui_entry.SupportedEntryPoints.BUILD_OC)

        return False


    def _determine_if_boot_matches(self):
        """
        Determine if the boot drive matches the macOS drive
        ie. Booted from USB, but macOS is on internal disk

        Goal of this function is to determine whether the user
        is using a USB drive to Boot OpenCore but macOS does not
        reside on the same drive as the USB.

        If we determine them to be mismatched, notify the user
        and ask if they want to install to install to disk.
        """

        logging.info("- Determining if macOS drive matches boot drive")

        should_notify = global_settings.GlobalEnviromentSettings().read_property("AutoPatch_Notify_Mismatched_Disks")
        if should_notify is False:
            logging.info("- Skipping due to user preference")
            return
        if self.constants.host_is_hackintosh is True:
            logging.info("- Skipping due to hackintosh")
            return
        if not self.constants.booted_oc_disk:
            logging.info("- Failed to find disk OpenCore launched from")
            return

        root_disk = self.constants.booted_oc_disk.strip("disk")
        root_disk = "disk" + root_disk.split("s")[0]

        logging.info(f"  - Boot Drive: {self.constants.booted_oc_disk} ({root_disk})")
        macOS_disk = utilities.get_disk_path()
        logging.info(f"  - macOS Drive: {macOS_disk}")
        physical_stores = utilities.find_apfs_physical_volume(macOS_disk)
        logging.info(f"  - APFS Physical Stores: {physical_stores}")

        disk_match = False
        for disk in physical_stores:
            if root_disk in disk:
                logging.info(f"- Boot drive matches macOS drive ({disk})")
                disk_match = True
                break

        if disk_match is True:
            return

        # Check if OpenCore is on a USB drive
        logging.info("- Boot Drive does not match macOS drive, checking if OpenCore is on a USB drive")

        disk_info = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", root_disk], stdout=subprocess.PIPE).stdout)
        try:
            if disk_info["Ejectable"] is False:
                logging.info("- Boot Disk is not removable, skipping prompt")
                return

            logging.info("- Boot Disk is ejectable, prompting user to install to internal")

            args = [
                "/usr/bin/osascript",
                "-e",
                f"""display dialog "OpenCore Legacy Patcher has detected that you are booting OpenCore from an USB or External drive.\n\nIf you would like to boot your Mac normally without a USB drive plugged in, you can install OpenCore to the internal hard drive.\n\nWould you like to launch OpenCore Legacy Patcher and install to disk?" """
                f'with icon POSIX file "{self.constants.app_icon_path}"',
            ]
            output = subprocess.run(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT
            )
            if output.returncode == 0:
                logging.info("- Launching GUI's Build/Install menu")
                self.constants.start_build_install = True
                gui_entry.EntryPoint(self.constants).start(entry=gui_entry.SupportedEntryPoints.BUILD_OC)

        except KeyError:
            logging.info("- Unable to determine if boot disk is removable, skipping prompt")


#kernelcache
#__init__.py

"""
kernelcache: Library for rebuilding macOS kernelcache files.

Usage:

>>> from kernelcache import RebuildKernelCache
>>> RebuildKernelCache(os_version, mount_location, auxiliary_cache, auxiliary_cache_only).rebuild()
"""

from .rebuild import RebuildKernelCache
from .kernel_collection.support import KernelCacheSupport

#base
#cache.py
"""
cache.py: Base class for kernel cache management
"""

class BaseKernelCache:

    def rebuild(self) -> None:
        raise NotImplementedError("To be implemented in subclass")

#kernel_collection
#auxiliary.py
"""
auxiliary.py: Auxiliary Kernel Collection management
"""

import logging
import subprocess

from ..base.cache import BaseKernelCache
from ....support  import subprocess_wrapper


class AuxiliaryKernelCollection(BaseKernelCache):

    def __init__(self, mount_location: str) -> None:
        self.mount_location = mount_location


    def _kmutil_arguments(self) -> list[str]:
        args = ["/usr/bin/kmutil", "create", "--allow-missing-kdk"]

        args.append("--new")
        args.append("aux")

        args.append("--boot-path")
        args.append(f"{self.mount_location}/System/Library/KernelCollections/BootKernelExtensions.kc")

        args.append("--system-path")
        args.append(f"{self.mount_location}/System/Library/KernelCollections/SystemKernelExtensions.kc")

        return args


    def _force_auxiliary_usage(self) -> bool:
        """
        Force the auxiliary kernel collection to be used.

        This is required as Apple doesn't offer a public way
        to rebuild the auxiliary kernel collection. Instead deleting
        necessary files and directories will force the newly built
        collection to be used.
        """

        logging.info("- Forcing Auxiliary Kernel Collection usage")
        result = subprocess_wrapper.run_as_root(["/usr/bin/killall", "syspolicyd", "kernelmanagerd"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.info("- Unable to kill syspolicyd and kernelmanagerd")
            subprocess_wrapper.log(result)
            return False

        for file in ["KextPolicy", "KextPolicy-shm", "KextPolicy-wal"]:
            result = subprocess_wrapper.run_as_root(["/bin/rm", f"/private/var/db/SystemPolicyConfiguration/{file}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info(f"- Unable to remove {file}")
                subprocess_wrapper.log(result)
                return False

        return True


    def rebuild(self) -> None:
        logging.info("- Building new Auxiliary Kernel Collection")
        result = subprocess_wrapper.run_as_root(self._kmutil_arguments(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.info("- Unable to build Auxiliary Kernel Collection")
            subprocess_wrapper.log(result)
            return False

        if self._force_auxiliary_usage() is False:
            return False

        return True


#boot_system.py:
"""
boot_system.py: Boot and System Kernel Collection management
"""

import logging
import subprocess

from ..base.cache import BaseKernelCache
from ....support  import subprocess_wrapper
from ....datasets import os_data


class BootSystemKernelCollections(BaseKernelCache):

    def __init__(self, mount_location: str, detected_os: int, auxiliary_kc: bool) -> None:
        self.mount_location = mount_location
        self.detected_os  = detected_os
        self.auxiliary_kc = auxiliary_kc


    def _kmutil_arguments(self) -> list[str]:
        """
        Generate kmutil arguments for creating or updating
        the boot, system and auxiliary kernel collections
        """

        args = ["/usr/bin/kmutil"]

        if self.detected_os >= os_data.os_data.ventura:
            args.append("create")
            args.append("--allow-missing-kdk")
        else:
            args.append("install")

        args.append("--volume-root")
        args.append(self.mount_location)

        args.append("--update-all")

        args.append("--variant-suffix")
        args.append("release")

        if self.auxiliary_kc is True:
            # Following arguments are supposed to skip kext consent
            # prompts when creating auxiliary KCs with SIP disabled
            args.append("--no-authentication")
            args.append("--no-authorization")

        return args


    def rebuild(self) -> bool:
        logging.info(f"- Rebuilding {'Boot and System' if self.auxiliary_kc is False else 'Boot, System and Auxiliary'} Kernel Collections")
        if self.auxiliary_kc is True:
            logging.info("  (You will get a prompt by System Preferences, ignore for now)")

        result = subprocess_wrapper.run_as_root(self._kmutil_arguments(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            subprocess_wrapper.log(result)
            return False

        return True

#support.py:
"""
support.py: Kernel Cache support functions
"""

import logging
import plistlib

from pathlib  import Path
from datetime import datetime

from ...patchsets import PatchType

from ....datasets import os_data
from ....support  import subprocess_wrapper


class KernelCacheSupport:

    def __init__(self, mount_location_data: str, detected_os: int, skip_root_kmutil_requirement: bool) -> None:
        self.mount_location_data = mount_location_data
        self.detected_os = detected_os
        self.skip_root_kmutil_requirement = skip_root_kmutil_requirement


    def check_kexts_needs_authentication(self, kext_name: str) -> bool:
        """
        Verify whether the user needs to authenticate in System Preferences
        Sets 'needs_to_open_preferences' to True if the kext is not in the AuxKC

        Logic:
            Under 'private/var/db/KernelManagement/AuxKC/CurrentAuxKC/com.apple.kcgen.instructions.plist'
                ["kextsToBuild"][i]:
                ["bundlePathMainOS"] = /Library/Extensions/Test.kext
                ["cdHash"] =           Bundle's CDHash (random on ad-hoc signed, static on dev signed)
                ["teamID"] =           Team ID (blank on ad-hoc signed)
            To grab the CDHash of a kext, run 'codesign -dvvv <kext_path>'
        """
        if not kext_name.endswith(".kext"):
            return False

        try:
            aux_cache_path = Path(self.mount_location_data) / Path("/private/var/db/KernelExtensionManagement/AuxKC/CurrentAuxKC/com.apple.kcgen.instructions.plist")
            if aux_cache_path.exists():
                aux_cache_data = plistlib.load((aux_cache_path).open("rb"))
                for kext in aux_cache_data["kextsToBuild"]:
                    if "bundlePathMainOS" in aux_cache_data["kextsToBuild"][kext]:
                        if aux_cache_data["kextsToBuild"][kext]["bundlePathMainOS"] == f"/Library/Extensions/{kext_name}":
                            return False
        except PermissionError:
            pass

        logging.info(f"  - {kext_name} requires authentication in System Preferences")

        return True


    def add_auxkc_support(self, install_file: str, source_folder_path: str, install_patch_directory: str, destination_folder_path: str) -> str:
        """
        Patch provided Kext to support Auxiliary Kernel Collection

        Logic:
            In macOS Ventura, KDKs are required to build new Boot and System KCs
            However for some patch sets, we're able to use the Auxiliary KCs with '/Library/Extensions'

            kernelmanagerd determines which kext is installed by their 'OSBundleRequired' entry
            If a kext is labeled as 'OSBundleRequired: Root' or 'OSBundleRequired: Safe Boot',
            kernelmanagerd will require the kext to be installed in the Boot/SysKC

            Additionally, kexts starting with 'com.apple.' are not natively allowed to be installed
            in the AuxKC. So we need to explicitly set our 'OSBundleRequired' to 'Auxiliary'

        Parameters:
            install_file            (str): Kext file name
            source_folder_path      (str): Source folder path
            install_patch_directory (str): Patch directory
            destination_folder_path (str): Destination folder path

        Returns:
            str: Updated destination folder path
        """

        if self.skip_root_kmutil_requirement is False:
            return destination_folder_path
        if not install_file.endswith(".kext"):
            return destination_folder_path
        if install_patch_directory != "/System/Library/Extensions":
            return destination_folder_path
        if self.detected_os < os_data.os_data.ventura:
            return destination_folder_path

        updated_install_location = str(self.mount_location_data) + "/Library/Extensions"

        logging.info(f"  - Adding AuxKC support to {install_file}")
        plist_path = Path(Path(source_folder_path) / Path(install_file) / Path("Contents/Info.plist"))
        plist_data = plistlib.load((plist_path).open("rb"))

        # Check if we need to update the 'OSBundleRequired' entry
        if not plist_data["CFBundleIdentifier"].startswith("com.apple."):
            return updated_install_location
        if "OSBundleRequired" in plist_data:
            if plist_data["OSBundleRequired"] == "Auxiliary":
                return updated_install_location

        plist_data["OSBundleRequired"] = "Auxiliary"
        plistlib.dump(plist_data, plist_path.open("wb"))

        return updated_install_location


    def clean_auxiliary_kc(self) -> None:
        """
        Clean the Auxiliary Kernel Collection

        Logic:
            When reverting root volume patches, the AuxKC will still retain the UUID
            it was built against. Thus when Boot/SysKC are reverted, Aux will break
            To resolve this, delete all installed kexts in /L*/E* and rebuild the AuxKC
            We can verify our binaries based off the OpenCore-Legacy-Patcher.plist file
        """

        if self.detected_os < os_data.os_data.big_sur:
            return

        logging.info("- Cleaning Auxiliary Kernel Collection")
        oclp_path = "/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist"
        if Path(oclp_path).exists():
            oclp_plist_data = plistlib.load(Path(oclp_path).open("rb"))
            for key in oclp_plist_data:
                if isinstance(oclp_plist_data[key], (bool, int)):
                    continue
                for install_type in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.OVERWRITE_DATA_VOLUME, PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
                    if install_type not in oclp_plist_data[key]:
                        continue
                    for location in oclp_plist_data[key][install_type]:
                        if not location.endswith("Extensions"):
                            continue
                        for file in oclp_plist_data[key][install_type][location]:
                            if not file.endswith(".kext"):
                                continue
                            if not Path(f"/Library/Extensions/{file}").exists():
                                continue
                            logging.info(f"  - Removing {file}")
                            subprocess_wrapper.run_as_root(["/bin/rm", "-Rf", f"/Library/Extensions/{file}"])

        # Handle situations where users migrated from older OSes with a lot of garbage in /L*/E*
        # ex. Nvidia Web Drivers, NetUSB, dosdude1's patches, etc.
        # Move if file's age is older than October 2021 (year before Ventura)
        if self.detected_os < os_data.os_data.ventura:
            return

        relocation_path = "/Library/Relocated Extensions"
        if not Path(relocation_path).exists():
            subprocess_wrapper.run_as_root(["/bin/mkdir", relocation_path])

        for file in Path("/Library/Extensions").glob("*.kext"):
            try:
                if datetime.fromtimestamp(file.stat().st_mtime) < datetime(2021, 10, 1):
                    logging.info(f"  - Relocating {file.name} kext to {relocation_path}")
                    if Path(relocation_path) / Path(file.name).exists():
                        subprocess_wrapper.run_as_root(["/bin/rm", "-Rf", relocation_path / Path(file.name)])
                    subprocess_wrapper.run_as_root(["/bin/mv", file, relocation_path])
            except:
                # Some users have the most cursed /L*/E* folders
                # ex. Symlinks pointing to symlinks pointing to dead files
                pass


#mkext
#mkext.py
"""
mkext.py: MKext cache management
"""

import logging
import subprocess

from ..base.cache import BaseKernelCache

from ....support import subprocess_wrapper


class MKext(BaseKernelCache):

    def __init__(self, mount_location: str) -> None:
        self.mount_location = mount_location


    def _mkext_arguments(self) -> list[str]:
        args = ["/usr/bin/touch", f"{self.mount_location}/System/Library/Extensions"]
        return args


    def rebuild(self) -> None:
        logging.info("- Rebuilding MKext cache")
        result = subprocess_wrapper.run_as_root(self._mkext_arguments(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        if result.returncode != 0:
            subprocess_wrapper.log(result)
            return False

        return True

#prelinked
#prelinked.py
"""
prelinked.py: Prelinked Kernel cache management
"""

import logging
import subprocess

from pathlib import Path

from ..base.cache import BaseKernelCache
from ....support import subprocess_wrapper


class PrelinkedKernel(BaseKernelCache):

    def __init__(self, mount_location: str) -> None:
        self.mount_location = mount_location


    def _kextcache_arguments(self) -> list[str]:
        args = ["/usr/sbin/kextcache", "-invalidate", f"{self.mount_location}/"]
        return args

    def _update_preboot_kernel_cache(self) -> bool:
        """
        Ensure Preboot volume's kernel cache is updated
        """
        if not Path("/usr/sbin/kcditto").exists():
            return

        logging.info("- Syncing Kernel Cache to Preboot")
        subprocess_wrapper.run_as_root_and_verify(["/usr/sbin/kcditto"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def rebuild(self) -> None:
        logging.info("- Rebuilding Prelinked Kernel")
        result = subprocess_wrapper.run_as_root(self._kextcache_arguments(), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        # kextcache notes:
        # - kextcache always returns 0, even if it fails
        # - Check the output for 'KernelCache ID' to see if the cache was successfully rebuilt
        if "KernelCache ID" not in result.stdout.decode():
            subprocess_wrapper.log(result)
            return False

        self._update_preboot_kernel_cache()

        return True

#rebuild.py:
"""
rebuild.py: Manage kernel cache rebuilding regardless of macOS version
"""

from .base.cache import BaseKernelCache
from ...datasets import os_data


class RebuildKernelCache:
    """
    RebuildKernelCache: Rebuild the kernel cache

    Parameters:
    - os_version: macOS version
    - mount_location: Path to the mounted volume
    - auxiliary_cache: Whether to create auxiliary kernel cache (Big Sur and later)
    - auxiliary_cache_only: Whether to only create auxiliary kernel cache (Ventura and later)
    """
    def __init__(self, os_version: os_data.os_data, mount_location: str, auxiliary_cache: bool, auxiliary_cache_only: bool) -> None:
        self.os_version = os_version
        self.mount_location = mount_location
        self.auxiliary_cache = auxiliary_cache
        self.auxiliary_cache_only = auxiliary_cache_only


    def _rebuild_method(self) -> BaseKernelCache:
        """
        Determine the correct method to rebuild the kernel cache
        """
        if self.os_version >= os_data.os_data.big_sur:
            if self.os_version >= os_data.os_data.ventura:
                if self.auxiliary_cache_only:
                    from .kernel_collection.auxiliary import AuxiliaryKernelCollection
                    return AuxiliaryKernelCollection(self.mount_location)

            from .kernel_collection.boot_system import BootSystemKernelCollections
            return BootSystemKernelCollections(self.mount_location, self.os_version, self.auxiliary_cache)

        if os_data.os_data.catalina >= self.os_version >= os_data.os_data.lion:
            from .prelinked.prelinked import PrelinkedKernel
            return PrelinkedKernel(self.mount_location)

        from .mkext.mkext import MKext
        return MKext(self.mount_location)


    def rebuild(self) -> bool:
        """
        Rebuild the kernel cache
        """
        return self._rebuild_method().rebuild()

#mount
#__init__.py
"""
mount: Library for mounting and unmounting the root volume and interacting with APFS snapshots.

Usage:

>>> from mount import RootVolumeMount
>>> RootVolumeMount(xnu_major).mount()
'/System/Volumes/Update/mnt1'
>>> RootVolumeMount(xnu_major).unmount()

>>> RootVolumeMount(xnu_major).create_snapshot()
>>> RootVolumeMount(xnu_major).revert_snapshot()
"""

from .mount    import RootVolumeMount
from .snapshot import APFSSnapshot

#mount.py:
"""
mount.py: Handling macOS root volume mounting and unmounting
"""

import logging
import plistlib
import subprocess

from pathlib import Path

from .snapshot import APFSSnapshot

from ...datasets import os_data
from ...support  import subprocess_wrapper


class RootVolumeMount:

    def __init__(self, xnu_major: int) -> None:
        self.xnu_major = xnu_major
        self.root_volume_identifier = self._fetch_root_volume_identifier()

        self.mount_path = None


    def _fetch_root_volume_identifier(self) -> str:
        """
        Resolve path to disk identifier

        ex. / -> disk1s1
        """
        try:
            content = plistlib.loads(subprocess.run(["/usr/sbin/diskutil", "info", "-plist", "/"], capture_output=True).stdout)
        except plistlib.InvalidFileException:
            raise RuntimeError("Failed to parse diskutil output.")

        disk = content["DeviceIdentifier"]

        if "APFSSnapshot" in content and content["APFSSnapshot"] is True:
            # Remove snapshot suffix (last 2 characters)
            # ex. disk1s1s1 -> disk1s1
            disk = disk[:-2]

        return disk


    def _mount_root_volume(self) -> str:
        """
        Mount the root volume.

        Returns the path to the root volume.
        """
        # Root volume same as data volume
        if self.xnu_major < os_data.os_data.catalina.value:
            return "/"

        # Catalina implemented a read-only root volume
        if self.xnu_major == os_data.os_data.catalina.value:
            result = subprocess_wrapper.run_as_root(["/sbin/mount", "-uw", "/"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.error("Failed to mount root volume")
                subprocess_wrapper.log(result)
                return None
            return "/"

        # Big Sur and newer implemented APFS snapshots for the root volume
        if self.xnu_major >= os_data.os_data.big_sur.value:
            if Path("/System/Volumes/Update/mnt1/System/Library/CoreServices/SystemVersion.plist").exists():
                return "/System/Volumes/Update/mnt1"
            result = subprocess_wrapper.run_as_root(["/sbin/mount", "-o", "nobrowse", "-t", "apfs", f"/dev/{self.root_volume_identifier}", "/System/Volumes/Update/mnt1"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.error("Failed to mount root volume")
                subprocess_wrapper.log(result)
                return None
            return "/System/Volumes/Update/mnt1"

        return None


    def _unmount_root_volume(self, ignore_errors: bool = True) -> bool:
        """
        Unmount the root volume.
        """
        if self.xnu_major < os_data.os_data.catalina.value:
            return True

        args = ["/sbin/umount"]

        if self.xnu_major == os_data.os_data.catalina.value:
            args += ["-uw", self.mount_path]

        if self.xnu_major >= os_data.os_data.big_sur.value:
            args += [self.mount_path]

        result = subprocess_wrapper.run_as_root(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            if ignore_errors is False:
                logging.error("Failed to unmount root volume")
                subprocess_wrapper.log(result)
            return False

        return True


    def mount(self) -> str:
        """
        Mount the root volume.

        Returns the path to the root volume.

        If none, failed to mount.
        """
        result = self._mount_root_volume()
        if result is None:
            logging.error("Failed to mount root volume")
            return None
        if not Path(result).exists():
            logging.error(f"Attempted to mount root volume, but failed: {result}")
            return None

        self.mount_path = result

        return result


    def unmount(self, ignore_errors: bool = True) -> bool:
        """
        Unmount the root volume.

        Returns True if successful, False otherwise.

        Note for Big Sur and newer, a snapshot is created before unmounting.
        And that unmounting is not critical to the process.
        """
        return self._unmount_root_volume(ignore_errors=ignore_errors)


    def create_snapshot(self) -> bool:
        """
        Create APFS snapshot of the root volume.
        """
        return APFSSnapshot(self.xnu_major, self.mount_path).create_snapshot()


    def revert_snapshot(self) -> bool:
        """
        Revert APFS snapshot of the root volume.
        """
        return APFSSnapshot(self.xnu_major, self.mount_path).revert_snapshot()

#snapshot.py:
"""
snapshot.py: Handling APFS snapshots
"""

import logging
import platform
import subprocess

from ...datasets import os_data
from ...support  import subprocess_wrapper


class APFSSnapshot:

    def __init__(self, xnu_major: int, mount_path: str):
        self.xnu_major = xnu_major
        self.mount_path = mount_path


    def _rosetta_status(self) -> bool:
        """
        Check if currently running inside of Rosetta
        """
        result = subprocess_wrapper.run(["/usr/sbin/sysctl", "-n", "sysctl.proc_translated"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            return False

        return True if result.stdout.decode().strip() == "1" else False


    def create_snapshot(self) -> bool:
        """
        Create APFS snapshot of the root volume.
        """
        if self.xnu_major < os_data.os_data.big_sur.value:
            return True

        args = ["/usr/sbin/bless"]
        if platform.machine() == "arm64" or self._rosetta_status() is True:
            args += ["--mount", self.mount_path, "--create-snapshot"]
        else:
            args += ["--folder", f"{self.mount_path}/System/Library/CoreServices", "--bootefi", "--create-snapshot"]

        result = subprocess_wrapper.run_as_root(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.error("Failed to create APFS snapshot")
            subprocess_wrapper.log(result)
            if "Can't use last-sealed-snapshot or create-snapshot on non system volume" in result.stdout.decode():
                logging.info("- This is an APFS bug with Monterey and newer! Perform a clean installation to ensure your APFS volume is built correctly")

            return False

        return True


    def revert_snapshot(self) -> bool:
        """
        Revert APFS snapshot of the root volume.
        """
        if self.xnu_major < os_data.os_data.big_sur.value:
            return True

        result = subprocess_wrapper.run_as_root(["/usr/sbin/bless", "--mount", self.mount_path, "--bootefi", "--last-sealed-snapshot"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.error("Failed to revert APFS snapshot")
            subprocess_wrapper.log(result)
            return False

        return True

#patchsets
#__init__.py:
"""
patchsets module
"""

from .base   import PatchType, DynamicPatchset
from .detect import HardwarePatchsetDetection, HardwarePatchsetSettings, HardwarePatchsetValidation

#base.py:
"""
base.py: Base class for all patch sets
"""

from enum import StrEnum


class PatchType(StrEnum):
    """
    Type of patch
    """
    OVERWRITE_SYSTEM_VOLUME = "Overwrite System Volume"
    OVERWRITE_DATA_VOLUME   = "Overwrite Data Volume"
    MERGE_SYSTEM_VOLUME     = "Merge System Volume"
    MERGE_DATA_VOLUME       = "Merge Data Volume"
    REMOVE_SYSTEM_VOLUME    = "Remove System Volume"
    REMOVE_DATA_VOLUME      = "Remove Data Volume"
    EXECUTE                 = "Execute"


class DynamicPatchset(StrEnum):
    MetallibSupportPkg = "MetallibSupportPkg"


class BasePatchset:

    def __init__(self) -> None:
        # XNU Kernel versions
        self.macOS_12_0_B7: float = 21.1
        self.macOS_12_4:    float = 21.5
        self.macOS_12_5:    float = 21.6
        self.macOS_13_3:    float = 22.4
        self.macOS_14_1:    float = 23.1
        self.macOS_14_2:    float = 23.2
        self.macOS_14_4:    float = 23.4
        self.macOS_15_2:    float = 24.2
        self.macOS_15_3:    float = 24.3
        self.macOS_15_4:    float = 24.4
        self.macOS_15_5:    float = 24.5
        self.macOS_15_6:    float = 24.6
        self.macOS_15_7:    float = 24.7
        self.macOS_15_8:    float = 24.8
        self.macOS_15_9:    float = 24.9
        self.macOS_26_0:    float = 26.0
        self.macOS_26_1:    float = 26.1
        self.macOS_26_2:    float = 26.2
        self.macOS_26_3:    float = 26.3
        self.macOS_beta:    float = beta
        self.macOS_beta:    float = 26.0
        
#The above I added the items after 15.4 Iâm unsure if theyâre right if you can check please

#detect.py:
"""
detect.py: Detects patches for a given system
"""

import logging
import plistlib
import subprocess
import py_sip_xnu
import packaging.version

from enum      import StrEnum
from pathlib   import Path
from functools import cache

from .hardware.base import BaseHardware, HardwareVariantGraphicsSubclass

from .hardware.graphics import (
    intel_iron_lake,
    intel_sandy_bridge,
    intel_ivy_bridge,
    intel_haswell,
    intel_broadwell,
    intel_skylake,

    nvidia_tesla,
    nvidia_kepler,
    nvidia_webdriver,

    amd_terascale_1,
    amd_terascale_2,
    amd_legacy_gcn,
    amd_polaris,
    amd_vega,
)
from .hardware.networking import (
    legacy_wireless,
    modern_wireless,
)
from .hardware.misc import (
    display_backlight,
    gmux,
    keyboard_backlight,
    legacy_audio,
    pcie_webcam,
    t1_security,
    usb11,
    cpu_missing_avx,
)

from ... import constants

from ...datasets import sip_data
from ...datasets.os_data import os_data
from ...support import (
    network_handler,
    utilities,
    kdk_handler,
    metallib_handler
)
from ...detections import (
    amfi_detect,
    device_probe
)


class HardwarePatchsetSettings(StrEnum):
    """
    Enum for patch settings
    """
    KERNEL_DEBUG_KIT_REQUIRED     = "Settings: Kernel Debug Kit required"
    KERNEL_DEBUG_KIT_MISSING      = "Settings: Kernel Debug Kit missing"
    METALLIB_SUPPORT_PKG_REQUIRED = "Settings: MetallibSupportPkg.pkg required"
    METALLIB_SUPPORT_PKG_MISSING  = "Settings: MetallibSupportPkg.pkg missing"


class HardwarePatchsetValidation(StrEnum):
    """
    Enum for validation settings
    """
    UNSUPPORTED_HOST_OS           = "Validation: Unsupported Host OS"
    MISSING_NETWORK_CONNECTION    = "Validation: Missing Network Connection"
    FILEVAULT_ENABLED             = "Validation: FileVault is enabled"
    SIP_ENABLED                   = "Validation: System Integrity Protection is enabled"
    SECURE_BOOT_MODEL_ENABLED     = "Validation: SecureBootModel is enabled"
    AMFI_ENABLED                  = "Validation: AMFI is enabled"
    WHATEVERGREEN_MISSING         = "Validation: WhateverGreen.kext missing"
    FORCE_OPENGL_MISSING          = "Validation: Force OpenGL property missing"
    FORCE_COMPAT_MISSING          = "Validation: Force compat property missing"
    NVDA_DRV_MISSING              = "Validation: nvda_drv(_vrl) variable missing"
    PATCHING_NOT_POSSIBLE         = "Validation: Patching not possible"
    UNPATCHING_NOT_POSSIBLE       = "Validation: Unpatching not possible"


class HardwarePatchsetDetection:

    def __init__(self, constants: constants.Constants,
                 xnu_major: int = None, xnu_minor:  int = None,
                 os_build:  str = None, os_version: str = None,
                 validation: bool = False # Whether to run validation checks
                 ) -> None:
        self._constants = constants

        self._xnu_major  = xnu_major  or self._constants.detected_os
        self._xnu_minor  = xnu_minor  or self._constants.detected_os_minor
        self._os_build   = os_build   or self._constants.detected_os_build
        self._os_version = os_version or self._constants.detected_os_version
        self._validation = validation

        self._hardware_variants = [
            intel_iron_lake.IntelIronLake,
            intel_sandy_bridge.IntelSandyBridge,
            intel_ivy_bridge.IntelIvyBridge,
            intel_haswell.IntelHaswell,
            intel_broadwell.IntelBroadwell,
            intel_skylake.IntelSkylake,

            nvidia_tesla.NvidiaTesla,
            nvidia_kepler.NvidiaKepler,
            nvidia_webdriver.NvidiaWebDriver,

            amd_terascale_1.AMDTeraScale1,
            amd_terascale_2.AMDTeraScale2,
            amd_legacy_gcn.AMDLegacyGCN,
            amd_polaris.AMDPolaris,
            amd_vega.AMDVega,

            legacy_wireless.LegacyWireless,
            modern_wireless.ModernWireless,

            display_backlight.DisplayBacklight,
            gmux.GraphicsMultiplexer,
            keyboard_backlight.KeyboardBacklight,
            legacy_audio.LegacyAudio,
            pcie_webcam.PCIeFaceTimeCamera,
            t1_security.T1SecurityChip,
            usb11.USB11Controller,
            cpu_missing_avx.CPUMissingAVX,
        ]

        self.device_properties = None
        self.patches           = None

        self.can_patch         = False
        self.can_unpatch       = False

        self._detect()


    def _validation_check_unsupported_host_os(self) -> bool:
        """
        Determine if host OS is unsupported
        """
        _min_os = os_data.big_sur.value
        _max_os = os_data.sequoia.value
        if self._dortania_internal_check() is True:
            return False
        if self._xnu_major < _min_os or self._xnu_major > _max_os:
            return True
        return False


    @cache
    def _validation_check_missing_network_connection(self) -> bool:
        """
        Determine if network connection is present
        """
        return network_handler.NetworkUtilities().verify_network_connection() is False


    @cache
    def _validation_check_filevault_is_enabled(self) -> bool:
        """
        Determine if FileVault is enabled
        """
        # macOS 11.0 introduced a FileVault check for root patching
        if self._xnu_major < os_data.big_sur.value:
            return False

        # OpenCore Legacy Patcher exposes whether it patched APFS.kext to allow for FileVault
        nvram = utilities.get_nvram("OCLP-Settings", "4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102", decode=True)
        if nvram:
            if "-allow_fv" in nvram:
                return False

        return "FileVault is Off" not in subprocess.run(["/usr/bin/fdesetup", "status"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode()


    def _validation_check_system_integrity_protection_enabled(self, configs: list[str]) -> bool:
        """
        Determine if System Integrity Protection is enabled
        """
        return utilities.csr_decode(configs)


    def _validation_check_secure_boot_model_enabled(self) -> bool:
        """
        Determine if SecureBootModel is enabled
        """
        return utilities.check_secure_boot_level()


    def _validation_check_amfi_enabled(self, level: amfi_detect.AmfiConfigDetectLevel) -> bool:
        """
        Determine if AMFI is enabled
        """
        return not amfi_detect.AmfiConfigurationDetection().check_config(self._override_amfi_level(level))


    def _validation_check_whatevergreen_missing(self) -> bool:
        """
        Determine if WhateverGreen.kext is missing
        """
        return utilities.check_kext_loaded("as.vit9696.WhateverGreen") is False


    @cache
    def _validation_check_force_opengl_missing(self) -> bool:
        """
        Determine if Force OpenGL property is missing
        """
        nv_on = utilities.get_nvram("boot-args", decode=True)
        if nv_on:
            if "ngfxgl=" in nv_on:
                return False
        for gpu in self._constants.computer.gpus:
            if isinstance(gpu, device_probe.NVIDIA):
                if gpu.disable_metal is True:
                    return False
        return True


    def _validation_check_force_compat_missing(self) -> bool:
        """
        Determine if Force compat property is missing
        """
        nv_on = utilities.get_nvram("boot-args", decode=True)
        if nv_on:
            if "ngfxcompat=" in nv_on:
                return False
        for gpu in self._constants.computer.gpus:
            if isinstance(gpu, device_probe.NVIDIA):
                if gpu.force_compatible is True:
                    return False
        return True


    def _validation_check_nvda_drv_missing(self) -> bool:
        """
        Determine if nvda_drv(_vrl) variable is missing
        """
        nv_on = utilities.get_nvram("boot-args", decode=True)
        if nv_on:
            if "nvda_drv_vrl=" in nv_on:
                return False
        nv_on = utilities.get_nvram("nvda_drv")
        if nv_on:
            return False
        return True


    @cache
    def _override_amfi_level(self, level: amfi_detect.AmfiConfigDetectLevel) -> amfi_detect.AmfiConfigDetectLevel:
        """
        Override level required based on whether AMFIPass is loaded
        """
        amfipass_version = utilities.check_kext_loaded("com.dhinakg.AMFIPass")
        if amfipass_version:
            if packaging.version.parse(amfipass_version) >= packaging.version.parse(self._constants.amfipass_compatibility_version):
                # If AMFIPass is loaded, our binaries will work
                return amfi_detect.AmfiConfigDetectLevel.NO_CHECK
        return level


    def _dortania_internal_check(self) -> None:
        """
        Determine whether to unlock Dortania Developer mode
        """
        return Path("~/.dortania_developer").expanduser().exists()


    def _already_has_networking_patches(self) -> bool:
        """
        Check if network patches are already applied
        """
        oclp_patch_path = "/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist"
        if not Path(oclp_patch_path).exists():
            return False
        try:
            oclp_plist = plistlib.load(open(oclp_patch_path, "rb"))
        except Exception as e:
            return False
        if "Legacy Wireless" in oclp_plist or "Modern Wireless" in oclp_plist:
            return True
        return False


    def _is_cached_kernel_debug_kit_present(self) -> bool:
        """
        Check if Kernel Debug Kit is present
        """
        return kdk_handler.KernelDebugKitObject(self._constants, self._os_build, self._os_version, passive=True).kdk_already_installed


    def _is_cached_metallib_support_pkg_present(self) -> bool:
        """
        Check if MetallibSupportPkg is present
        """
        return metallib_handler.MetalLibraryObject(self._constants, self._os_build, self._os_version).metallib_already_installed


    def _can_patch(self, requirements: dict, ignore_keys: list[str] = []) -> bool:
        """
        Check if patching is possible
        """
        for key, value in requirements.items():
            if key in ignore_keys:
                continue
            if not key.startswith("Validation:"):
                continue
            if value is True:
                return False
        return True


    def _convert_required_sip_config_to_int(self, configs: list[str]) -> int:
        """
        Convert required SIP configurations to integer
        """
        value = 0
        for config in configs:
            if config in sip_data.system_integrity_protection.csr_values_extended:
                value += sip_data.system_integrity_protection.csr_values_extended[config]["value"]

        return value


    def _strip_incompatible_hardware(self, present_hardware: list[BaseHardware]) -> list[BaseHardware]:
        """
        Strip out incompatible hardware. Priority is given to Metal GPUs (specifically 31001 when applicable)

        Notes:
        - Non-Metal GPUs are stripped out if any Metal GPUs are present
        - Metal 3802 GPUs are stripped out if Metal 31001 GPUs are present on macOS Sequoia or newer
          - Exception is made for "Graphics: AMD Legacy GCN" on Sequoia or newer
          - Special handling is done in amd_legacy_gcn.py
        """
        non_metal_gpu_present   = False
        metal_gpu_present       = False
        metal_3802_gpu_present  = False
        metal_31001_gpu_present = False
        metal_31001_name        = None

        for hardware in present_hardware:
            hardware: BaseHardware
            sub_variant = hardware.hardware_variant_graphics_subclass()
            if sub_variant == HardwareVariantGraphicsSubclass.METAL_31001_GRAPHICS:
                metal_31001_gpu_present = True
                metal_31001_name = hardware.name()
            elif sub_variant == HardwareVariantGraphicsSubclass.METAL_3802_GRAPHICS:
                metal_3802_gpu_present = True
            elif sub_variant == HardwareVariantGraphicsSubclass.NON_METAL_GRAPHICS:
                non_metal_gpu_present = True

        metal_gpu_present = metal_31001_gpu_present or metal_3802_gpu_present

        if metal_gpu_present and non_metal_gpu_present:
            logging.error("Cannot mix Metal and Non-Metal GPUs")
            logging.error("Stripping out Non-Metal GPUs")
            for hardware in list(present_hardware):
                if hardware.hardware_variant_graphics_subclass() == HardwareVariantGraphicsSubclass.NON_METAL_GRAPHICS:
                    logging.info(f"  Stripping out {hardware.name()}")
                    present_hardware.remove(hardware)

        if metal_3802_gpu_present and metal_31001_gpu_present and self._xnu_major >= os_data.sequoia.value:
            if metal_31001_name != "Graphics: AMD Legacy GCN":
                logging.error("Cannot mix Metal 3802 and Metal 31001 GPUs on macOS Sequoia or newer")
                logging.error("Stripping out Metal 3802 GPUs")
                for hardware in list(present_hardware):
                    if hardware.hardware_variant_graphics_subclass() == HardwareVariantGraphicsSubclass.METAL_3802_GRAPHICS:
                        logging.error(f"  Stripping out {hardware.name()}")
                        present_hardware.remove(hardware)

        return present_hardware


    def _handle_missing_network_connection(self, requirements: dict, device_properties: dict) -> tuple[dict, dict]:
        """
        Sync network connection requirements
        """
        if self._can_patch(requirements, ignore_keys=[HardwarePatchsetValidation.MISSING_NETWORK_CONNECTION]) is False:
            return requirements, device_properties
        logging.info("Network connection missing, checking whether network patches are applicable")
        if self._already_has_networking_patches() is True:
            logging.info("Network patches are already applied, requiring network connection")
            return requirements, device_properties

        if not any([key.startswith("Networking:") for key in device_properties.keys()]):
            logging.info("Network patches are not applicable, requiring network connection")
            return requirements, device_properties

        logging.info("Network patches are applicable, removing other patches")
        for key in list(device_properties.keys()):
            if key.startswith("Networking:"):
                continue
            device_properties.pop(key, None)

        requirements[HardwarePatchsetValidation.MISSING_NETWORK_CONNECTION]  = False
        requirements[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED]     = False
        requirements[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_MISSING]      = False
        requirements[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED] = False
        requirements[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_MISSING]  = False

        return requirements, device_properties


    def _handle_sip_breakdown(self, requirements: dict, required_sip_configs: list[str]) -> dict:
        """
        Handle SIP breakdown
        """
        current_sip_status  = hex(py_sip_xnu.SipXnu().get_sip_status().value)
        expected_sip_status = hex(self._convert_required_sip_config_to_int(required_sip_configs))
        sip_string = f"Validation: Booted SIP: {current_sip_status} vs expected: {expected_sip_status}"
        index = list(requirements.keys()).index(HardwarePatchsetValidation.SIP_ENABLED)
        return dict(list(requirements.items())[:index+1] + [(sip_string, True)] + list(requirements.items())[index+1:])


    def _detect(self) -> None:
        """
        Detect patches for a given system
        """
        present_hardware  = []
        device_properties = {}
        patches           = {}

        requires_metallib_support_pkg = False
        missing_metallib_support_pkg  = False
        requires_kernel_debug_kit     = False
        missing_kernel_debug_kit      = False
        requires_network_connection   = False
        has_nvidia_web_drivers        = False
        highest_amfi_level            = amfi_detect.AmfiConfigDetectLevel.NO_CHECK
        required_sip_configs          = []

        # First pass to find all present hardware
        for hardware in self._hardware_variants:
            item: BaseHardware = hardware(
                xnu_major        = self._xnu_major,
                xnu_minor        = self._xnu_minor,
                os_build         = self._os_build,
                global_constants = self._constants
            )
            # During validation, don't skip missing items
            # This is to ensure we can validate all files
            if self._validation is False:
                if item.present() is False:  # Skip if not present
                    continue
                if item.native_os() is True: # Skip if native OS
                    continue
            present_hardware.append(item)

        if self._validation is False:
            present_hardware = self._strip_incompatible_hardware(present_hardware)

        # Second pass to determine requirements
        for item in present_hardware:
            item: BaseHardware
            device_properties[item.name()] = True

            if item.name() == "Graphics: Nvidia Web Drivers":
                has_nvidia_web_drivers = True

            for config in item.required_system_integrity_protection_configurations():
                if config not in required_sip_configs:
                    required_sip_configs.append(config)

            if item.requires_metallib_support_pkg() is True:
                requires_metallib_support_pkg = True
            if item.requires_kernel_debug_kit() is True:
                requires_kernel_debug_kit = True
            if item.required_amfi_level() > highest_amfi_level:
                highest_amfi_level = item.required_amfi_level()

        if self._validation is False:
            if requires_metallib_support_pkg is True:
                missing_metallib_support_pkg = not self._is_cached_metallib_support_pkg_present()
            if requires_kernel_debug_kit is True:
                missing_kernel_debug_kit = not self._is_cached_kernel_debug_kit_present()

        requires_network_connection = missing_metallib_support_pkg or missing_kernel_debug_kit

        requirements = {
            HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED:     requires_kernel_debug_kit,
            HardwarePatchsetSettings.KERNEL_DEBUG_KIT_MISSING:      missing_kernel_debug_kit,
            HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED: requires_metallib_support_pkg,
            HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_MISSING:  missing_metallib_support_pkg,

            HardwarePatchsetValidation.UNSUPPORTED_HOST_OS:         self._validation_check_unsupported_host_os(),
            HardwarePatchsetValidation.MISSING_NETWORK_CONNECTION:  self._validation_check_missing_network_connection() if requires_network_connection else False,
            HardwarePatchsetValidation.FILEVAULT_ENABLED:           self._validation_check_filevault_is_enabled(),
            HardwarePatchsetValidation.SIP_ENABLED:                 self._validation_check_system_integrity_protection_enabled(required_sip_configs),
            HardwarePatchsetValidation.SECURE_BOOT_MODEL_ENABLED:   self._validation_check_secure_boot_model_enabled(),
            HardwarePatchsetValidation.AMFI_ENABLED:                self._validation_check_amfi_enabled(highest_amfi_level),
            HardwarePatchsetValidation.WHATEVERGREEN_MISSING:       self._validation_check_whatevergreen_missing() if has_nvidia_web_drivers is True else False,
            HardwarePatchsetValidation.FORCE_OPENGL_MISSING:        self._validation_check_force_opengl_missing()  if has_nvidia_web_drivers is True else False,
            HardwarePatchsetValidation.FORCE_COMPAT_MISSING:        self._validation_check_force_compat_missing()  if has_nvidia_web_drivers is True else False,
            HardwarePatchsetValidation.NVDA_DRV_MISSING:            self._validation_check_nvda_drv_missing()      if has_nvidia_web_drivers is True else False,
        }

        _cant_patch   = False
        _cant_unpatch = requirements[HardwarePatchsetValidation.SIP_ENABLED]

        if self._validation is False:
            if requirements[HardwarePatchsetValidation.SIP_ENABLED] is True:
                requirements = self._handle_sip_breakdown(requirements, required_sip_configs)
            if requirements[HardwarePatchsetValidation.MISSING_NETWORK_CONNECTION] is True:
                requirements, device_properties = self._handle_missing_network_connection(requirements, device_properties)

        # Third pass to sync stripped hardware (ie. '_handle_missing_network_connection()')
        for item in present_hardware:
            item: BaseHardware
            if item.name() not in device_properties:
                continue
            patches.update(item.patches())

        _cant_patch = not self._can_patch(requirements)

        requirements[HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE]   = _cant_patch
        requirements[HardwarePatchsetValidation.UNPATCHING_NOT_POSSIBLE] = _cant_unpatch

        self.can_patch   = not _cant_patch
        self.can_unpatch = not _cant_unpatch

        device_properties.update(requirements)

        self.device_properties = device_properties
        self.patches           = patches


    def detailed_errors(self) -> None:
        """
        Print out detailed errors
        """
        logging.error("- Breakdown:")
        for key, value in self.device_properties.items():
            if not key.startswith("Validation:"):
                continue
            if key in [HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE, HardwarePatchsetValidation.UNPATCHING_NOT_POSSIBLE]:
                continue
            if value is False:
                continue
            logging.error(f"  - {key.replace('Validation: ', '')}")

#hardware
#base.py:
"""
base.py: Base class for hardware patch set detection
"""

from enum    import StrEnum
from pathlib import Path

from ..base import BasePatchset

from ....constants import Constants

from ....datasets.os_data       import os_data
from ....datasets.sip_data      import system_integrity_protection
from ....detections.amfi_detect import AmfiConfigDetectLevel
from ....detections             import device_probe


class HardwareVariant(StrEnum):
    """
    Hardware variant for patch set
    """
    GRAPHICS:      str = "Graphics"
    NETWORKING:    str = "Networking"
    AUDIO:         str = "Audio"
    MISCELLANEOUS: str = "Miscellaneous"


class HardwareVariantGraphicsSubclass(StrEnum):
    """
    Graphics hardware variant subclass
    """
    NON_METAL_GRAPHICS:   str = "Non-Metal Graphics"
    METAL_3802_GRAPHICS:  str = "Metal 3802 Graphics"
    METAL_31001_GRAPHICS: str = "Metal 31001 Graphics"
    HEADLESS_GRAPHICS:    str = "Headless Graphics"
    NOT_APPLICABLE:       str = "N/A"


class BaseHardware(BasePatchset):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__()
        self._xnu_major = xnu_major
        self._xnu_minor = xnu_minor
        self._os_build  = os_build
        self._constants = global_constants
        self._computer  = global_constants.computer

        self._xnu_float = float(f"{self._xnu_major}.{self._xnu_minor}")


    def name(self) -> str:
        """
        Name of the patch set
        """
        raise NotImplementedError


    def present(self) -> bool:
        """
        Whether the hardware is present in the system
        """
        raise NotImplementedError


    def native_os(self) -> bool:
        """
        Is on native OS
        """
        raise NotImplementedError


    def hardware_variant(self) -> HardwareVariant:
        """
        What hardware variant is this patch set for
        """
        raise NotImplementedError


    def hardware_variant_graphics_subclass(self) -> HardwareVariantGraphicsSubclass:
        """
        What subclass of graphics
        """
        return HardwareVariantGraphicsSubclass.NOT_APPLICABLE


    def required_amfi_level(self) -> AmfiConfigDetectLevel:
        """
        What level of AMFI configuration is required for this patch set
        Currently defaulted to AMFI needing to be disabled
        """
        return AmfiConfigDetectLevel.ALLOW_ALL


    def requires_primary_kernel_cache(self) -> bool:
        """
        Whether patch set requires access to the primary kernel cache
        ex. Boot/System Kernel Collection on Big Sur and newer
        """
        return False


    def requires_kernel_debug_kit(self) -> bool:
        """
        Whether patch set requires access to the Kernel Debug Kit
        """
        return False


    def requires_metallib_support_pkg(self) -> bool:
        """
        Whether patch set requires access to the MetallibSupportPkg PKG
        """
        return False


    def required_system_integrity_protection_configurations(self) -> list[str]:
        """
        List of required SIP configurations for the patch set
        """
        if self._xnu_major >= os_data.ventura.value:
            return system_integrity_protection.root_patch_sip_ventura
        if self._xnu_major >= os_data.big_sur.value:
            return system_integrity_protection.root_patch_sip_big_sur
        return system_integrity_protection.root_patch_sip_mojave


    def patches(self) -> dict:
        """
        Dictionary of patches
        """
        raise NotImplementedError


    def _is_gpu_architecture_present(self, gpu_architectures: list[device_probe.GPU]) -> bool:
        """
        Check if a GPU architecture is present
        """
        for gpu in self._computer.gpus:
            if not gpu.class_code:
                continue
            if not gpu.arch:
                continue
            if gpu.class_code == 0xFFFFFFFF:
                continue

            if gpu.arch in gpu_architectures:
                return True

        return False


    def _resolve_monterey_framebuffers(self) -> str:
        """
        Resolve patchset directory for framebuffers last supported in Monterey:
        - AppleIntelBDWGraphics.kext
        - AppleIntelBDWGraphicsFramebuffer.kext
        - AppleIntelFramebufferAzul.kext
        - AppleIntelHD5000Graphics.kext
        - AppleIntelSKLGraphics.kext
        - AppleIntelSKLGraphicsFramebuffer.kext
        - AMDRadeonX4000.kext
        - AMDRadeonX5000.kext
        """
        if self._xnu_major < os_data.sonoma.value:
            return "12.5"
        if self._xnu_float < self.macOS_14_4:
            return "12.5-23"
        return "12.5-23.4"


    def _dortania_internal_check(self) -> None:
        """
        Determine whether to unlock Dortania Developer mode
        """
        return Path("~/.dortania_developer").expanduser().exists()


#graphics
#intel_skylake,py:
"""
intel_skylake.py: Intel Skylake detection
"""

from ..base import BaseHardware, HardwareVariant, HardwareVariantGraphicsSubclass

from ...base import PatchType

from ...shared_patches.monterey_opencl import MontereyOpenCL

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class IntelSkylake(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Intel Skylake"


    def present(self) -> bool:
        """
        Targeting Intel Skylake GPUs
        """
        return self._is_gpu_architecture_present(
            gpu_architectures=[
                device_probe.Intel.Archs.Skylake
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 13, Ventura
        """
        return self._xnu_major < os_data.ventura.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.GRAPHICS


    def hardware_variant_graphics_subclass(self) -> HardwareVariantGraphicsSubclass:
        """
        Type of hardware variant subclass
        """
        return HardwareVariantGraphicsSubclass.METAL_31001_GRAPHICS


    def _model_specific_patches(self) -> dict:
        """
        Model specific patches
        """
        return {
            "Intel Skylake": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "AppleIntelSKLGraphics.kext":            self._resolve_monterey_framebuffers(),
                        "AppleIntelSKLGraphicsFramebuffer.kext": self._resolve_monterey_framebuffers(),
                        "AppleIntelSKLGraphicsGLDriver.bundle":  "12.5",
                        "AppleIntelSKLGraphicsMTLDriver.bundle": "12.5" if self._xnu_major < os_data.sequoia else "12.5-24",
                        "AppleIntelSKLGraphicsVADriver.bundle":  "12.5",
                        "AppleIntelSKLGraphicsVAME.bundle":      "12.5",
                        "AppleIntelGraphicsShared.bundle":       "12.5",
                    },
                },
            },
        }


    def patches(self) -> dict:
        """
        Patches for Intel Skylake iGPUs
        """
        if self.native_os() is True:
            return {}

        return {
            **MontereyOpenCL(self._xnu_major, self._xnu_minor, self._constants.detected_os_version).patches(),
            **self._model_specific_patches(),
        }

#nvidia_kepler.py:
"""
nvidia_kepler.py: Nvidia Kepler detection
"""

from ..base import BaseHardware, HardwareVariant, HardwareVariantGraphicsSubclass

from ...base import PatchType

from ...shared_patches.metal_3802      import LegacyMetal3802
from ...shared_patches.monterey_opencl import MontereyOpenCL
from ...shared_patches.big_sur_opencl  import BigSurOpenCL
from ...shared_patches.monterey_webkit import MontereyWebKit

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class NvidiaKepler(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Nvidia Kepler"


    def present(self) -> bool:
        """
        Targeting Nvidia Kepler GPUs
        """
        return self._is_gpu_architecture_present(
            gpu_architectures=[
                device_probe.NVIDIA.Archs.Kepler
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 12.0 Beta 7, Monterey
        """
        if self._xnu_major < os_data.monterey:
            return True

        if self._xnu_major == os_data.monterey:
            if self._xnu_minor <= 0:             # 12.0 Beta 8 increased XNU minor
                if self._os_build != "21A5522h": # 12.0 Beta 7
                    return True

        return False


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.GRAPHICS


    def hardware_variant_graphics_subclass(self) -> HardwareVariantGraphicsSubclass:
        """
        Type of hardware variant subclass
        """
        return HardwareVariantGraphicsSubclass.METAL_3802_GRAPHICS


    def requires_metallib_support_pkg(self) -> bool:
        """
        New compiler format introduced in macOS 15, Sequoia
        """
        return self._xnu_major >= os_data.sequoia.value


    def _resolve_kepler_geforce_framebuffers(self) -> str:
        """
        Resolve patchset directory for GeForce.kext
        """
        if self._xnu_major < os_data.sonoma:
            return "12.0 Beta 6"
        if self._xnu_float < self.macOS_14_4:
            return "12.0 Beta 6-23"
        return "12.0 Beta 6-23.4"


    def _model_specific_patches(self) -> dict:
        """
        Model specific patches
        """
        return {
            "Nvidia Kepler": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "GeForce.kext":            self._resolve_kepler_geforce_framebuffers(),
                        "NVDAGF100Hal.kext":       "12.0 Beta 6",
                        "NVDAGK100Hal.kext":       "12.0 Beta 6",
                        "NVDAResman.kext":         "12.0 Beta 6",
                        "NVDAStartup.kext":        "12.0 Beta 6",
                        "GeForceAIRPlugin.bundle": "11.0 Beta 3",
                        "GeForceGLDriver.bundle":  "11.0 Beta 3",
                        "GeForceMTLDriver.bundle": "11.0 Beta 3" if self._xnu_major <= os_data.monterey else f"11.0 Beta 3-22",
                        "GeForceVADriver.bundle":  "12.0 Beta 6",
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        # XNU 21.6 (macOS 12.5)
                        **({ "Metal.framework": "12.5 Beta 2"} if (self._xnu_float >= self.macOS_12_5 and self._xnu_major < os_data.ventura) else {}),
                    },
                    "/System/Library/PrivateFrameworks": {
                        "GPUCompiler.framework": "11.6",
                    },
                }
            },
        }


    def patches(self) -> dict:
        """
        Patches for Nvidia Kepler GPUs
        """
        if self.native_os() is True:
            return {}

        return {
            **LegacyMetal3802(self._xnu_major, self._xnu_minor, self._constants.detected_os_version).patches(),
            **MontereyOpenCL(self._xnu_major, self._xnu_minor, self._constants.detected_os_version).patches(),
            **BigSurOpenCL(self._xnu_major, self._xnu_minor, self._constants.detected_os_version).patches(),
            **MontereyWebKit(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **self._model_specific_patches(),
        }


#nvidia_tesla.py:
"""
nvidia_tesla.py: Nvidia Tesla detection
"""

from ..base import BaseHardware, HardwareVariant, HardwareVariantGraphicsSubclass

from ...base import PatchType

from ...shared_patches.non_metal       import NonMetal
from ...shared_patches.monterey_webkit import MontereyWebKit

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class NvidiaTesla(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Nvidia Tesla"


    def present(self) -> bool:
        """
        Targeting Nvidia Tesla GPUs
        """
        return self._is_gpu_architecture_present(
            gpu_architectures=[
                device_probe.NVIDIA.Archs.Tesla
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major < os_data.mojave.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.GRAPHICS


    def hardware_variant_graphics_subclass(self) -> HardwareVariantGraphicsSubclass:
        """
        Type of hardware variant subclass
        """
        return HardwareVariantGraphicsSubclass.NON_METAL_GRAPHICS


    def requires_kernel_debug_kit(self) -> bool:
        """
        Apple no longer provides standalone kexts in the base OS
        """
        return self._xnu_major >= os_data.ventura.value


    def _model_specific_patches(self) -> dict:
        """
        Model specific patches
        """
        return {
            "Nvidia Tesla": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "GeForceGA.bundle":            "10.13.6",
                        "GeForceTesla.kext":           "10.13.6",
                        "GeForceTeslaGLDriver.bundle": "10.13.6",
                        "GeForceTeslaVADriver.bundle": "10.13.6",
                        "NVDANV50HalTesla.kext":       "10.13.6",
                        "NVDAResmanTesla.kext":        "10.13.6",
                        # Apple dropped NVDAStartup in 12.0 Beta 7 (XNU 21.1)
                        **({ "NVDAStartup.kext":       "12.0 Beta 6" } if self._xnu_float >= self.macOS_12_0_B7 else {})
                    },
                },
            },
        }


    def patches(self) -> dict:
        """
        Patches for Nvidia Tesla GPUs
        """
        if self.native_os() is True:
            return {}

        if self._xnu_major not in self._constants.legacy_accel_support and self._dortania_internal_check() is False:
            return {**self._model_specific_patches()}

        return {
            **NonMetal(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **MontereyWebKit(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **self._model_specific_patches(),
        }

#nvidia_webdriver.py:
"""
nvidia_webdriver.py: Nvidia Web Driver detection
"""

from ..base import BaseHardware, HardwareVariant, HardwareVariantGraphicsSubclass

from ...base import PatchType

from ...shared_patches.non_metal             import NonMetal
from ...shared_patches.monterey_webkit       import MontereyWebKit
from ...shared_patches.non_metal_ioaccel     import NonMetalIOAccelerator
from ...shared_patches.non_metal_coredisplay import NonMetalCoreDisplay
from ...shared_patches.non_metal_enforcement import NonMetalEnforcement

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data  import os_data
from .....datasets.sip_data import system_integrity_protection


class NvidiaWebDriver(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Nvidia Web Drivers"


    def present(self) -> bool:
        """
        Targeting Nvidia Fermi, Maxwell, Pascal GPUs
        """
        return self._is_gpu_architecture_present(
            gpu_architectures=[
                device_probe.NVIDIA.Archs.Fermi,
                device_probe.NVIDIA.Archs.Maxwell,
                device_probe.NVIDIA.Archs.Pascal,
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major < os_data.mojave.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.GRAPHICS


    def hardware_variant_graphics_subclass(self) -> HardwareVariantGraphicsSubclass:
        """
        Type of hardware variant subclass
        """
        return HardwareVariantGraphicsSubclass.NON_METAL_GRAPHICS


    def requires_kernel_debug_kit(self) -> bool:
        """
        Apple no longer provides standalone kexts in the base OS
        """
        return self._xnu_major >= os_data.ventura.value


    def required_system_integrity_protection_configurations(self) -> list[str]:
        """
        List of required SIP configurations for the patch set
        """
        return system_integrity_protection.root_patch_sip_big_sur_3rd_part_kexts


    def _model_specific_patches(self) -> dict:
        """
        Model specific patches
        """
        return {
            "Nvidia Web Drivers": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "GeForceAIRPluginWeb.bundle":     "WebDriver-387.10.10.10.40.140",
                        "GeForceGLDriverWeb.bundle":      "WebDriver-387.10.10.10.40.140",
                        "GeForceMTLDriverWeb.bundle":     "WebDriver-387.10.10.10.40.140",
                        "GeForceVADriverWeb.bundle":      "WebDriver-387.10.10.10.40.140",

                        # Tesla-only files
                        "GeForceTeslaGAWeb.bundle":       "WebDriver-387.10.10.10.40.140",
                        "GeForceTeslaGLDriverWeb.bundle": "WebDriver-387.10.10.10.40.140",
                        "GeForceTeslaVADriverWeb.bundle": "WebDriver-387.10.10.10.40.140",
                    },
                },
                PatchType.OVERWRITE_DATA_VOLUME: {
                    "/Library/Extensions": {
                        "GeForceWeb.kext":                "WebDriver-387.10.10.10.40.140",
                        "NVDAGF100HalWeb.kext":           "WebDriver-387.10.10.10.40.140",
                        "NVDAGK100HalWeb.kext":           "WebDriver-387.10.10.10.40.140",
                        "NVDAGM100HalWeb.kext":           "WebDriver-387.10.10.10.40.140",
                        "NVDAGP100HalWeb.kext":           "WebDriver-387.10.10.10.40.140",
                        "NVDAResmanWeb.kext":             "WebDriver-387.10.10.10.40.140",
                        "NVDAStartupWeb.kext":            "WebDriver-387.10.10.10.40.140",

                        # Tesla-only files
                        "GeForceTeslaWeb.kext":           "WebDriver-387.10.10.10.40.140",
                        "NVDANV50HalTeslaWeb.kext":       "WebDriver-387.10.10.10.40.140",
                        "NVDAResmanTeslaWeb.kext":        "WebDriver-387.10.10.10.40.140",
                    },

                    # Disabled due to issues with Pref pane stripping 'nvda_drv' NVRAM
                    # variables
                    # "/Library/PreferencePanes": {
                    #     "NVIDIA Driver Manager.prefPane": "WebDriver-387.10.10.10.40.140",
                    # },
                    #  "/Library/LaunchAgents": {
                    #     "com.nvidia.nvagent.plist":       "WebDriver-387.10.10.10.40.140",
                    # },
                    # "/Library/LaunchDaemons": {
                    #     "com.nvidia.nvroothelper.plist":  "WebDriver-387.10.10.10.40.140",
                    # },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        # Restore OpenCL by adding missing compiler files
                        **({ "GPUCompiler.framework": "11.6"} if self._xnu_major >= os_data.monterey else {}),
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        # Due to how late the Auxiliary cache loads, NVDAStartup will match first and then the Web Driver kexts.
                        # This has no effect for Maxwell and Pascal, however for development purposes, Tesla and Kepler are partially supported.
                        "NVDAStartup.kext",
                    ],
                },
            },
        }


    def patches(self) -> dict:
        """
        Patches for Nvidia Web Drivers
        """
        if self.native_os() is True:
            return {}

        if self._xnu_major not in self._constants.legacy_accel_support and self._dortania_internal_check() is False:
            return {**self._model_specific_patches()}

        return {
            **NonMetal(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **NonMetalIOAccelerator(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **NonMetalCoreDisplay(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **MontereyWebKit(self._xnu_major, self._xnu_minor, self._os_build).patches(),
            **self._model_specific_patches(),
            **NonMetalEnforcement(self._xnu_major, self._xnu_minor, self._os_build).patches(),
        }

#misc
#cpu_missing_avx:
"""
cpu_missing_avx.py: Legacy CPUs (Lacking AVX) Detection

Note that this system is implemented only for macOS Ventura and
machines not using the legacy/modern wireless patches (AVX patch integrated into WiFi patches).

This commit implemented unconditional AVX usage, thus Safari 18.2 and later will crash:
https://github.com/WebKit/WebKit/commit/c15e741266db8ff9df309ce9971eda1cfd9021cc
"""

from ..base import BaseHardware, HardwareVariant

from ..networking.legacy_wireless import LegacyWireless
from ..networking.modern_wireless import ModernWireless

from ...base import PatchType

from .....constants  import Constants

from .....datasets.os_data import os_data


class CPUMissingAVX(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy CPUs (Lacking AVX)"


    def present(self) -> bool:
        """
        Targeting CPUs without AVX support
        """
        if self._constants.computer.rosetta_active is True:
            return False
        if "AVX1.0" in self._constants.computer.cpu.flags:
            return False

        return True


    def native_os(self) -> bool:
        """
        Only install this patch on macOS Ventura.
        This is because we integrated the patch into the WiFi patches which all Macs use in Sonoma+.
        """
        if self._xnu_major != os_data.ventura.value:
            return True

        if LegacyWireless(self._xnu_major, self._xnu_minor, self._os_build, self._constants).present() is True:
            return True
        if ModernWireless(self._xnu_major, self._xnu_minor, self._os_build, self._constants).present() is True:
            return True

        return False


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def patches(self) -> dict:
        """
        Patches for Legacy CPUs (Lacking AVX)
        """
        if self.native_os() is True:
            return {}

        return {
            "CPU Missing AVX": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        "IO80211.framework": "13.7.2-22",
                    },
                }
            },
        }

#display_backlight.py:
"""
display_backlight.py: Legacy Backlight Control detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants  import Constants

from .....datasets.os_data import os_data


class DisplayBacklight(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy Backlight Control"


    def present(self) -> bool:
        """
        Targeting Legacy Backlight Controllers
        """
        return self._computer.real_model in [
            "MacBook5,2",
            "iMac7,1",
            "iMac8,1",
            "iMac9,1",
        ]


    def native_os(self) -> bool:
        """
        Dropped support with macOS 10.13, High Sierra
        """
        return self._xnu_major < os_data.high_sierra.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def requires_kernel_debug_kit(self) -> bool:
        """
        Apple no longer provides standalone kexts in the base OS
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        Patches for Legacy Backlight Control
        """
        if self.native_os() is True:
            return {}

        return {
            "Legacy Backlight Control": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "AppleBacklight.kext":       "10.12.6",
                        "AppleBacklightExpert.kext": "10.12.6",
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        "DisplayServices.framework": "10.12.6",
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions/AppleGraphicsControl.kext/Contents/PlugIns": [
                        "AGDCBacklightControl.kext",
                    ],
                },
            },
        }

#gmux.py:
"""
gmux.py: Legacy GMUX detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants import Constants
from .....support   import utilities

from .....datasets.os_data import os_data


class GraphicsMultiplexer(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy GMUX"


    def _check_dgpu_status(self) -> bool:
        """
        Query whether system has an active dGPU
        """
        dgpu = self._computer.dgpu
        if dgpu:
            if dgpu.class_code and dgpu.class_code == 0xFFFFFFFF:
                # If dGPU is disabled via class-codes, assume demuxed
                return False
            return True
        return False


    def _detect_demux(self) -> bool:
        """
        Query whether system has been demuxed (ex. MacBookPro8,2, disabled dGPU)
        """
        # If GFX0 is missing, assume machine was demuxed
        # -wegnoegpu would also trigger this, so ensure arg is not present
        if not "-wegnoegpu" in (utilities.get_nvram("boot-args", decode=True) or ""):
            igpu = self._constants.computer.igpu
            dgpu = self._check_dgpu_status()
            if igpu and not dgpu:
                return True
        return False


    def present(self) -> bool:
        """
        Targeting Legacy GMUX Controllers
        Ref: https://doslabelectronics.com/Demux.html

        Sierra uses a legacy GMUX control method needed for dGPU switching on MacBookPro5,x
        Same method is also used for demuxed machines
        Note that MacBookPro5,x machines are extremely unstable with this patch set, so disabled until investigated further
        Ref: https://github.com/dortania/OpenCore-Legacy-Patcher/files/7360909/KP-b10-030.txt
        """
        return self._computer.real_model in ["MacBookPro8,2", "MacBookPro8,3"] and self._detect_demux()


    def native_os(self) -> bool:
        """
        Dropped support with macOS 10.13, High Sierra
        """
        return self._xnu_major < os_data.sierra.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def requires_kernel_debug_kit(self) -> bool:
        """
        Apple no longer provides standalone kexts in the base OS
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        Patches for Legacy GMUX Controllers
        """
        if self.native_os() is True:
            return {}

        if self._xnu_major not in self._constants.legacy_accel_support:
            return {}

        return {
            "Legacy GMUX": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions/AppleGraphicsControl.kext/Contents/PlugIns": {
                        "AppleMuxControl.kext": "10.12.6",
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        "AppleBacklight.kext",
                    ],
                    "/System/Library/Extensions/AppleGraphicsControl.kext/Contents/PlugIns": [
                        "AGDCBacklightControl.kext",
                        "AppleMuxControl.kext",
                    ],
                },
            },
        }

#keyboard_backlight.py:
"""
keyboard_backlight.py: Legacy Keyboard Backlight detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class KeyboardBacklight(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy Keyboard Backlight"


    def present(self) -> bool:
        """
        Targeting Legacy Keyboard Backlight (ie. non-Metal Macs)
        """
        return self._computer.real_model.startswith("MacBook") and self._is_gpu_architecture_present(
            gpu_architectures=[
                device_probe.Intel.Archs.Iron_Lake,
                device_probe.Intel.Archs.Sandy_Bridge,
                device_probe.AMD.Archs.TeraScale_1,
                device_probe.AMD.Archs.TeraScale_2,
                device_probe.NVIDIA.Archs.Tesla,
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 11, Big Sur
        """
        return self._xnu_major < os_data.big_sur.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def requires_kernel_debug_kit(self) -> bool:
        """
        Apple no longer provides standalone kexts in the base OS
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        Patches for Legacy Keyboard Backlight
        """
        if self.native_os() is True:
            return {}

        if self._xnu_major not in self._constants.legacy_accel_support:
            return {}

        return {
            "Legacy Keyboard Backlight": {
                PatchType.EXECUTE: {
                    "/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist Moraea_BacklightHack -bool true": True,
                }
            },
        }

#legacy_audio.py:
"""
legacy_audio.py: Legacy Audio detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants import Constants
from .....support   import utilities

from .....datasets.os_data import os_data


class LegacyAudio(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy Audio"


    def present(self) -> bool:
        """
        Targeting Realtek Audio and machines without AppleALC
        """
        return self._computer.real_model in ["iMac7,1", "iMac8,1"] or (
        self._computer.real_model in ["MacBook5,1",
                                      "MacBook5,2",
                                      "MacBook6,1",
                                      "MacBook7,1",
                                      "MacBookAir2,1",
                                      "MacBookAir3,1",
                                      "MacBookAir3,2",
                                      "MacBookAir4,1",
                                      "MacBookAir4,2",
                                      "MacBookPro4,1",
                                      "MacBookPro5,1",
                                      "MacBookPro5,2",
                                      "MacBookPro5,3",
                                      "MacBookPro5,4",
                                      "MacBookPro5,5",
                                      "MacBookPro6,1",
                                      "MacBookPro6,2",
                                      "MacBookPro7,1",
                                      "MacBookPro8,1",
                                      "MacBookPro8,2",
                                      "MacBookPro8,3",
                                      "Macmini3,1",
                                      "Macmini4,1",
                                      "Macmini5,1",
                                      "Macmini5,2",
                                      "Macmini5,3",
                                      "iMac9,1",
                                      "iMac10,1",
                                      "iMac11,1",
                                      "iMac11,2",
                                      "iMac11,3",
                                      "iMac12,1",
                                      "iMac12,2",
                                      "MacPro3,1"
        ] and utilities.check_kext_loaded("as.vit9696.AppleALC") is False)


    def native_os(self) -> bool:
        """
        - iMac7,1 and iMac8,1 last supported in macOS 10.11, El Capitan
        - All other models pre-2012 models last supported in macOS 10.13, High Sierra
        """
        if self._computer.real_model in ["iMac7,1", "iMac8,1"]:
            return self._xnu_major < os_data.sierra.value
        return self._xnu_major < os_data.mojave.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def _missing_gop_patches(self) -> dict:
        """
        Patches for graphics cards with missing GOP (ie. breaking AppleALC functionality)
        """
        return {
            "Legacy Non-GOP": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "AppleHDA.kext": "10.13.6",
                    },
                },
            },
        }


    def _realtek_audio_patches(self) -> dict:
        """
        Patches for Realtek Audio
        """
        return {
            "Legacy Realtek": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "AppleHDA.kext":      "10.11.6",
                        "IOAudioFamily.kext": "10.11.6",
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        "AppleVirtIO.kext",
                        "AppleVirtualGraphics.kext",
                        "AppleVirtualPlatform.kext",
                        "ApplePVPanic.kext",
                        "AppleVirtIOStorage.kext",
                        "AvpFairPlayDriver.kext",
                    ],
                },
            },
        }


    def patches(self) -> dict:
        """
        Patches for legacy audio
        """
        if self.native_os() is True:
            return {}

        if self._computer.real_model in ["iMac7,1", "iMac8,1"]:
            return self._realtek_audio_patches()
        return self._missing_gop_patches()

#pcie_webcam.py:
"""
pci_webcam.py: PCIe FaceTime Camera detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants import Constants

from .....datasets.os_data import os_data


class PCIeFaceTimeCamera(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: PCIe FaceTime Camera"


    def present(self) -> bool:
        """
        Targeting PCIe FaceTime Cameras
        """
        return self._computer.pcie_webcam


    def native_os(self) -> bool:
        """
        Dropped support with macOS 14 Developer Beta 1 (23A5257q)
        """
        return self._xnu_major < os_data.sonoma.value or self._os_build == "23A5257q"


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def patches(self) -> dict:
        """
        Patches for PCIe FaceTime Camera
        """
        if self.native_os() is True:
            return {}

        return {
            "PCIe FaceTime Camera": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks/CoreMediaIO.framework/Versions/A/Resources": {
                        "AppleCamera.plugin":  "14.0 Beta 1"
                    },
                    "/System/Library/LaunchDaemons": {
                        "com.apple.cmio.AppleCameraAssistant.plist":  "14.0 Beta 1"
                    },
                },
            },
        }

#t1_security.py
"""
t1_security.py: T1 Security Chip detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants import Constants

from .....datasets.os_data import os_data


class T1SecurityChip(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: T1 Security Chip"


    def present(self) -> bool:
        """
        Targeting T1 Security Chip
        """
        return self._computer.t1_chip


    def native_os(self) -> bool:
        """
        Dropped support with macOS 14, Sonoma
        """
        return self._xnu_major < os_data.sonoma.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def patches(self) -> dict:
        """
        Patches for T1 Security Chip
        """
        if self.native_os() is True:
            return {}

        return {
            "T1 Security Chip": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    # Required for Apple Pay
                    "/usr/lib": {
                        "libNFC_Comet.dylib":          "13.6",
                        "libNFC_HAL.dylib":            "13.6",

                        "libnfshared.dylib":           "13.6",
                        "libnfshared.dylibOld.dylib":  "13.6",
                        "libnfstorage.dylib":          "13.6",
                        "libnfrestore.dylib":          "13.6",

                        "libPN548_API.dylib":          "13.6"
                    },
                    "/usr/libexec": {
                        "biometrickitd":      "13.6",    # Required for Touch ID
                        "nfcd":               "13.6",    # Required for Apple Pay
                        "nfrestore_service":  "13.6",    # Required for Apple Pay
                    },
                    "/usr/standalone/firmware/nfrestore/firmware/fw": {
                        "PN549_FW_02_01_5A_rev88207.bin":         "13.6",
                        "SN100V_FW_A3_01_01_81_rev127208.bin":    "13.6",
                        "SN200V_FW_B1_02_01_86_rev127266.bin":    "13.6",
                        "SN300V_FW_B0_02_01_22_rev129172.bin":    "13.6",
                    }
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks/LocalAuthentication.framework/Support": {
                        "SharedUtils.framework": f"13.6-{self._xnu_major}" if self._xnu_major < os_data.sequoia else f"13.7.1-{self._xnu_major}",  # Required for Password Authentication (SharedUtils.framework)
                        **({ "MechanismPlugins": "15.0 Beta 4" } if self._xnu_major >= os_data.sequoia else {}), # Required to add a TouchID fingerprint
                        **({ "ModulePlugins": "15.1" } if self._xnu_float >= self.macOS_15_2 else {}),
                        **({ "ModuleBase.framework": "15.2" } if self._xnu_float >= self.macOS_15_3 else {}),
                    },
                    "/System/Library/PrivateFrameworks": {
                        "EmbeddedOSInstall.framework": "13.6",  # Required for biometrickitd
                        **({ "NearField.framework": "14.7.2" } if self._xnu_major >= os_data.sequoia else {}),
                    },
                }
            },
        }

#usb11.py


"""
usb11.py: Legacy USB 1.1 Controller detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data
from .....datasets import smbios_data, cpu_data


class USB11Controller(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy USB 1.1"


    def present(self) -> bool:
        """
        Targeting UHCI/OHCI controllers
        """
        # If we're on a hackintosh, check for UHCI/OHCI controllers
        if self._constants.host_is_hackintosh is True:
            for controller in self._computer.usb_controllers:
                if (
                    isinstance(controller, device_probe.UHCIController) or
                    isinstance(controller, device_probe.OHCIController)
                ):
                    return True
            return False

        if self._computer.real_model not in smbios_data.smbios_dictionary:
            return False

        # If we're on a Mac, check for Penryn or older
        # This is due to Apple implementing an internal USB hub on post-Penryn (excluding MacPro4,1, MacPro5,1 and Xserve3,1)
        # Ref: https://techcommunity.microsoft.com/t5/microsoft-usb-blog/reasons-to-avoid-companion-controllers/ba-p/270710
        if (
            smbios_data.smbios_dictionary[self._computer.real_model]["CPU Generation"] <= cpu_data.CPUGen.penryn.value or \
            self._computer.real_model in ["MacPro4,1", "MacPro5,1", "Xserve3,1"]
        ):
            return True

        return False


    def native_os(self) -> bool:
        """
        Dropped support with macOS 13, Ventura
        """
        return self._xnu_major < os_data.ventura.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.MISCELLANEOUS


    def _base_patches(self) -> dict:
        """
        Base patches for USB 1.1 Controller
        """
        return {
            "Legacy USB 1.1": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "IOUSBHostFamily.kext": "12.6.2" if self._xnu_float < self.macOS_14_4 else "12.6.2-23.4",
                    },
                },
            },
        }


    def _extended_patches(self) -> dict:
        """
        Extended patches for USB 1.1 Controller
        """
        if self._xnu_float < self.macOS_14_1:
            return {}

        return {
            # Injection of UHCI/OHCI causes a panic on 14.1+
            "Legacy USB 1.1 Extended": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions/IOUSBHostFamily.kext/Contents/PlugIns": {
                        "AppleUSBOHCI.kext":    "12.6.2-USB",
                        "AppleUSBOHCIPCI.kext": "12.6.2-USB",
                        "AppleUSBUHCI.kext":    "12.6.2-USB",
                        "AppleUSBUHCIPCI.kext": "12.6.2-USB",
                    },
                    "/System/Library/Extensions": {
                        **({ "AppleUSBAudio.kext": "14.5" } if self._xnu_major >= os_data.sequoia else {}),
                        **({ "AppleUSBCDC.kext":   "14.5" } if self._xnu_major >= os_data.sequoia else {}),
                    },
                },
            },
        }


    def _usb_webcam_patches(self) -> dict:
        """
        Patches for USB 1.1 Webcam
        """
        if self._xnu_major < os_data.sequoia.value:
            return {}

        return {
            "Legacy USB 1.1 Webcam": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "IOUSBHost.framework": "14.6.1",
                    },
                },
            },
        }


    def patches(self) -> dict:
        """
        Patches for USB 1.1 Controller
        """
        if self.native_os() is True:
            return {}

        return {
            **self._base_patches(),
            **self._extended_patches(),
            **self._usb_webcam_patches(),
        }

#networking
#legacy_wireless.py:
"""
legacy_wireless.py: Legacy Wireless detection
"""

import packaging.version

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class LegacyWireless(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Legacy Wireless"


    def present(self) -> bool:
        """
        Targeting Legacy Wireless
        """
        if (
            isinstance(self._computer.wifi, device_probe.Broadcom)
            and self._computer.wifi.chipset in [device_probe.Broadcom.Chipsets.AirPortBrcm4331, device_probe.Broadcom.Chipsets.AirPortBrcm43224]
        ):
            return True

        if (
            isinstance(self._computer.wifi, device_probe.Atheros)
            and self._computer.wifi.chipset == device_probe.Atheros.Chipsets.AirPortAtheros40
        ):
            return True

        return False


    def native_os(self) -> bool:
        """
        Dropped support with macOS 12, Monterey
        """
        return self._xnu_major < os_data.monterey.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.NETWORKING


    def _affected_by_cve_2024_23227(self) -> bool:
        """
        CVE-2024-23227 broke our airportd patches for 12.7.4, 13.6.5 and 14.4

        Note that since the XNU version's security patch level is not increment
        """

        if self._xnu_major > os_data.sonoma:
            return True

        marketing_version = self._constants.detected_os_version
        parsed_version = packaging.version.parse(marketing_version)

        if marketing_version.startswith("12"):
            return parsed_version >= packaging.version.parse("12.7.4")
        if marketing_version.startswith("13"):
            return parsed_version >= packaging.version.parse("13.6.5")
        if marketing_version.startswith("14"):
            return parsed_version >= packaging.version.parse("14.4")

        return False


    def _base_patch(self) -> dict:
        """
        Base patches for Legacy Wireless
        """
        return {
            "Legacy Wireless": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/usr/libexec": {
                        "airportd": "11.7.10" if self._affected_by_cve_2024_23227 is False else "11.7.10-Sandbox",
                    },
                    "/System/Library/CoreServices": {
                        "WiFiAgent.app": "11.7.10",
                    },
                },
                PatchType.OVERWRITE_DATA_VOLUME: {
                    "/Library/Application Support/SkyLightPlugins": {
                        **({ "CoreWLAN.dylib": "SkyLightPlugins" } if self._xnu_major == os_data.monterey else {}),
                        **({ "CoreWLAN.txt": "SkyLightPlugins" } if self._xnu_major == os_data.monterey else {}),
                    },
                },
            },
        }


    def _extended_patch(self) -> dict:
        """
        Extended patches for Legacy Wireless
        """
        if self._xnu_major < os_data.ventura:
            return {}

        return {
            "Legacy Wireless Extended": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/usr/libexec": {
                        "wps":      "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                        "wifip2pd": "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "CoreWLAN.framework": "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                    },
                    "/System/Library/PrivateFrameworks": {
                        "CoreWiFi.framework":       "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                        "IO80211.framework":        "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                        "WiFiPeerToPeer.framework": "12.7.2" if self._xnu_major < os_data.sequoia else f"12.7.2-{self._xnu_major}",
                    },
                }
            },
        }


    def patches(self) -> dict:
        """
        Patches for Legacy Wireless
        """
        if self.native_os() is True:
            return {}

        return {
            **self._base_patch(),
            **self._extended_patch(),
        }

#modern_wireless.py:
"""
modern_wireless.py: Modern Wireless detection
"""

from ..base import BaseHardware, HardwareVariant

from ...base import PatchType

from .....constants  import Constants
from .....detections import device_probe

from .....datasets.os_data import os_data


class ModernWireless(BaseHardware):

    def __init__(self, xnu_major, xnu_minor, os_build, global_constants: Constants) -> None:
        super().__init__(xnu_major, xnu_minor, os_build, global_constants)


    def name(self) -> str:
        """
        Display name for end users
        """
        return f"{self.hardware_variant()}: Modern Wireless"


    def present(self) -> bool:
        """
        Targeting Modern Wireless
        """
        return isinstance(self._computer.wifi, device_probe.Broadcom) and (
            self._computer.wifi.chipset in [
                device_probe.Broadcom.Chipsets.AirPortBrcm4360,
                device_probe.Broadcom.Chipsets.AirportBrcmNIC,
                # We don't officially support this chipset, however we'll throw a bone to hackintosh users
                device_probe.Broadcom.Chipsets.AirPortBrcmNICThirdParty,
            ]
        )


    def native_os(self) -> bool:
        """
        Dropped support with macOS 14, Sonoma
        """
        return self._xnu_major < os_data.sonoma.value


    def hardware_variant(self) -> HardwareVariant:
        """
        Type of hardware variant
        """
        return HardwareVariant.NETWORKING


    def patches(self) -> dict:
        """
        Patches for Modern Wireless
        """
        if self.native_os() is True:
            return {}

        return {
            "Modern Wireless": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/usr/libexec": {
                        "airportd": f"13.7.2-{self._xnu_major}",
                        "wifip2pd": f"13.7.2-{self._xnu_major}",
                    },
                    "/System/Library/CoreServices": {
                        **({ "WiFiAgent.app": "14.7.2" } if self._xnu_major >= os_data.sequoia else {}),
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "CoreWLAN.framework": f"13.7.2-{self._xnu_major}",
                    },
                    "/System/Library/PrivateFrameworks": {
                        "CoreWiFi.framework":       f"13.7.2-{self._xnu_major}",
                        "IO80211.framework":        f"13.7.2-{self._xnu_major}",
                        "WiFiPeerToPeer.framework": f"13.7.2-{self._xnu_major}",
                    },
                }
            },
        }

#shared_patches
#amd_opencl.py:
"""
amd_opencl.py: AMD OpenCL patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class AMDOpenCL(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        In Ventura, Apple added AVX2.0 code to AMD's OpenCL/GL compilers
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "AMD OpenCL": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "OpenCL.framework": "12.5 non-AVX2.0",
                        "OpenGL.framework": "12.5 non-AVX2.0",
                    },
                },
            },
        }

#amd_terascale.py
"""
amd_terascale.py: AMD TeraScale patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class AMDTeraScale(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major >= os_data.mojave.value


    def patches(self) -> dict:
        """
        Shared patches between TeraScale 1 and 2
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "AMD TeraScale Common": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "AMDFramebuffer.kext":           "10.13.6",
                        "AMDLegacyFramebuffer.kext":     "10.13.6" if self._xnu_float < self.macOS_13_3 else "10.13.6 TS2",
                        "AMDLegacySupport.kext":         "10.13.6",
                        "AMDShared.bundle":              "10.13.6",
                        "AMDSupport.kext":               "10.13.6",
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        "AMD7000Controller.kext",
                        "AMD8000Controller.kext",
                        "AMD9000Controller.kext",
                        "AMD9500Controller.kext",
                        "AMD10000Controller.kext",
                    ],
                },
            },
        }

#base.py
"""
base.py: Base class for shared patch sets
"""

from ..base import BasePatchset


class BaseSharedPatchSet(BasePatchset):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__()
        self._xnu_major = xnu_major
        self._xnu_minor = xnu_minor
        self._marketing_version = marketing_version

        self._xnu_float = float(f"{self._xnu_major}.{self._xnu_minor}")


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires patches
        """
        raise NotImplementedError


    def patches(self) -> dict:
        """
        Dictionary of patches
        """
        raise NotImplementedError

#big_sur_gva.py
"""
big_sur_gva.py: Big Sur GVA patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class BigSurGVA(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.monterey.value


    def patches(self) -> dict:
        """
        For GPUs last natively supported in Catalina/Big Sur
        Restores DRM support for these GPUs
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Big Sur GVA": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        "AppleGVA.framework":     "11.7.10",
                        "AppleGVACore.framework": "11.7.10",
                    },
                },
            },
        }

#big_sur_opencl.py
"""
big_sur_opencl.py: Big Sur OpenCL patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class BigSurOpenCL(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.monterey.value


    def patches(self) -> dict:
        """
        For graphics cards dropped in Monterey
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Big Sur OpenCL": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "OpenCL.framework": "11.6",
                    },
                },
            },
        }

#high_sierra_gva.py
"""
high_sierra_gva.py: High Sierra GVA patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class HighSierraGVA(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 11.0, Big Sur
        """
        return self._xnu_major >= os_data.big_sur.value


    def patches(self) -> dict:
        """
        For GPUs last natively supported in High Sierra/Catalina
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            # For GPUs last natively supported in High Sierra/Catalina
            # Restores DRM support
            "High Sierra GVA": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        "AppleGVA.framework":     "10.13.6",
                        "AppleGVACore.framework": "10.15.7",
                    },
                },
            },
        }

#metal_3802.py
"""
metal_3802.py: Metal 3802 patches
"""

import packaging.version

from .base import BaseSharedPatchSet

from ..base import PatchType, DynamicPatchset

from ....datasets.os_data import os_data


class LegacyMetal3802(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.ventura.value


    def _patches_metal_3802_common(self) -> dict:
        """
        Intel Ivy Bridge, Haswell and Nvidia Kepler are Metal 3802-based GPUs
        Due to this, we need to re-add 3802 compiler support to the Metal stack
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Metal 3802 Common": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Sandbox/Profiles": {
                        "com.apple.mtlcompilerservice.sb": "12.5-3802",
                    }
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "Metal.framework": "12.5-3802-22" if self._xnu_major < os_data.sonoma else "12.5-3802-23",
                    },
                    "/System/Library/PrivateFrameworks": {
                        "MTLCompiler.framework": "12.7.6-3802",
                        "GPUCompiler.framework": "12.7.6-3802",
                    },
                }
            }
        }


    def _patches_metal_3802_common_extended(self) -> dict:
        """
        Support for 3802 GPUs were broken with 13.3+
        Downgrades 31001 stack to 13.2.1, however nukes AMFI support
        """
        if self._xnu_float < self.macOS_13_3:
            return {}

        return {
            "Metal 3802 Common Extended": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "Metal.framework": f"13.2.1-{self._xnu_major}",
                        **({  "CoreImage.framework": "14.0 Beta 3" if self._xnu_major < os_data.sequoia.value else "14.0 Beta 3-24"} if self._xnu_major >= os_data.sonoma.value else {}),
                    },
                    "/System/Library/PrivateFrameworks": {
                        **({  "MTLCompiler.framework": "13.2.1" } if self._xnu_major == os_data.ventura.value else {}),
                        **({  "GPUCompiler.framework": "13.2.1" } if self._xnu_major == os_data.ventura.value else {}),
                        "RenderBox.framework": "13.2.1-3802"      if self._xnu_major == os_data.ventura.value else "14.0-3802",

                        # More issues for 3802, now with 14.2 Beta 2+...
                        # If there is a god, they clearly despise us and legacy Macs.
                        **({  "MTLCompiler.framework": "14.2 Beta 1" } if self._xnu_float >= self.macOS_14_2 else {}),
                        **({  "GPUCompiler.framework": "14.2 Beta 1" } if self._xnu_float >= self.macOS_14_2 else {}),
                    },

                },
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks/PhotosUICore.framework/Versions/A/Resources": {
                        **({  "default.metallib": "14.6.1" } if self._xnu_major == os_data.sonoma.value else {}),
                    },
                }
            }
        }


    def _patches_metal_3802_metallibs(self) -> dict:
        """
        With macOS Sequoia, a new .metallib compiler format was introduced (V27)
        Thus we need to patch all .metallib files to support 3802 GPUs using MetallibSupportPkg

        Reference:
        https://github.com/dortania/MetallibSupportPkg
        """
        if self._xnu_major < os_data.sequoia.value:
            return {}

        return {
            "Metal 3802 .metallibs": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSCore.framework/Versions/A/Resources": {
                        "default.metallib": "14.6.1",
                    },
                    "/System/Library/Frameworks/MLCompute.framework/Versions/A/Resources": {
                        "default.metallib": "14.6.1"
                    },
                    "/System/Library/PrivateFrameworks/CoreUI.framework/Versions/A/Resources": {
                        "default.metallib": "14.6.1",
                    },
                    "/System/Library/Frameworks/CoreImage.framework/Versions/A": {
                        "CoreImage.metallib": "14.6.1",
                    },
                    "/System/Library/Frameworks/CoreImage.framework/Versions/A/Resources": {
                        "default.metallib":                    "14.6.1",
                        "ci_filters.metallib":                 "14.6.1",
                        "ci_stdlib_stitchable_h.metallib":     "14.6.1",
                        "ci_stdlib_stitchable.metallib":       "14.6.1",
                        "CIPortraitBlurStitchableV3.metallib": "14.6.1",
                        "CIPortraitBlurStitchableV2.metallib": "14.6.1",
                        "ci_stdlib_h.metallib":                "14.6.1",
                        "ci_filters_stitchable.metallib":      "14.6.1",
                        "CIPortraitBlurV2.metallib":           "14.6.1",
                        "CIPortraitBlurV3.metallib":           "14.6.1",
                        "ci_stdlib.metallib":                  "14.6.1",
                    },
                    "/System/Library/PrivateFrameworks/Tungsten.framework/Versions/A/Resources": {
                        "default.metallib": "15.0 Beta 7",
                    },
                    "/System/Library/PrivateFrameworks/RenderBox.framework/Versions/A/Resources": {
                        "default.metallib": "15.0 Beta 8" if packaging.version.parse(self._marketing_version) < packaging.version.parse("15.1") else "15.1 Beta 4",
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/VFX.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/VisionKitInternal.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/TSReading.framework/Versions/A/Resources": {
                        "TSDDefaultMetalLibrary.metallib": DynamicPatchset.MetallibSupportPkg,
                        "KeynoteMetalLibrary.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/WeatherUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "ForegroundEffectShaders.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/AvatarKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/Tungsten.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/TextInputUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/ActivityRingsUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/ChatKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/WeatherMaps.framework/Versions/A/Resources": {
                        "WeatherMapsMetalLib.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/HomeAccessoryControlUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/PassKitUIFoundation.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/PrivateFrameworks/MediaCoreUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/Frameworks/ARKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/Frameworks/SpriteKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/Frameworks/PencilKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/Frameworks/SwiftUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/iOSSupport/System/Library/Frameworks/SceneKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Video/Plug-Ins/AppleGVAHEVCEncoder.bundle/Contents/Resources": {
                        "AppleGVAHEVCFrameStatistics.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Video/Plug-Ins/AV1DecoderSW.bundle/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Video/Plug-Ins/AppleAVEEncoder.bundle/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/CoreServices/MTLReplayer.app/Contents/Frameworks/MTLReplayController.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/CoreImage/CIPassThrough.cifilter/Contents/Resources": {
                        "CIPassThrough.ci.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/CoreImage/PortraitFilters.cifilter/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "portrait_filters.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/ScreenCaptureKitMetal/ScreenCaptureKitMetal.bundle/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/ExtensionKit/Extensions/Monterey.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/ExtensionKit/Extensions/Drift.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/ExtensionKit/Extensions/WallpaperMacintoshExtension.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/ExtensionKit/Extensions/WallpaperSequoiaExtension.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/SetupAssistantSupportUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/GESS.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VFX.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VisionCore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/CMImaging.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/CoreRE.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/HDRProcessing.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AvatarKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/SkyLight.framework/Versions/A/Resources": {
                        "SkyLightShaders.air64.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AppleISPEmulator.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/NeutrinoCore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/ImageHarmonizationKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VideoProcessing.framework/Versions/A/PlugIns/Codecs/VCPRealtimeEncoder.bundle/Contents/Resources": {
                        "ProcessAccelerate.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VideoProcessing.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "ProcessAccelerate.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Portrait.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VisualGeneration.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "NonMaxLineSuppress.ci.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AccelerateGPU.framework": {
                        "GPUBLAS.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AccelerateGPU.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/ShaderGraph.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Hydra.framework/Plugins/HydraQLThumbnailExtension.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Hydra.framework/Plugins/HydraQLPreviewExtension.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Hydra.framework/Versions/C/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/SiriUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/TextRecognition.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Leonardo.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VectorKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/VectorKit.framework/Versions/A/Resources/metal_libraries": {
                        "AlloyCommonLibrary.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/GPUToolsCapture.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/PhotoImaging.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/PhotosUICore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/MetalTools.framework/Versions/A/Resources": {
                        "MTLLegacySVICBSupport.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLGPUDebugICBSupport.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLGPUDebugAccelerationStructureSupport.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLDebugShaders.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLLegacySVAccelerationStructureSupport.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AppleDepth.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Human.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/CorePhotogrammetry.framework/Versions/A/Resources": {
                        "ComputerVision_Tess_Kernels.metallib": DynamicPatchset.MetallibSupportPkg,
                        "Photogrammetry_Matching_Kernels.metallib": DynamicPatchset.MetallibSupportPkg,
                        "Photogrammetry_Texturing_Kernels.metallib": DynamicPatchset.MetallibSupportPkg,
                        "Photogrammetry_MVS_Kernels.metallib": DynamicPatchset.MetallibSupportPkg,
                        "Photogrammetry_Meshing_Kernels.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/HumanUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Quagga.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/Espresso.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/CMPhoto.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/MediaAnalysis.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/AltruisticBodyPoseKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/MusicUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/FRC.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/H13ISPServices.framework/Versions/A/Resources": {
                        "CalibrateRgbIr.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/SiriUICore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/PassKitUIFoundation.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/H16ISPServices.framework/Versions/A/Resources": {
                        "CalibrateRgbIr.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/CoreOCModules.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/PhotosensitivityProcessing.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/PrivateFrameworks/MediaCoreUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/Metal.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLMeshShaderEmulator.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLBVHBuilder.metallib": DynamicPatchset.MetallibSupportPkg,
                        "MTLECBE.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/QuartzCore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/CoreMediaIO.framework/Versions/A/Resources/ACD.plugin/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSFunctions.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSRayIntersector.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSNeuralNetwork.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSNDArray.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSImage.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalPerformanceShaders.framework/Versions/A/Frameworks/MPSMatrix.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/MetalFX.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/ParavirtualizedGraphics.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/ImageIO.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/SpriteKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/PencilKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/CoreDisplay.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/SwiftUICore.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/SwiftUI.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/Vision.framework/Versions/A/Resources": {
                        "ImageFilters.metallib": DynamicPatchset.MetallibSupportPkg,
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/StickerKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/VideoToolbox.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/Frameworks/SceneKit.framework/Versions/A/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Library/VideoProcessors/CCPortrait.bundle/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "CoreImageKernels_only.ci.metallib": DynamicPatchset.MetallibSupportPkg,
                        "CoreImageKernels.ci.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Applications/Music.app/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Applications/Chess.app/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Applications/Freeform.app/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                        "coreimage.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                    "/System/Applications/Freeform.app/Contents/Extensions/USDRendererExtension.appex/Contents/Resources": {
                        "default.metallib": DynamicPatchset.MetallibSupportPkg,
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks/RenderBox.framework/Versions/A/Resources": [
                        # For some reason Ivy Bridge can't tell the metallib lacks AIR64 support, and errors out
                        "archive.metallib",
                    ],
                },
            }
        }


    def patches(self) -> dict:
        """
        Dictionary of patches
        """
        return {
            **self._patches_metal_3802_common(),
            **self._patches_metal_3802_common_extended(),
            **self._patches_metal_3802_metallibs(),
        }

#monterey_gva.py
"""
monterey_gva.py: Monterey GVA patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class MontereyGVA(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        For GPUs last natively supported in Monterey
        Restores DRM support
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Monterey GVA": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks": {
                        "AppleGVA.framework":     "12.5",
                        "AppleGVACore.framework": "12.5",
                    },
                },
            },
        }


    def revert_patches(self) -> dict:
        """
        Revert if patches are no longer required/misapplied
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Revert Monterey GVA": {
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/PrivateFrameworks/AppleGVA.framework/Versions/A": [
                        "AppleGVA"
                    ],
                    "/System/Library/PrivateFrameworks/AppleGVACore.framework/Versions/A": [
                        "AppleGVACore"
                    ],
                }
            }
        }

#monterey_opencl.py
"""
monterey_opencl.py: Monterey OpenCL patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class MontereyOpenCL(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major >= os_data.ventura.value


    def patches(self) -> dict:
        """
        For graphics cards dropped in Ventura
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Monterey OpenCL": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "OpenCL.framework": "12.5",
                    },
                },
            },
        }

#monterey_webkit.py:
"""
monterey_opencl.py: Monterey OpenCL patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class MontereyWebKit(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Check if the current OS requires
        """
        return self._xnu_major == os_data.monterey.value


    def patches(self) -> dict:
        """
        Monterey has a WebKit sandboxing issue where many UI elements fail to render
        This patch simple replaces the sandbox profile with one supporting our GPUs
        Note: Neither Big Sur nor Ventura have this issue
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "WebKit Monterey Common": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "WebKit.framework":  "11.6"
                    },
                },
                PatchType.MERGE_DATA_VOLUME: {
                    "/Library/Apple/System/Library/StagedFrameworks/Safari": {
                        "WebKit.framework":  "11.6"
                    },
                },
            },
        }

# non_metal_coredisplay.py:
"""
non_metal_coredisplay.py: Non-Metal CoreDisplay patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class NonMetalCoreDisplay(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major >= os_data.mojave.value


    def patches(self) -> dict:
        """
        Nvidia Web Drivers require an older build of CoreDisplay
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Non-Metal CoreDisplay Common": {
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "CoreDisplay.framework": f"10.13.6-{self._xnu_major}",
                    },
                },
            },
        }

#non_metal_enforcement.py:
"""
non_metal_enforcement.py: Non-Metal Enforcement patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class NonMetalEnforcement(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major >= os_data.mojave.value


    def patches(self) -> dict:
        """
        Forces Metal kexts from High Sierra to run in the fallback non-Metal mode
        Verified functional with HD4000 and Iris Plus 655
        Only used for internal development purposes, not suitable for end users

        Note: Metal kexts in High Sierra rely on IOAccelerator, thus 'Non-Metal IOAccelerator Common'
        is needed for proper linking
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Non-Metal Enforcement": {
                PatchType.EXECUTE: {
                    "/usr/bin/defaults write /Library/Preferences/com.apple.CoreDisplay useMetal -boolean no": True,
                    "/usr/bin/defaults write /Library/Preferences/com.apple.CoreDisplay useIOP -boolean no":   True,
                },
            },
        }

#non_metal_ioaccel.py:
"""
non_metal_ioaccel.py: Non-Metal IOAccelerator patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class NonMetalIOAccelerator(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major >= os_data.mojave.value


    def patches(self) -> dict:
        """
        TeraScale 2 and Nvidia Web Drivers broke in Mojave due to mismatched structs in
        the IOAccelerator stack
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Non-Metal IOAccelerator Common": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "IOAcceleratorFamily2.kext":     "10.13.6",
                        "IOSurface.kext":                "10.14.6",
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "IOSurface.framework": f"10.14.6-{self._xnu_major}",
                        "OpenCL.framework":     "10.13.6",
                    },
                    "/System/Library/PrivateFrameworks": {
                        "GPUSupport.framework":     "10.13.6",
                        "IOAccelerator.framework": f"10.13.6-{self._xnu_major}",
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        "AppleCameraInterface.kext"
                    ],
                },
            },
        }

#non_metal.py:
"""
non_metal.py: Non-Metal patches
"""

from .base import BaseSharedPatchSet

from ..base import PatchType

from ....datasets.os_data import os_data


class NonMetal(BaseSharedPatchSet):

    def __init__(self, xnu_major: int, xnu_minor: int, marketing_version: str) -> None:
        super().__init__(xnu_major, xnu_minor, marketing_version)


    def _os_requires_patches(self) -> bool:
        """
        Dropped support with macOS 10.14, Mojave
        """
        return self._xnu_major >= os_data.mojave.value


    def patches(self) -> dict:
        """
        General non-Metal GPU patches
        """
        if self._os_requires_patches() is False:
            return {}

        return {
            "Non-Metal Common": {
                PatchType.OVERWRITE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": {
                        "IOSurface.kext": "10.15.7",
                    },
                    "/System/Applications": {
                        **({ "Photo Booth.app": "11.7.9"} if self._xnu_major >= os_data.monterey else {}),
                    },
                    "/usr/sbin": {
                        **({ "screencapture": "14.7"} if self._xnu_major >= os_data.sequoia else {}),
                    },
                    "/System/Library/CoreServices/RemoteManagement": {
                        **({"ScreensharingAgent.bundle": "14.7.2"} if self._xnu_major >= os_data.sequoia else {}),
                        **({"screensharingd.bundle":     "14.7.2"} if self._xnu_major >= os_data.sequoia else {}),
                        **({"SSMenuAgent.app":           "14.7.2"} if self._xnu_major >= os_data.sequoia else {}),
                    },
                },
                PatchType.REMOVE_SYSTEM_VOLUME: {
                    "/System/Library/Extensions": [
                        "AMDRadeonX4000.kext",
                        "AMDRadeonX4000HWServices.kext",
                        "AMDRadeonX5000.kext",
                        "AMDRadeonX5000HWServices.kext",
                        "AMDRadeonX6000.kext",
                        "AMDRadeonX6000Framebuffer.kext",
                        "AMDRadeonX6000HWServices.kext",
                        "AppleIntelBDWGraphics.kext",
                        "AppleIntelBDWGraphicsFramebuffer.kext",
                        "AppleIntelCFLGraphicsFramebuffer.kext",
                        "AppleIntelHD4000Graphics.kext",
                        "AppleIntelHD5000Graphics.kext",
                        "AppleIntelICLGraphics.kext",
                        "AppleIntelICLLPGraphicsFramebuffer.kext",
                        "AppleIntelKBLGraphics.kext",
                        "AppleIntelKBLGraphicsFramebuffer.kext",
                        "AppleIntelSKLGraphics.kext",
                        "AppleIntelSKLGraphicsFramebuffer.kext",
                        "AppleIntelFramebufferAzul.kext",
                        "AppleIntelFramebufferCapri.kext",
                        "AppleParavirtGPU.kext",
                        "GeForce.kext",
                        "IOAcceleratorFamily2.kext",
                        "IOGPUFamily.kext",
                        "AppleAfterburner.kext",
                    ],
                    "/System/Library/ExtensionKit/Extensions/": [
                        "WallpaperMacintoshExtension.appex"
                    ],
                },
                PatchType.OVERWRITE_DATA_VOLUME: {
                    "/Library/Application Support/SkyLightPlugins": {
                        **({ "DropboxHack.dylib": "SkyLightPlugins" } if self._xnu_major >= os_data.monterey else {}),
                        **({ "DropboxHack.txt":   "SkyLightPlugins" } if self._xnu_major >= os_data.monterey else {}),
                    },
                },
                PatchType.MERGE_SYSTEM_VOLUME: {
                    "/System/Library/Frameworks": {
                        "OpenGL.framework":       "10.14.3",
                        "CoreDisplay.framework": f"10.14.4-{self._xnu_major}",
                        "IOSurface.framework":   f"10.15.7-{self._xnu_major}",
                        "QuartzCore.framework":  f"10.15.7-{self._xnu_major}",
                    },
                    "/System/Library/PrivateFrameworks": {
                        "GPUSupport.framework": "10.14.3",
                        "SkyLight.framework":  f"10.14.6-{self._xnu_major}",
                        **({"FaceCore.framework":  f"13.5"} if self._xnu_major >= os_data.sonoma else {}),
                    },
                },
                PatchType.EXECUTE: {
                    # 'When Space Allows' option introduced in 12.4 (XNU 21.5)
                    **({"/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist ShowDate -int 1": True } if self._xnu_float >= self.macOS_12_4 else {}),
                    "/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist InternalDebugUseGPUProcessForCanvasRenderingEnabled -bool false": True,
                    "/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist WebKitExperimentalUseGPUProcessForCanvasRenderingEnabled -bool false": True,
                    **({"/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist WebKitPreferences.acceleratedDrawingEnabled -bool false": True} if self._xnu_major >= os_data.sonoma else {}),
                    **({"/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist NSEnableAppKitMenus -bool false": True} if self._xnu_major >= os_data.sonoma else {}),
                    **({"/usr/bin/defaults write /Library/Preferences/.GlobalPreferences.plist NSZoomButtonShowMenu -bool false": True} if self._xnu_major == os_data.sonoma else {}),
                },
            },
        }

#sys_patch_helpers.py:
"""
sys_patch_helpers.py: Additional support functions for sys_patch.py
Modified for macOS Tahoe (version 27+) support - Developed by Casey Jay Topojani
Skyscope Sentinel Intelligence - MIT - 2025
"""

import os
import logging
import plistlib
import subprocess

from typing import Union
from pathlib import Path
from datetime import datetime

from .. import constants

from ..datasets import os_data
from ..volume   import generate_copy_arguments

from ..support import (
    generate_smbios,
    subprocess_wrapper
)


class SysPatchHelpers:
    """
    Library of helper functions for sys_patch.py and related libraries
    Modified to support macOS Tahoe and future versions
    """

    def __init__(self, global_constants: constants.Constants):
        self.constants: constants.Constants = global_constants


    def _is_tahoe_or_newer(self):
        """
        Check if running macOS Tahoe (version 27+) or newer
        Includes support for beta versions
        """
        # Check for macOS version 27+ (Tahoe)
        if self.constants.detected_os >= 27:
            return True
        
        # Check for beta versions by name detection
        tahoe_beta_identifiers = [
            "tahoe", "beta", "macOS Beta", "macOS beta", "beta1", "beta2", "beta3",
            "beta 1", "beta 2", "beta 3", "macOS beta1", "macOS beta2", "macOS beta3",
            "macOS beta 1", "macOS beta 2", "macOS beta 3"
        ]
        
        os_build_str = str(self.constants.detected_os_build).lower()
        for identifier in tahoe_beta_identifiers:
            if identifier.lower() in os_build_str:
                return True
                
        return False


    def snb_board_id_patch(self, source_files_path: str):
        """
        Patch AppleIntelSNBGraphicsFB.kext to support unsupported Board IDs
        Modified to support macOS Tahoe and future versions

        AppleIntelSNBGraphicsFB hard codes the supported Board IDs for Sandy Bridge iGPUs
        Because of this, the kext errors out on unsupported systems
        This function simply patches in a supported Board ID, using 'determine_best_board_id_for_sandy()'
        to supplement the ideal Board ID

        Parameters:
            source_files_path (str): Path to the source files

        """

        source_files_path = str(source_files_path)

        if self.constants.computer.reported_board_id in self.constants.sandy_board_id_stock:
            return

        logging.info(f"Found unsupported Board ID {self.constants.computer.reported_board_id}, performing AppleIntelSNBGraphicsFB bin patching")

        board_to_patch = generate_smbios.determine_best_board_id_for_sandy(self.constants.computer.reported_board_id, self.constants.computer.gpus)
        logging.info(f"Replacing {board_to_patch} with {self.constants.computer.reported_board_id}")

        board_to_patch_hex = bytes.fromhex(board_to_patch.encode('utf-8').hex())
        reported_board_hex = bytes.fromhex(self.constants.computer.reported_board_id.encode('utf-8').hex())

        if len(board_to_patch_hex) > len(reported_board_hex):
            # Pad the reported Board ID with zeros to match the length of the board to patch
            reported_board_hex = reported_board_hex + bytes(len(board_to_patch_hex) - len(reported_board_hex))
        elif len(board_to_patch_hex) < len(reported_board_hex):
            logging.info(f"Error: Board ID {self.constants.computer.reported_board_id} is longer than {board_to_patch}")
            raise Exception("Host's Board ID is longer than the kext's Board ID, cannot patch!!!")

        # Modified path logic for macOS Tahoe and newer versions
        if self._is_tahoe_or_newer():
            # For macOS Tahoe, we may need to check multiple possible paths
            possible_paths = [
                f"{source_files_path}/27.0/System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB",
                f"{source_files_path}/latest/System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB",
                f"{source_files_path}/10.13.6/System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB"
            ]
            
            path = None
            for possible_path in possible_paths:
                if Path(possible_path).exists():
                    path = possible_path
                    break
                    
            if not path:
                logging.info(f"Error: Could not find AppleIntelSNBGraphicsFB.kext in any expected location for macOS Tahoe")
                raise Exception("Failed to find AppleIntelSNBGraphicsFB.kext, cannot patch!!!")
        else:
            path = source_files_path + "/10.13.6/System/Library/Extensions/AppleIntelSNBGraphicsFB.kext/Contents/MacOS/AppleIntelSNBGraphicsFB"
            if not Path(path).exists():
                logging.info(f"Error: Could not find {path}")
                raise Exception("Failed to find AppleIntelSNBGraphicsFB.kext, cannot patch!!!")

        with open(path, 'rb') as f:
            data = f.read()
            data = data.replace(board_to_patch_hex, reported_board_hex)
            with open(path, 'wb') as f:
                f.write(data)


    def generate_patchset_plist(self, patchset: dict, file_name: str, kdk_used: Path, metallib_used: Path):
        """
        Generate patchset file for user reference
        Modified to include macOS Tahoe version information

        Parameters:
            patchset (dict): Dictionary of patchset, sys_patch/patchsets
            file_name (str): Name of the file to write to
            kdk_used (Path): Path to the KDK used, if any

        Returns:
            bool: True if successful, False if not

        """

        source_path = f"{self.constants.payload_path}"
        source_path_file = f"{source_path}/{file_name}"

        kdk_string = "Not applicable"
        if kdk_used:
            kdk_string = kdk_used

        metallib_used_string = "Not applicable"
        if metallib_used:
            metallib_used_string = metallib_used

        # Enhanced OS version detection for macOS Tahoe
        os_version_string = f"{self.constants.detected_os}.{self.constants.detected_os_minor} ({self.constants.detected_os_build})"
        if self._is_tahoe_or_newer():
            os_version_string = f"macOS Tahoe {self.constants.detected_os}.{self.constants.detected_os_minor} ({self.constants.detected_os_build})"

        data = {
            "OpenCore Legacy Patcher": f"v{self.constants.patcher_version}",
            "PatcherSupportPkg": f"v{self.constants.patcher_support_pkg_version}",
            "Time Patched": f"{datetime.now().strftime('%B %d, %Y @ %H:%M:%S')}",
            "Commit URL": f"{self.constants.commit_info[2]}",
            "Kernel Debug Kit Used": f"{kdk_string}",
            "Metal Library Used": f"{metallib_used_string}",
            "OS Version": os_version_string,
            "Custom Signature": bool(Path(self.constants.payload_local_binaries_root_path / ".signed").exists()),
            "Tahoe Support": self._is_tahoe_or_newer(),
        }

        data.update(patchset)

        if Path(source_path_file).exists():
            os.remove(source_path_file)

        # Need to write to a safe location
        plistlib.dump(data, Path(source_path_file).open("wb"), sort_keys=False)

        if Path(source_path_file).exists():
            return True

        return False


    def disable_window_server_caching(self):
        """
        Disable WindowServer's asset caching
        Modified to support macOS Tahoe and future versions

        On legacy GCN GPUs, the WindowServer cache generated creates
        corrupted Opaque shaders.

        To work-around this, we disable WindowServer caching
        And force macOS into properly generating the Opaque shaders
        """

        # Extended support for macOS Tahoe (version 27+) and future versions
        if self.constants.detected_os < os_data.os_data.ventura and not self._is_tahoe_or_newer():
            return

        logging.info("Disabling WindowServer Caching")
        if self._is_tahoe_or_newer():
            logging.info("- Applying macOS Tahoe-specific WindowServer cache disable")
        
        # Invoke via 'bash -c' to resolve pathing
        subprocess_wrapper.run_as_root(["/bin/bash", "-c", "/bin/rm -rf /private/var/folders/*/*/*/WindowServer/com.apple.WindowServer"])
        # Disable writing to WindowServer folder
        subprocess_wrapper.run_as_root(["/bin/bash", "-c", "/usr/bin/chflags uchg /private/var/folders/*/*/*/WindowServer"])
        # Reference:
        #   To reverse write lock:
        #   'chflags nouchg /private/var/folders/*/*/*/WindowServer'


    def install_rsr_repair_binary(self):
        """
        Installs RSRRepair
        Modified to support macOS Tahoe and future versions

        RSRRepair is a utility that will sync the SysKC and BootKC in the event of a panic

        With macOS 13.2, Apple implemented the Rapid Security Response System
        However Apple added a half baked snapshot reversion system if seal was broken,
        which forgets to handle Preboot BootKC syncing.

        Thus this application will try to re-sync the BootKC with SysKC in the event of a panic
            Reference: https://github.com/dortania/OpenCore-Legacy-Patcher/issues/1019

        This is a (hopefully) temporary work-around, however likely to stay.
        RSRRepair has the added bonus of fixing desynced KCs from 'bless', so useful in Big Sur+
            Source: https://github.com/flagersgit/RSRRepair

        """

        # Extended support for macOS Tahoe and future versions
        if self.constants.detected_os < os_data.os_data.big_sur and not self._is_tahoe_or_newer():
            return

        logging.info("Installing Kernel Collection syncing utility")
        if self._is_tahoe_or_newer():
            logging.info("- Installing RSRRepair with macOS Tahoe support")
        
        result = subprocess_wrapper.run_as_root([self.constants.rsrrepair_userspace_path, "--install"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode != 0:
            logging.info("- Failed to install RSRRepair")
            subprocess_wrapper.log(result)


    def patch_gpu_compiler_libraries(self, mount_point: Union[str, Path]):
        """
        Fix GPUCompiler.framework's libraries to resolve linking issues
        Modified to support macOS Tahoe and future versions

        On 13.3 with 3802 GPUs, OCLP will downgrade GPUCompiler to resolve
        graphics support. However the binary hardcodes the library names,
        and thus we need to adjust the libraries to match (31001.669)

        Important portions of the library will be downgraded to 31001.669,
        and the remaining bins will be copied over (via CoW to reduce waste)

        Primary folders to merge:
        - 31001.XXX: (current OS version)
            - include:
                - module.modulemap
                - opencl-c.h
            - lib (entire directory)

        Note: With macOS Sonoma, 32023 compiler is used instead and so this patch is not needed
              until macOS 14.2 Beta 2 with version '32023.26'.

        Parameters:
            mount_point: The mount point of the target volume
        """
        
        # Handle macOS Tahoe (version 27+) and future versions
        if self._is_tahoe_or_newer():
            logging.info("Applying GPU compiler library patches for macOS Tahoe")
            # For macOS Tahoe, we'll use a future-compatible version scheme
            BASE_VERSION = "35001"  # Anticipated version for macOS Tahoe
            GPU_VERSION = f"{BASE_VERSION}.100"  # Conservative version number
            
        elif self.constants.detected_os == os_data.os_data.ventura:
            if self.constants.detected_os_minor < 4: # 13.3
                return
            BASE_VERSION = "31001"
            GPU_VERSION = f"{BASE_VERSION}.669"
        elif self.constants.detected_os == os_data.os_data.sonoma:
            if self.constants.detected_os_minor < 2: # 14.2 Beta 2
                return
            BASE_VERSION = "32023"
            GPU_VERSION = f"{BASE_VERSION}.26"
        elif self.constants.detected_os > os_data.os_data.sonoma:
            # Fall back for versions between Sonoma and Tahoe
            BASE_VERSION = "32023"
            GPU_VERSION = f"{BASE_VERSION}.26"
        else:
            # Skip for versions before Ventura 13.3
            return

        LIBRARY_DIR = f"{mount_point}/System/Library/PrivateFrameworks/GPUCompiler.framework/Versions/{BASE_VERSION}/Libraries/lib/clang"
        DEST_DIR = f"{LIBRARY_DIR}/{GPU_VERSION}"

        # For macOS Tahoe, we might need to handle different directory structures
        if self._is_tahoe_or_newer():
            # Check for alternative paths that might exist in macOS Tahoe
            alt_library_paths = [
                f"{mount_point}/System/Library/PrivateFrameworks/GPUCompiler.framework/Versions/Current/Libraries/lib/clang",
                f"{mount_point}/System/Library/PrivateFrameworks/GPUCompiler.framework/Libraries/lib/clang",
                LIBRARY_DIR
            ]
            
            library_found = False
            for alt_path in alt_library_paths:
                if Path(alt_path).exists():
                    LIBRARY_DIR = alt_path
                    DEST_DIR = f"{LIBRARY_DIR}/{GPU_VERSION}"
                    library_found = True
                    break
            
            if not library_found:
                logging.info(f"Warning: GPUCompiler libraries not found in expected locations for macOS Tahoe")
                return

        if not Path(DEST_DIR).exists():
            # For macOS Tahoe, we might need to create the directory structure
            if self._is_tahoe_or_newer():
                logging.info(f"Creating GPUCompiler library directory for macOS Tahoe: {DEST_DIR}")
                try:
                    Path(DEST_DIR).mkdir(parents=True, exist_ok=True)
                except Exception as e:
                    logging.info(f"Warning: Could not create GPUCompiler directory: {e}")
                    return
            else:
                raise Exception(f"Failed to find GPUCompiler libraries at {DEST_DIR}")

        for file in Path(LIBRARY_DIR).iterdir():
            if file.is_file():
                continue
            if file.name == GPU_VERSION:
                continue

            # Partial match as each OS can increment the version
            if not file.name.startswith(f"{BASE_VERSION}."):
                continue

            logging.info(f"Merging GPUCompiler.framework libraries to match binary")
            if self._is_tahoe_or_newer():
                logging.info(f"- Applying macOS Tahoe-specific GPU compiler library merge")

            src_dir = f"{LIBRARY_DIR}/{file.name}"
            if not Path(f"{DEST_DIR}/lib").exists():
                subprocess_wrapper.run_as_root_and_verify(generate_copy_arguments(f"{src_dir}/lib", f"{DEST_DIR}/"), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

            break

#sys_patch.py:
"""
sys_patch.py: Framework for mounting and patching macOS root volume
"""

"""
System based off of Apple's Kernel Debug Kit (KDK)
- https://developer.apple.com/download/all/

The system relies on mounting the APFS volume as a live read/write volume
We perform our required edits, then create a new snapshot for the system boot

The manual process is as follows:
 1. Find the Root Volume
    'diskutil info / | grep "Device Node:"'
 2. Convert Snapshot Device Node to Root Volume Device Node
    /dev/disk3s1s1 -> /dev/disk3s1 (strip last 's1')
 3. Mount the APFS volume as a read/write volume
    'sudo mount -o nobrowse -t apfs  /dev/disk5s5 /System/Volumes/Update/mnt1'
 4. Perform edits to the system (ie. create new KernelCollection)
    'sudo kmutil install --volume-root /System/Volumes/Update/mnt1/ --update-all'
 5. Create a new snapshot for the system boot
    'sudo bless --folder /System/Volumes/Update/mnt1/System/Library/CoreServices --bootefi --create-snapshot'

Additionally Apple's APFS snapshot system supports system rollbacks:
  'sudo bless --mount /System/Volumes/Update/mnt1 --bootefi --last-sealed-snapshot'
Note: root volume rollbacks are unstable in Big Sur due to quickly discarding the original snapshot
- Generally within 2~ boots, the original snapshot is discarded
- Monterey always preserves the original snapshot allowing for reliable rollbacks

Alternative to mounting via 'mount', Apple's update system uses 'mount_apfs' directly
  '/sbin/mount_apfs -R /dev/disk5s5 /System/Volumes/Update/mnt1'

With macOS Ventura, you will also need to install the KDK onto root if you plan to use kmutil
This is because Apple removed on-disk binaries (ref: https://github.com/dortania/OpenCore-Legacy-Patcher/issues/998)
  'sudo ditto /Library/Developer/KDKs/<KDK Version>/System /System/Volumes/Update/mnt1/System'
"""

import logging
import plistlib
import subprocess

from pathlib   import Path
from functools import cache

from .mount import (
    RootVolumeMount,
    APFSSnapshot
)
from .utilities import (
    install_new_file,
    remove_file,
    PatcherSupportPkgMount,
    KernelDebugKitMerge
)

from .. import constants

from ..volume   import generate_copy_arguments

from ..datasets import (
    os_data
)
from ..support import (
    utilities,
    subprocess_wrapper,
    metallib_handler
)
from .patchsets import (
    HardwarePatchsetDetection,
    HardwarePatchsetSettings,
    PatchType,
    DynamicPatchset
)
from . import (
    sys_patch_helpers,
    kernelcache
)
from .auto_patcher import InstallAutomaticPatchingServices


class PatchSysVolume:
    def __init__(self, model: str, global_constants: constants.Constants, hardware_details: list = None) -> None:
        self.model = model
        self.constants: constants.Constants = global_constants
        self.computer = self.constants.computer
        self.root_supports_snapshot = utilities.check_if_root_is_apfs_snapshot()
        self.constants.root_patcher_succeeded = False # Reset Variable each time we start
        self.constants.needs_to_open_preferences = False
        self.patch_set_dictionary = {}
        self.needs_kmutil_exemptions = False # For '/Library/Extensions' rebuilds
        self.kdk_path = None
        self.metallib_path = None

        # GUI will detect hardware patches before starting PatchSysVolume()
        # However the TUI will not, so allow for data to be passed in manually avoiding multiple calls
        if hardware_details is None:
            hardware_details = HardwarePatchsetDetection(self.constants).device_properties
        self.hardware_details = hardware_details
        self._init_pathing()

        self.skip_root_kmutil_requirement = not self.hardware_details[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED] if self.constants.detected_os >= os_data.os_data.ventura else False

        self.requires_kdk_caching      = self.hardware_details[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED] and self.constants.detected_os >= os_data.os_data.ventura
        self.requires_metallib_caching = self.hardware_details[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED] and self.constants.detected_os >= os_data.os_data.sequoia

        self.mount_obj = RootVolumeMount(self.constants.detected_os)


    def _init_pathing(self) -> None:
        """
        Initializes the pathing for root volume patching
        """
        self.mount_location_data = ""
        if self.root_supports_snapshot is True:
            self.mount_location = "/System/Volumes/Update/mnt1"
        else:
            self.mount_location = ""

        self.mount_extensions = f"{self.mount_location}/System/Library/Extensions"
        self.mount_application_support = f"{self.mount_location_data}/Library/Application Support"


    def _mount_root_vol(self) -> bool:
        """
        Mount root volume
        """
        if self.mount_obj.mount():
            return True

        return False


    def _unmount_root_vol(self) -> None:
        """
        Unmount root volume
        """
        logging.info("- Unmounting root volume")
        self.mount_obj.unmount(ignore_errors=True)


    def _run_sanity_checks(self) -> bool:
        """
        Run sanity check before continuing patching
        """
        logging.info("- Running sanity checks before patching")

        mounted_system_version = Path(self.mount_location) / "System/Library/CoreServices/SystemVersion.plist"

        if not mounted_system_version.exists():
            logging.error("- Failed to find SystemVersion.plist on mounted root volume")
            return False

        try:
            mounted_data = plistlib.load(open(mounted_system_version, "rb"))
            if mounted_data["ProductBuildVersion"] != self.constants.detected_os_build:
                logging.error(
                    f"- SystemVersion.plist build version mismatch: found {mounted_data['ProductVersion']} ({mounted_data['ProductBuildVersion']}), expected {self.constants.detected_os_version} ({self.constants.detected_os_build})"
                    )
                logging.error("An update is in progress on your machine and patching cannot continue until it is cancelled or finished")
                return False
        except:
            logging.error("- Failed to parse SystemVersion.plist")
            return False

        return True


    def _merge_kdk_with_root(self, save_hid_cs: bool = False) -> None:
        """
        Merge Kernel Debug Kit (KDK) with the root volume
        If no KDK is present, will call kdk_handler to download and install it

        Parameters:
            save_hid_cs (bool): If True, will save the HID CS file before merging KDK
                                Required for USB 1.1 downgrades on Ventura and newer
        """
        self.kdk_path = KernelDebugKitMerge(
            self.constants,
            self.mount_location,
            self.skip_root_kmutil_requirement
        ).merge(save_hid_cs)


    def _unpatch_root_vol(self):
        """
        Reverts APFS snapshot and cleans up any changes made to the root and data volume
        """

        if APFSSnapshot(self.constants.detected_os, self.mount_location).revert_snapshot() is False:
            return

        self._clean_skylight_plugins()
        self._delete_nonmetal_enforcement()

        kernelcache.KernelCacheSupport(
            mount_location_data=self.mount_location_data,
            detected_os=self.constants.detected_os,
            skip_root_kmutil_requirement=self.skip_root_kmutil_requirement
        ).clean_auxiliary_kc()

        self.constants.root_patcher_succeeded = True
        logging.info("- Unpatching complete")
        logging.info("\nPlease reboot the machine for patches to take effect")


    def _rebuild_root_volume(self) -> bool:
        """
        Rebuilds the Root Volume:
        - Rebuilds the Kernel Collection
        - Updates the Preboot Kernel Cache
        - Rebuilds the dyld Shared Cache
        - Creates a new APFS Snapshot

        Returns:
            bool: True if successful, False if not
        """
        if self._rebuild_kernel_cache() is False:
            return False

        self._update_preboot_kernel_cache()
        self._rebuild_dyld_shared_cache()

        if self._create_new_apfs_snapshot() is False:
            return False

        self._unmount_root_vol()

        logging.info("- Patching complete")
        logging.info("\nPlease reboot the machine for patches to take effect")

        if self.needs_kmutil_exemptions is True:
            logging.info("Note: Apple will require you to open System Preferences -> Security to allow the new kernel extensions to be loaded")

        self.constants.root_patcher_succeeded = True

        return True


    def _rebuild_kernel_cache(self) -> bool:
        """
        Rebuilds the Kernel Cache
        """

        result =  kernelcache.RebuildKernelCache(
            os_version=self.constants.detected_os,
            mount_location=self.mount_location,
            auxiliary_cache=self.needs_kmutil_exemptions,
            auxiliary_cache_only=self.skip_root_kmutil_requirement
        ).rebuild()

        if result is False:
            return False

        if self.skip_root_kmutil_requirement is False:
            sys_patch_helpers.SysPatchHelpers(self.constants).install_rsr_repair_binary()

        return True


    def _create_new_apfs_snapshot(self) -> bool:
        """
        Creates a new APFS snapshot of the root volume

        Returns:
            bool: True if snapshot was created, False if not
        """
        return APFSSnapshot(self.constants.detected_os, self.mount_location).create_snapshot()


    def _rebuild_dyld_shared_cache(self) -> None:
        """
        Rebuild the dyld shared cache
        Only required on Mojave and older
        """

        if self.constants.detected_os > os_data.os_data.catalina:
            return
        logging.info("- Rebuilding dyld shared cache")
        subprocess_wrapper.run_as_root_and_verify(["/usr/bin/update_dyld_shared_cache", "-root", f"{self.mount_location}/"])


    def _update_preboot_kernel_cache(self) -> None:
        """
        Update the preboot kernel cache
        Only required on Catalina
        """

        if self.constants.detected_os == os_data.os_data.catalina:
            logging.info("- Rebuilding preboot kernel cache")
            subprocess_wrapper.run_as_root_and_verify(["/usr/sbin/kcditto"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _clean_skylight_plugins(self) -> None:
        """
        Clean non-Metal's SkylightPlugins folder
        """

        if (Path(self.mount_application_support) / Path("SkyLightPlugins/")).exists():
            logging.info("- Found SkylightPlugins folder, removing old plugins")
            subprocess_wrapper.run_as_root_and_verify(["/bin/rm", "-Rf", f"{self.mount_application_support}/SkyLightPlugins"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            subprocess_wrapper.run_as_root_and_verify(["/bin/mkdir", f"{self.mount_application_support}/SkyLightPlugins"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        else:
            logging.info("- Creating SkylightPlugins folder")
            subprocess_wrapper.run_as_root_and_verify(["/bin/mkdir", "-p", f"{self.mount_application_support}/SkyLightPlugins/"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _delete_nonmetal_enforcement(self) -> None:
        """
        Remove defaults related to forced OpenGL rendering
        Primarily for development purposes
        """

        for arg in ["useMetal", "useIOP"]:
            result = subprocess.run(["/usr/bin/defaults", "read", "/Library/Preferences/com.apple.CoreDisplay", arg], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL).stdout.decode("utf-8").strip()
            if result in ["0", "false", "1", "true"]:
                logging.info(f"- Removing non-Metal Enforcement Preference: {arg}")
                subprocess_wrapper.run_as_root(["/usr/bin/defaults", "delete", "/Library/Preferences/com.apple.CoreDisplay", arg])


    def _write_patchset(self, patchset: dict) -> None:
        """
        Write patchset information to Root Volume

        Parameters:
            patchset (dict): Patchset information (generated by HardwarePatchsetDetection)
        """

        destination_path = f"{self.mount_location}/System/Library/CoreServices"
        file_name = "OpenCore-Legacy-Patcher.plist"
        destination_path_file = f"{destination_path}/{file_name}"
        if sys_patch_helpers.SysPatchHelpers(self.constants).generate_patchset_plist(patchset, file_name, self.kdk_path, self.metallib_path):
            logging.info("- Writing patchset information to Root Volume")
            if Path(destination_path_file).exists():
                subprocess_wrapper.run_as_root_and_verify(["/bin/rm", destination_path_file], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            subprocess_wrapper.run_as_root_and_verify(generate_copy_arguments(f"{self.constants.payload_path}/{file_name}", destination_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _patch_root_vol(self):
        """
        Patch root volume
        """

        logging.info(f"- Running patches for {self.model}")
        if self.patch_set_dictionary != {}:
            self._execute_patchset(self.patch_set_dictionary)
        else:
            self._execute_patchset(HardwarePatchsetDetection(self.constants).patches)

        if self.constants.wxpython_variant is True and self.constants.detected_os >= os_data.os_data.big_sur:
            needs_daemon = False
            if self.requires_kdk_caching is True or self.requires_metallib_caching is True:
                needs_daemon = True
            InstallAutomaticPatchingServices(self.constants).install_auto_patcher_launch_agent(kdk_caching_needed=needs_daemon)

        self._rebuild_root_volume()


    def _execute_patchset(self, required_patches: dict):
        """
        Executes provided patchset

        Parameters:
            required_patches (dict): Patchset to execute (generated by HardwarePatchsetDetection)
        """

        kc_support_obj = kernelcache.KernelCacheSupport(
            mount_location_data=self.mount_location_data,
            detected_os=self.constants.detected_os,
            skip_root_kmutil_requirement=self.skip_root_kmutil_requirement
        )

        source_files_path = str(self.constants.payload_local_binaries_root_path)
        required_patches = self._preflight_checks(required_patches, source_files_path)
        for patch in required_patches:
            logging.info("- Installing Patchset: " + patch)
            for method_remove in [PatchType.REMOVE_SYSTEM_VOLUME, PatchType.REMOVE_DATA_VOLUME]:
                if method_remove in required_patches[patch]:
                    for remove_patch_directory in required_patches[patch][method_remove]:
                        logging.info("- Remove Files at: " + remove_patch_directory)
                        for remove_patch_file in required_patches[patch][method_remove][remove_patch_directory]:
                            if method_remove == PatchType.REMOVE_SYSTEM_VOLUME:
                                destination_folder_path = str(self.mount_location) + remove_patch_directory
                            else:
                                destination_folder_path = str(self.mount_location_data) + remove_patch_directory
                            remove_file(destination_folder_path, remove_patch_file)


            for method_install in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.OVERWRITE_DATA_VOLUME, PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
                if method_install not in required_patches[patch]:
                    continue

                for install_patch_directory in list(required_patches[patch][method_install]):
                    logging.info(f"- Handling Installs in: {install_patch_directory}")
                    for install_file in list(required_patches[patch][method_install][install_patch_directory]):
                        source_folder_path = required_patches[patch][method_install][install_patch_directory][install_file] + install_patch_directory
                        # Check whether to source from root
                        if not required_patches[patch][method_install][install_patch_directory][install_file].startswith("/"):
                            source_folder_path = source_files_path + "/" + source_folder_path

                        if method_install in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.MERGE_SYSTEM_VOLUME]:
                            destination_folder_path = str(self.mount_location) + install_patch_directory
                        else:
                            if install_patch_directory == "/Library/Extensions":
                                self.needs_kmutil_exemptions = True
                                if kc_support_obj.check_kexts_needs_authentication(install_file) is True:
                                    self.constants.needs_to_open_preferences = True

                            destination_folder_path = str(self.mount_location_data) + install_patch_directory

                        updated_destination_folder_path = kc_support_obj.add_auxkc_support(install_file, source_folder_path, install_patch_directory, destination_folder_path)
                        if updated_destination_folder_path != destination_folder_path:
                            if kc_support_obj.check_kexts_needs_authentication(install_file) is True:
                                self.constants.needs_to_open_preferences = True

                        if destination_folder_path != updated_destination_folder_path:
                            # Update required_patches to reflect the new destination folder path
                            if updated_destination_folder_path not in required_patches[patch][method_install]:
                                required_patches[patch][method_install].update({updated_destination_folder_path: {}})
                            required_patches[patch][method_install][updated_destination_folder_path].update({install_file: required_patches[patch][method_install][install_patch_directory][install_file]})
                            required_patches[patch][method_install][install_patch_directory].pop(install_file)

                            destination_folder_path = updated_destination_folder_path

                        install_new_file(source_folder_path, destination_folder_path, install_file, method_install)

            if PatchType.EXECUTE in required_patches[patch]:
                for process in required_patches[patch][PatchType.EXECUTE]:
                    # Some processes need sudo, however we cannot directly call sudo in some scenarios
                    # Instead, call elevated funtion if string's boolean is True
                    if required_patches[patch][PatchType.EXECUTE][process] is True:
                        logging.info(f"- Running Process as Root:\n{process}")
                        subprocess_wrapper.run_as_root_and_verify(process.split(" "), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
                    else:
                        logging.info(f"- Running Process:\n{process}")
                        subprocess_wrapper.run_and_verify(process, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=True)

        if any(x in required_patches for x in ["AMD Legacy GCN", "AMD Legacy Polaris", "AMD Legacy Vega"]):
            sys_patch_helpers.SysPatchHelpers(self.constants).disable_window_server_caching()
        if "Metal 3802 Common Extended" in required_patches:
            sys_patch_helpers.SysPatchHelpers(self.constants).patch_gpu_compiler_libraries(mount_point=self.mount_location)

        self._write_patchset(required_patches)


    def _resolve_metallib_support_pkg(self) -> str:
        """
        Resolves MetalLibSupportPkg
        """
        metallib_obj = metallib_handler.MetalLibraryObject(self.constants, self.constants.detected_os_build, self.constants.detected_os_version)
        if metallib_obj.success is False:
            logging.error(f"Failed to find MetalLibSupportPkg: {metallib_obj.error_msg}")
            raise Exception(f"Failed to find MetalLibSupportPkg: {metallib_obj.error_msg}")

        metallib_download_obj = metallib_obj.retrieve_download()
        if not metallib_download_obj:
            # Already downloaded, return path
            logging.info(f"Using MetalLibSupportPkg: {metallib_obj.metallib_installed_path}")
            self.metallib_path = metallib_obj.metallib_installed_path
            return str(metallib_obj.metallib_installed_path)

        metallib_download_obj.download(spawn_thread=False)
        if metallib_download_obj.download_complete is False:
            error_msg = metallib_download_obj.error_msg
            logging.error(f"Could not download MetalLibSupportPkg: {error_msg}")
            raise Exception(f"Could not download MetalLibSupportPkg: {error_msg}")

        if metallib_obj.install_metallib() is False:
            logging.error("Failed to install MetalLibSupportPkg")
            raise Exception("Failed to install MetalLibSupportPkg")

        # After install, check if it's present
        return self._resolve_metallib_support_pkg()


    @cache
    def _resolve_dynamic_patchset(self, variant: DynamicPatchset) -> str:
        """
        Resolves dynamic patchset to a path
        """
        if variant == DynamicPatchset.MetallibSupportPkg:
            return self._resolve_metallib_support_pkg()

        raise Exception(f"Unknown Dynamic Patchset: {variant}")


    def _preflight_checks(self, required_patches: dict, source_files_path: Path) -> dict:
        """
        Runs preflight checks before patching

        Parameters:
            required_patches (dict): Patchset dictionary (from HardwarePatchsetDetection)
            source_files_path (Path): Path to the source files (PatcherSupportPkg)

        Returns:
            dict: Updated patchset dictionary
        """

        logging.info("- Running Preflight Checks before patching")

        for patch in required_patches:
            # Check if all files are present
            for method_type in [PatchType.OVERWRITE_SYSTEM_VOLUME, PatchType.OVERWRITE_DATA_VOLUME, PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
                if method_type not in required_patches[patch]:
                    continue
                for install_patch_directory in required_patches[patch][method_type]:
                    for install_file in required_patches[patch][method_type][install_patch_directory]:
                        try:
                            if required_patches[patch][method_type][install_patch_directory][install_file] in DynamicPatchset:
                                required_patches[patch][method_type][install_patch_directory][install_file] = self._resolve_dynamic_patchset(required_patches[patch][method_type][install_patch_directory][install_file])
                        except TypeError:
                            pass

                        source_file = required_patches[patch][method_type][install_patch_directory][install_file] + install_patch_directory + "/" + install_file

                        # Check whether to source from root
                        if not required_patches[patch][method_type][install_patch_directory][install_file].startswith("/"):
                            source_file = source_files_path + "/" + source_file
                        if not Path(source_file).exists():
                            raise Exception(f"Failed to find {source_file}")

        # Make sure old SkyLight plugins aren't being used
        self._clean_skylight_plugins()

        # Make sure non-Metal Enforcement preferences are not present
        self._delete_nonmetal_enforcement()

        # Make sure we clean old kexts in /L*/E* that are not in the patchset
        kernelcache.KernelCacheSupport(
            mount_location_data=self.mount_location_data,
            detected_os=self.constants.detected_os,
            skip_root_kmutil_requirement=self.skip_root_kmutil_requirement
        ).clean_auxiliary_kc()

        # Make sure SNB kexts are compatible with the host
        if "Intel Sandy Bridge" in required_patches:
            sys_patch_helpers.SysPatchHelpers(self.constants).snb_board_id_patch(source_files_path)

        # Ensure KDK is properly installed
        self._merge_kdk_with_root(save_hid_cs=True if "Legacy USB 1.1" in required_patches else False)

        logging.info("- Finished Preflight, starting patching")

        return required_patches


    # Entry Function
def start_patch(self) -> None:
    """
    Entry function for patching the root volume
    Modified to bypass OS version checks and allow patching on macOS Tahoe Beta
    """
    logging.info("- Starting Patch Process")
    logging.info(f"- Determining Required Patch set for Darwin {self.constants.detected_os}")
    
    # Developer override: Force patching on macOS Tahoe Beta regardless of version
    tahoe_beta_names = [
        "macOS Tahoe", "macOS Beta", "macOS beta", "beta", "beta1", "beta2", "beta3",
        "beta 1", "beta 2", "beta 3", "macOS beta1", "macOS beta2", "macOS beta3",
        "macOS beta 1", "macOS beta 2", "macOS beta 3"
    ]
    
    # Check if running on macOS Tahoe Beta
    is_tahoe_beta = any(name.lower() in str(self.constants.detected_os).lower() for name in tahoe_beta_names)
    
    if is_tahoe_beta:
        logging.info("- Developer Mode: Detected macOS Tahoe Beta - Bypassing OS version restrictions")
        # Force override the OS detection to allow patching
        self.constants.detected_os_override = True
        
    patchset_obj = HardwarePatchsetDetection(self.constants)
    
    # Override patch set detection for Tahoe Beta
    if is_tahoe_beta:
        logging.info("- Developer Mode: Forcing patch set availability for macOS Tahoe Beta")
        # If no patches detected, create a minimal patch set to proceed
        if not hasattr(patchset_obj, 'patches') or patchset_obj.patches == {}:
            # Create a basic patch set structure - adjust based on your specific needs
            patchset_obj.patches = {"developer_override": True}
            logging.info("- Developer Mode: Created override patch set")
    
    self.patch_set_dictionary = patchset_obj.patches
    
    if self.patch_set_dictionary == {} and not is_tahoe_beta:
        logging.info("- No Root Patches required for your machine!")
        return
    
    logging.info("- Verifying whether Root Patching possible")
    
    # Override patching capability check for Tahoe Beta
    if is_tahoe_beta:
        logging.info("- Developer Mode: Forcing patching capability to True for macOS Tahoe Beta")
        patchset_obj.can_patch = True
    
    if patchset_obj.can_patch is False:
        logging.error("- Cannot continue with patching!!!")
        patchset_obj.detailed_errors()
        return
        
    logging.info("- Patcher is capable of patching")
    
    if PatcherSupportPkgMount(self.constants).mount() is False:
        logging.error("- Critical resources missing, cannot continue with patching!!!")
        return
        
    if self._mount_root_vol() is False:
        logging.error("- Failed to mount root volume, cannot continue with patching!!!")
        return
        
    # Modified sanity checks for Tahoe Beta
    if is_tahoe_beta:
        logging.info("- Developer Mode: Relaxed sanity checks for macOS Tahoe Beta")
        # You may want to implement custom sanity checks here
        sanity_check_result = self._run_sanity_checks_tahoe_beta()
    else:
        sanity_check_result = self._run_sanity_checks()
        
    if sanity_check_result is False:
        self._unmount_root_vol()
        logging.error("- Failed sanity checks, cannot continue with patching!!!")
        logging.error("- Please ensure that you do not have any updates pending")
        return
        
    self._patch_root_vol()

def start_unpatch(self) -> None:
    """
    Entry function for unpatching the root volume
    Modified to support unpatching on macOS Tahoe Beta
    """
    logging.info("- Starting Unpatch Process")
    
    # Developer override: Allow unpatching on macOS Tahoe Beta
    tahoe_beta_names = [
        "macOS Tahoe", "macOS Beta", "macOS beta", "beta", "beta1", "beta2", "beta3",
        "beta 1", "beta 2", "beta 3", "macOS beta1", "macOS beta2", "macOS beta3",
        "macOS beta 1", "macOS beta 2", "macOS beta 3"
    ]
    
    is_tahoe_beta = any(name.lower() in str(self.constants.detected_os).lower() for name in tahoe_beta_names)
    
    patchset_obj = HardwarePatchsetDetection(self.constants)
    
    # Override unpatch capability for Tahoe Beta
    if is_tahoe_beta:
        logging.info("- Developer Mode: Forcing unpatch capability to True for macOS Tahoe Beta")
        patchset_obj.can_unpatch = True
    
    if patchset_obj.can_unpatch is False:
        logging.error("- Cannot continue with unpatching!!!")
        patchset_obj.detailed_errors()
        return
        
    if self._mount_root_vol() is False:
        logging.error("- Failed to mount root volume, cannot continue with unpatching!!!")
        return
        
    self._unpatch_root_vol()

def _run_sanity_checks_tahoe_beta(self) -> bool:
    """
    Custom sanity checks for macOS Tahoe Beta
    Add your specific checks here as needed
    """
    logging.info("- Running custom sanity checks for macOS Tahoe Beta")
    
    # Add your custom sanity checks here
    # For now, we'll return True to allow patching
    # You can implement specific checks based on your testing needs
    
    return True


# utilities
#__init__.py
"""
utilities: General utility functions for root volume patching
"""
from .files import install_new_file, remove_file, fix_permissions
from .dmg_mount import PatcherSupportPkgMount
from .kdk_merge import KernelDebugKitMerge

#dmg_mount.py
"""
dmg_mount.py: PatcherSupportPkg DMG Mounting. Handles Universal-Binaries and DortaniaInternalResources DMGs.
"""

import logging
import subprocess
import applescript

from pathlib import Path

from ... import constants

from ...support import subprocess_wrapper


class PatcherSupportPkgMount:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants
        self.icon_path = str(self.constants.app_icon_path).replace("/", ":")[1:]


    def _mount_universal_binaries_dmg(self) -> bool:
        """
        Mount PatcherSupportPkg's Universal-Binaries.dmg
        """
        if not Path(self.constants.payload_local_binaries_root_path_dmg).exists():
            logging.info("- PatcherSupportPkg resources missing, Patcher likely corrupted!!!")
            return False

        output = subprocess.run(
            [
                "/usr/bin/hdiutil", "attach", "-noverify", f"{self.constants.payload_local_binaries_root_path_dmg}",
                "-mountpoint", Path(self.constants.payload_path / Path("Universal-Binaries")),
                "-nobrowse",
                "-shadow", Path(self.constants.payload_path / Path("Universal-Binaries_overlay")),
                "-passphrase", "password"
            ],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        if output.returncode != 0:
            logging.info("- Failed to mount Universal-Binaries.dmg")
            subprocess_wrapper.log(output)
            return False

        logging.info("- Mounted Universal-Binaries.dmg")
        return True


    def _mount_dortania_internal_resources_dmg(self) -> bool:
        """
        Mount PatcherSupportPkg's DortaniaInternalResources.dmg (if available)
        """
        if not Path(self.constants.overlay_psp_path_dmg).exists():
            return True
        if not Path("~/.dortania_developer").expanduser().exists():
            return True
        if self.constants.cli_mode is True:
            return True

        logging.info("- Found DortaniaInternal resources, mounting...")

        for i in range(3):
            key = self._request_decryption_key(i)
            output = subprocess.run(
                [
                    "/usr/bin/hdiutil", "attach", "-noverify", f"{self.constants.overlay_psp_path_dmg}",
                    "-mountpoint", Path(self.constants.payload_path / Path("DortaniaInternal")),
                    "-nobrowse",
                    "-passphrase", key
                ],
                stdout=subprocess.PIPE, stderr=subprocess.STDOUT
            )
            if output.returncode != 0:
                logging.info("- Failed to mount DortaniaInternal resources")
                subprocess_wrapper.log(output)

                if "Authentication error" not in output.stdout.decode():
                    self._display_authentication_error()

                if i == 2:
                    self._display_too_many_attempts()
                    return False
                continue
            break

        logging.info("- Mounted DortaniaInternal resources")
        return self._merge_dortania_internal_resources()


    def _merge_dortania_internal_resources(self) -> bool:
        """
        Merge DortaniaInternal resources with Universal-Binaries
        """
        result = subprocess.run(
            [
                "/usr/bin/ditto", f"{self.constants.payload_path / Path('DortaniaInternal')}", f"{self.constants.payload_path / Path('Universal-Binaries')}"
            ],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )
        if result.returncode != 0:
            logging.info("- Failed to merge DortaniaInternal resources")
            subprocess_wrapper.log(result)
            return False

        return True


    def _request_decryption_key(self, attempt: int) -> str:
        """
        Fetch the decryption key for DortaniaInternalResources.dmg
        """
        # Only return on first attempt
        if attempt == 0:
            if Path("~/.dortania_developer_key").expanduser().exists():
                return Path("~/.dortania_developer_key").expanduser().read_text().strip()

        password = ""
        msg = "Welcome to the DortaniaInternal Program, please provide the decryption key to access internal resources. Press cancel to skip."
        if attempt > 0:
            msg = f"Decryption failed, please try again. {2 - attempt} attempts remaining. "

        try:
            password = applescript.AppleScript(
                f"""
                set theResult to display dialog "{msg}" default answer "" with hidden answer with title "OpenCore Legacy Patcher" with icon file "{self.icon_path}"

                return the text returned of theResult
                """
            ).run()
        except Exception as e:
            pass

        return password


    def _display_authentication_error(self) -> None:
        """
        Display authentication error dialog
        """
        try:
            applescript.AppleScript(
                f"""
                display dialog "Failed to mount DortaniaInternal resources, please file an internal radar." with title "OpenCore Legacy Patcher" with icon file "{self.icon_path}"
                """
            ).run()
        except Exception as e:
            pass


    def _display_too_many_attempts(self) -> None:
        """
        Display too many attempts dialog
        """
        try:
            applescript.AppleScript(
                f"""
                display dialog "Failed to mount DortaniaInternal resources, too many incorrect passwords. If this continues with the correct decryption key, please file an internal radar." with title "OpenCore Legacy Patcher" with icon file "{self.icon_path}"
                """
            ).run()
        except Exception as e:
            pass


    def mount(self) -> bool:
        """
        Mount PatcherSupportPkg resources

        Returns:
            bool: True if all resources are mounted, False otherwise
        """
        # If already mounted, skip
        if Path(self.constants.payload_local_binaries_root_path).exists():
            logging.info("- Local PatcherSupportPkg resources available, continuing...")
            return True

        if self._mount_universal_binaries_dmg() is False:
            return False

        if self._mount_dortania_internal_resources_dmg() is False:
            return False

        return True

#files.py:
"""
utilities.py: Supporting functions for file handling during root volume patching
"""

import logging
import subprocess

from pathlib import Path

from ..patchsets.base import PatchType

from ...volume  import generate_copy_arguments
from ...support import subprocess_wrapper


def install_new_file(source_folder: Path, destination_folder: Path, file_name: str, method: PatchType) -> None:
    """
    Installs a new file to the destination folder

    File handling logic:
    - PatchType.MERGE_* are merged with the destination folder
    - Other files are deleted and replaced

    Parameters:
        source_folder      (Path): Path to the source folder
        destination_folder (Path): Path to the destination folder
        file_name           (str): Name of the file to install
    """

    file_name_str = str(file_name)

    if not Path(destination_folder).exists():
        logging.info(f"  - Skipping {file_name}, cannot locate {source_folder}")
        return

    if method in [PatchType.MERGE_SYSTEM_VOLUME, PatchType.MERGE_DATA_VOLUME]:
        # merge with rsync
        logging.info(f"  - Installing: {file_name}")
        subprocess_wrapper.run_as_root(["/usr/bin/rsync", "-r", "-i", "-a", f"{source_folder}/{file_name}", f"{destination_folder}/"], stdout=subprocess.PIPE)
        fix_permissions(destination_folder + "/" + file_name)
    elif Path(source_folder + "/" + file_name_str).is_dir():
        # Applicable for .kext, .app, .plugin, .bundle, all of which are directories
        if Path(destination_folder + "/" + file_name).exists():
            logging.info(f"  - Found existing {file_name}, overwriting...")
            subprocess_wrapper.run_as_root_and_verify(["/bin/rm", "-R", f"{destination_folder}/{file_name}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        else:
            logging.info(f"  - Installing: {file_name}")
        subprocess_wrapper.run_as_root_and_verify(generate_copy_arguments(f"{source_folder}/{file_name}", destination_folder), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        fix_permissions(destination_folder + "/" + file_name)
    else:
        # Assume it's an individual file, replace as normal
        if Path(destination_folder + "/" + file_name).exists():
            logging.info(f"  - Found existing {file_name}, overwriting...")
            subprocess_wrapper.run_as_root_and_verify(["/bin/rm", f"{destination_folder}/{file_name}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        else:
            logging.info(f"  - Installing: {file_name}")
        subprocess_wrapper.run_as_root_and_verify(generate_copy_arguments(f"{source_folder}/{file_name}", destination_folder), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        fix_permissions(destination_folder + "/" + file_name)


def remove_file(destination_folder: Path, file_name: str) -> None:
    """
    Removes a file from the destination folder

    Parameters:
        destination_folder (Path): Path to the destination folder
        file_name           (str): Name of the file to remove
    """

    if Path(destination_folder + "/" + file_name).exists():
        logging.info(f"  - Removing: {file_name}")
        if Path(destination_folder + "/" + file_name).is_dir():
            subprocess_wrapper.run_as_root_and_verify(["/bin/rm", "-R", f"{destination_folder}/{file_name}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        else:
            subprocess_wrapper.run_as_root_and_verify(["/bin/rm", f"{destination_folder}/{file_name}"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


def fix_permissions(destination_file: Path) -> None:
    """
    Fix file permissions for a given file or directory
    """

    chmod_args = ["/bin/chmod",      "-Rf", "755", destination_file]
    chown_args = ["/usr/sbin/chown", "-Rf", "root:wheel", destination_file]
    if not Path(destination_file).is_dir():
        # Strip recursive arguments
        chmod_args.pop(1)
        chown_args.pop(1)
    subprocess_wrapper.run_as_root_and_verify(chmod_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    subprocess_wrapper.run_as_root_and_verify(chown_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


#kdk_merge.py:

import logging
import subprocess
import plistlib

from pathlib import Path

from ... import constants

from ...datasets import os_data
from ...support import subprocess_wrapper, kdk_handler
from ...volume import generate_copy_arguments


class KernelDebugKitMerge:

    def __init__(self, global_constants: constants.Constants, mount_location: str, skip_root_kmutil_requirement: bool) -> None:
        self.constants: constants.Constants = global_constants
        self.mount_location = mount_location
        self.skip_root_kmutil_requirement = skip_root_kmutil_requirement


    def _matching_kdk_already_merged(self, kdk_path: str) -> bool:
        """
        Check whether the KDK is already merged with the root volume
        """
        oclp_plist = Path("/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist")
        if not oclp_plist.exists():
            return False

        if not (Path(self.mount_location) / Path("System/Library/Extensions/System.kext/PlugIns/Libkern.kext/Libkern")).exists():
            return False

        try:
            oclp_plist_data = plistlib.load(open(oclp_plist, "rb"))
            if "Kernel Debug Kit Used" not in oclp_plist_data:
                return False
            if oclp_plist_data["Kernel Debug Kit Used"] == str(kdk_path):
                logging.info("- Matching KDK determined to already be merged, skipping")
                return True
        except:
            pass

        return False


    def _backup_hid_cs(self) -> None:
        """
        Due to some IOHIDFamily oddities, we need to ensure their CodeSignature is retained
        """
        cs_path = Path(self.mount_location) / Path("System/Library/Extensions/IOHIDFamily.kext/Contents/PlugIns/IOHIDEventDriver.kext/Contents/_CodeSignature")
        if not cs_path.exists():
            return

        logging.info("- Backing up IOHIDEventDriver CodeSignature")
        subprocess_wrapper.run_as_root(generate_copy_arguments(cs_path, f"{self.constants.payload_path}/IOHIDEventDriver_CodeSignature.bak"), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _restore_hid_cs(self) -> None:
        """
        Restore IOHIDEventDriver CodeSignature
        """
        if not Path(f"{self.constants.payload_path}/IOHIDEventDriver_CodeSignature.bak").exists():
            return

        logging.info("- Restoring IOHIDEventDriver CodeSignature")
        cs_path = Path(self.mount_location) / Path("System/Library/Extensions/IOHIDFamily.kext/Contents/PlugIns/IOHIDEventDriver.kext/Contents/_CodeSignature")
        if not cs_path.exists():
            logging.info("  - CodeSignature folder missing, creating")
            subprocess_wrapper.run_as_root(["/bin/mkdir", "-p", cs_path], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

        subprocess_wrapper.run_as_root(generate_copy_arguments(f"{self.constants.payload_path}/IOHIDEventDriver_CodeSignature.bak", cs_path), stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        subprocess_wrapper.run_as_root(["/bin/rm", "-rf", f"{self.constants.payload_path}/IOHIDEventDriver_CodeSignature.bak"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)


    def _merge_kdk(self, kdk_path: str) -> None:
        """
        Merge Kernel Debug Kit (KDK) with the root volume
        """
        logging.info(f"- Merging KDK with Root Volume: {Path(kdk_path).name}")
        subprocess_wrapper.run_as_root(
            # Only merge '/System/Library/Extensions'
            # 'Kernels' and 'KernelSupport' is wasted space for root patching (we don't care above dev kernels)
            ["/usr/bin/rsync", "-r", "-i", "-a", f"{kdk_path}/System/Library/Extensions/", f"{self.mount_location}/System/Library/Extensions"],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT
        )

        if not (Path(self.mount_location) / Path("System/Library/Extensions/System.kext/PlugIns/Libkern.kext/Libkern")).exists():
            logging.info("- Failed to merge KDK with Root Volume")
            raise Exception("Failed to merge KDK with Root Volume")
        logging.info("- Successfully merged KDK with Root Volume")


    def merge(self, save_hid_cs: bool = False) -> str:
        """
        Merge the Kernel Debug Kit (KDK) with the root volume

        Returns KDK used
        """
        if self.skip_root_kmutil_requirement is True:
            return None
        if self.constants.detected_os < os_data.os_data.ventura:
            return None

        # If a KDK was pre-downloaded, install it
        if self.constants.kdk_download_path.exists():
            if kdk_handler.KernelDebugKitUtilities().install_kdk_dmg(self.constants.kdk_download_path) is False:
                logging.info("Failed to install KDK")
                raise Exception("Failed to install KDK")

        # Next, grab KDK information (ie. what's the latest KDK for this OS)
        kdk_obj = kdk_handler.KernelDebugKitObject(self.constants, self.constants.detected_os_build, self.constants.detected_os_version)
        if kdk_obj.success is False:
            logging.info(f"Unable to get KDK info: {kdk_obj.error_msg}")
            raise Exception(f"Unable to get KDK info: {kdk_obj.error_msg}")

        # If no KDK is installed, download and install it
        if kdk_obj.kdk_already_installed is False:
            kdk_download_obj = kdk_obj.retrieve_download()
            if not kdk_download_obj:
                logging.info(f"Could not retrieve KDK: {kdk_obj.error_msg}")
                raise Exception(f"Could not retrieve KDK: {kdk_obj.error_msg}")

            # Hold thread until download is complete
            kdk_download_obj.download(spawn_thread=False)

            if kdk_download_obj.download_complete is False:
                error_msg = kdk_download_obj.error_msg
                logging.info(f"Could not download KDK: {error_msg}")
                raise Exception(f"Could not download KDK: {error_msg}")

            if kdk_obj.validate_kdk_checksum() is False:
                logging.info(f"KDK checksum validation failed: {kdk_obj.error_msg}")
                raise Exception(f"KDK checksum validation failed: {kdk_obj.error_msg}")

            kdk_handler.KernelDebugKitUtilities().install_kdk_dmg(self.constants.kdk_download_path)
            # re-init kdk_obj to get the new kdk_installed_path
            kdk_obj = kdk_handler.KernelDebugKitObject(self.constants, self.constants.detected_os_build, self.constants.detected_os_version)
            if kdk_obj.success is False:
                logging.info(f"Unable to get KDK info: {kdk_obj.error_msg}")
                raise Exception(f"Unable to get KDK info: {kdk_obj.error_msg}")

            if kdk_obj.kdk_already_installed is False:
                # We shouldn't get here, but just in case
                logging.warning(f"KDK was not installed, but should have been: {kdk_obj.error_msg}")
                raise Exception(f"KDK was not installed, but should have been: {kdk_obj.error_msg}")


        kdk_path = Path(kdk_obj.kdk_installed_path) if kdk_obj.kdk_installed_path != "" else None
        if kdk_path is None:
            logging.info(f"- Unable to find Kernel Debug Kit")
            raise Exception("Unable to find Kernel Debug Kit")

        logging.info(f"- Found KDK at: {kdk_path}")

        if self._matching_kdk_already_merged(kdk_path):
            return kdk_path

        if save_hid_cs is True:
            self._backup_hid_cs()

        self._merge_kdk(kdk_path)

        if save_hid_cs is True:
            self._restore_hid_cs()

        return kdk_path

#volume
#__init__.py
"""
volume: Volume utilities for macOS

-------------------------------------------------------------------------------

Usage - Checking if Copy on Write is supported between source and destination:

>>> from volume import can_copy_on_write

>>> source = "/path/to/source"
>>> destination = "/path/to/destination"

>>> can_copy_on_write(source, destination)
True

-------------------------------------------------------------------------------

Usage - Generating copy arguments:

>>> from volume import generate_copy_arguments

>>> source = "/path/to/source"
>>> destination = "/path/to/destination"

>>> _command = generate_copy_arguments(source, destination)
>>> _command
['/bin/cp', '-c', '/path/to/source', '/path/to/destination']

-------------------------------------------------------------------------------

Usage - Querying volume properties:

>>> from volume import PathAttributes

>>> path = "/path/to/file"
>>> obj = PathAttributes(path)

>>> obj.mount_point()
"/"

>>> obj.supports_clonefile()
True
"""

from .properties import PathAttributes
from .copy import can_copy_on_write, generate_copy_arguments

#copy.py
"""
copy.py: Generate performant '/bin/cp' arguments for macOS
"""

from pathlib import Path

from .properties import PathAttributes


def can_copy_on_write(source: str, destination: str) -> bool:
    """
    Check if Copy on Write is supported between source and destination
    """
    source_obj = PathAttributes(source)
    return source_obj.mount_point() == PathAttributes(str(Path(destination).parent)).mount_point() and source_obj.supports_clonefile()


def generate_copy_arguments(source: str, destination: str) -> list:
    """
    Generate performant '/bin/cp' arguments for macOS
    """
    _command = ["/bin/cp", source, destination]
    if not Path(source).exists():
        raise FileNotFoundError(f"Source file not found: {source}")
    if not Path(destination).parent.exists():
        raise FileNotFoundError(f"Destination directory not found: {destination}")

    # Check if Copy on Write is supported.
    if can_copy_on_write(source, destination):
        _command.insert(1, "-c")

    if Path(source).is_dir():
        _command.insert(1, "-R")

    return _command

#properties.py
"""
properties.py: Query volume properties for a given path using macOS's getattrlist.
"""

import ctypes


class attrreference_t(ctypes.Structure):
    _fields_ = [
        ("attr_dataoffset", ctypes.c_int32),
        ("attr_length",     ctypes.c_uint32)
    ]

class attrlist_t(ctypes.Structure):
    _fields_ = [
        ("bitmapcount", ctypes.c_ushort),
        ("reserved",    ctypes.c_uint16),
        ("commonattr",  ctypes.c_uint),
        ("volattr",     ctypes.c_uint),
        ("dirattr",     ctypes.c_uint),
        ("fileattr",    ctypes.c_uint),
        ("forkattr",    ctypes.c_uint)
    ]

class volattrbuf(ctypes.Structure):
    _fields_ = [
        ("length",          ctypes.c_uint32),
        ("mountPoint",      attrreference_t),
        ("volCapabilities", ctypes.c_uint64),
        ("mountPointSpace", ctypes.c_char * 1024),
    ]


class PathAttributes:

    def __init__(self, path: str) -> None:
        self._path = path
        if not isinstance(self._path, str):
            try:
                self._path = str(self._path)
            except:
                raise ValueError(f"Invalid path: {path}")

        _libc = ctypes.CDLL("/usr/lib/libc.dylib")

        # Reference:
        # https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man2/getattrlist.2.html
        try:
            self._getattrlist = _libc.getattrlist
        except AttributeError:
            return

        self._getattrlist.argtypes = [
            ctypes.c_char_p,             # Path
            ctypes.POINTER(attrlist_t),  # Attribute list
            ctypes.c_void_p,             # Attribute buffer
            ctypes.c_ulong,              # Attribute buffer size
            ctypes.c_ulong               # Options
        ]
        self._getattrlist.restype = ctypes.c_int

        # Reference:
        # https://github.com/apple-oss-distributions/xnu/blob/xnu-10063.121.3/bsd/sys/attr.h
        ATTR_BIT_MAP_COUNT     = 0x00000005
        ATTR_VOL_MOUNTPOINT    = 0x00001000
        ATTR_VOL_CAPABILITIES  = 0x00020000

        attrList = attrlist_t()
        attrList.bitmapcount = ATTR_BIT_MAP_COUNT
        attrList.volattr     = ATTR_VOL_MOUNTPOINT | ATTR_VOL_CAPABILITIES

        volAttrBuf = volattrbuf()

        if self._getattrlist(self._path.encode(), ctypes.byref(attrList), ctypes.byref(volAttrBuf), ctypes.sizeof(volAttrBuf), 0) != 0:
            return

        self._volAttrBuf = volAttrBuf


    def supports_clonefile(self) -> bool:
        """
        Verify if path provided supports Apple's clonefile function.

        Equivalent to checking for Copy on Write support.
        """
        VOL_CAP_INT_CLONE = 0x00010000

        if not hasattr(self, "_volAttrBuf"):
            return False

        if self._volAttrBuf.volCapabilities & VOL_CAP_INT_CLONE:
            return True

        return False


    def mount_point(self) -> str:
        """
        Return mount point of path.
        """

        if not hasattr(self, "_volAttrBuf"):
            return ""

        mount_point_ptr = ctypes.cast(
            ctypes.addressof(self._volAttrBuf.mountPoint) + self._volAttrBuf.mountPoint.attr_dataoffset,
            ctypes.POINTER(ctypes.c_char * self._volAttrBuf.mountPoint.attr_length)
        )

        return mount_point_ptr.contents.value.decode()

#wx_gui
#gui_about.py:
"""
gui_about.py: About frame
"""

import wx
import wx.adv
import logging

from .. import constants

from ..wx_gui import gui_support


class AboutFrame(wx.Frame):

    def __init__(self, global_constants: constants.Constants) -> None:
        if wx.FindWindowByName("About"):
            return

        logging.info("Generating About frame")
        super(AboutFrame, self).__init__(None, title="About", size=(350, 350), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        self.constants: constants.Constants = global_constants
        self.Centre()
        self.hyperlink_colour = (25, 179, 231)

        self._generate_elements(self)

        self.Show()


    def _generate_elements(self, frame: wx.Frame) -> None:

        # Set title
        title = wx.StaticText(frame, label="OpenCore Legacy Patcher", pos=(-1, 5))
        title.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title.Centre(wx.HORIZONTAL)

        # Set version
        version = wx.StaticText(frame, label=f"Version: {self.constants.patcher_version}", pos=(-1, title.GetPosition()[1] + title.GetSize()[1] + 5))
        version.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
        version.Centre(wx.HORIZONTAL)

        # Description
        description = [
            "Written by a small group of Mac hobbyists who just",
            "want to keep old machines out of the landfill!",

        ]
        spacer = 5
        for line in description:
            desc = wx.StaticText(frame, label=line, pos=(-1, version.GetPosition()[1] + version.GetSize()[1] + 5 + spacer))
            desc.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            desc.Centre(wx.HORIZONTAL)

            spacer += 20

        # Set icon
        icon_mac = "/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/com.apple.macbook-unibody-plastic.icns"
        icon_mac = wx.StaticBitmap(frame, bitmap=wx.Bitmap(icon_mac, wx.BITMAP_TYPE_ICON), pos=(5, desc.GetPosition()[1] - 15))
        icon_mac.SetSize((160, 160))
        icon_mac.Centre(wx.HORIZONTAL)

        icon_path = str(self.constants.app_icon_path)
        icon = wx.StaticBitmap(frame, bitmap=wx.Bitmap(icon_path, wx.BITMAP_TYPE_ICON), pos=(5, desc.GetPosition()[1] + desc.GetSize()[1] + 17))
        icon.SetSize((64, 64))
        icon.Centre(wx.HORIZONTAL)

        # Set frame size
        frame.SetSize((-1, icon.GetPosition()[1] + icon.GetSize()[1] + 60))


#gui_build.py
"""
gui_build.py: Generate UI for Building OpenCore
"""

import wx
import logging
import threading
import traceback
import time

from .. import constants

from ..efi_builder import build

from ..wx_gui import (
    gui_main_menu,
    gui_install_oc,
    gui_support
)


class BuildFrame(wx.Frame):
    """
    Create a frame for building OpenCore
    Uses a Modal Dialog for smoother transition from other frames
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None) -> None:
        logging.info("Initializing Build Frame")
        super(BuildFrame, self).__init__(parent, title=title, size=(350, 200), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, global_constants).generate()

        self.build_successful: bool = False

        self.install_button: wx.Button = None
        self.text_box:     wx.TextCtrl = None
        self.frame_modal:    wx.Dialog = None

        self.constants: constants.Constants = global_constants
        self.title: str = title
        self.stock_output = logging.getLogger().handlers[0].stream

        self.frame_modal = wx.Dialog(self, title=title, size=(400, 200))

        self._generate_elements(self.frame_modal)

        if self.constants.update_stage != gui_support.AutoUpdateStages.INACTIVE:
            self.constants.update_stage = gui_support.AutoUpdateStages.BUILDING

        self.Centre()
        self.frame_modal.ShowWindowModal()

        self._invoke_build()


    def _generate_elements(self, frame: wx.Frame = None) -> None:
        """
        Generate UI elements for build frame

        Format:
            - Title label:        Build and Install OpenCore
            - Text:               Model: {Build or Host Model}
            - Button:             Install OpenCore
            - Read-only text box: {empty}
            - Button:             Return to Main Menu
        """
        frame = self if not frame else frame

        title_label = wx.StaticText(frame, label="Build and Install OpenCore", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        model_label = wx.StaticText(frame, label=f"Model: {self.constants.custom_model or self.constants.computer.real_model}", pos=(-1,30))
        model_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        model_label.Centre(wx.HORIZONTAL)

        # Button: Install OpenCore
        install_button = wx.Button(frame, label="ð© Install OpenCore", pos=(-1, model_label.GetPosition()[1] + model_label.GetSize()[1]), size=(150, 30))
        install_button.Bind(wx.EVT_BUTTON, self.on_install)
        install_button.Centre(wx.HORIZONTAL)
        install_button.Disable()
        self.install_button = install_button

        # Read-only text box: {empty}
        text_box = wx.TextCtrl(frame, value="", pos=(-1, install_button.GetPosition()[1] + install_button.GetSize()[1] + 10), size=(380, 350), style=wx.TE_READONLY | wx.TE_MULTILINE | wx.TE_RICH2)
        text_box.Centre(wx.HORIZONTAL)
        self.text_box = text_box

        # Button: Return to Main Menu
        return_button = wx.Button(frame, label="Return to Main Menu", pos=(-1, text_box.GetPosition()[1] + text_box.GetSize()[1] + 5), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        return_button.Centre(wx.HORIZONTAL)
        return_button.Disable()
        self.return_button = return_button

        # Adjust window size to fit all elements
        frame.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))


    def _invoke_build(self) -> None:
        """
        Invokes build function and waits for it to finish
        """
        while gui_support.PayloadMount(self.constants, self).is_unpack_finished() is False:
            wx.Yield()
            time.sleep(self.constants.thread_sleep_interval)

        thread = threading.Thread(target=self._build)
        thread.start()

        gui_support.wait_for_thread(thread)

        self.return_button.Enable()

        # Check if config.plist was built
        if self.build_successful is False:
            dialog = wx.MessageDialog(
                parent=self,
                message="An error occurred while building OpenCore",
                caption="Error building OpenCore",
                style=wx.OK | wx.ICON_ERROR
            )
            dialog.ShowModal()
            return

        dialog = wx.MessageDialog(
            parent=self,
            message=f"Would you like to install OpenCore now?",
            caption="Finished building your OpenCore configuration!",
            style=wx.YES_NO | wx.ICON_QUESTION
        )
        dialog.SetYesNoLabels("Install to disk", "View build log")

        self.on_install() if dialog.ShowModal() == wx.ID_YES else self.install_button.Enable()


    def _build(self) -> None:
        """
        Calls build function and redirects stdout to the text box
        """
        logger = logging.getLogger()
        logger.addHandler(gui_support.ThreadHandler(self.text_box))
        try:
            build.BuildOpenCore(self.constants.custom_model or self.constants.computer.real_model, self.constants)
            self.build_successful = True
        except Exception as e:
            logging.error("An internal error occurred while building:\n")
            logging.error(traceback.format_exc())

            # Handle bug from 2.1.0 where None type was stored in config.plist from global settings
            if "TypeError: unsupported type: <class 'NoneType'>" in traceback.format_exc():
                logging.error("If you continue to see this error, delete the following file and restart the application:")
                logging.error("Path: /Users/Shared/.com.dortania.opencore-legacy-patcher.plist")

        logger.removeHandler(logger.handlers[2])


    def on_return_to_main_menu(self, event: wx.Event = None) -> None:
        """
        Return to main menu
        """
        self.frame_modal.Hide()
        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        main_menu_frame.Show()
        self.frame_modal.Destroy()
        self.Destroy()


    def on_install(self, event: wx.Event = None) -> None:
        """
        Launch install frame
        """
        self.frame_modal.Destroy()
        self.Destroy()
        install_oc_frame = gui_install_oc.InstallOCFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        install_oc_frame.Show()



#gui_cache_os_update.py
"""
gui_cache_os_update.py: UI to display to users before a macOS update is applied
Primarily for caching updates required for incoming OS (ex. KDKs)
"""

import wx
import sys
import time
import logging
import threading

from pathlib import Path

from .. import constants
from ..support import kdk_handler, utilities, metallib_handler
from ..wx_gui import gui_support, gui_download

from ..sys_patch.patchsets import HardwarePatchsetDetection, HardwarePatchsetSettings


class OSUpdateFrame(wx.Frame):
    """
    Create a modal frame for displaying information to the user before an update is applied
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing Prepare Update Frame")

        if parent:
            self.frame = parent
        else:
            super().__init__(parent, title=title, size=(360, 140), style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX)
            self.frame = self
            self.frame.Centre()

        self.title = title
        self.constants: constants.Constants = global_constants

        os_data = utilities.fetch_staged_update(variant="Preflight")
        if os_data[0] is None:
            logging.info("No staged update found")
            self._exit()
        logging.info(f"Staged update found: {os_data[0]} ({os_data[1]})")
        self.os_data = os_data

        # Check if we need to patch the system volume
        results = HardwarePatchsetDetection(
            constants=self.constants,
            xnu_major=int(self.os_data[1][:2]),
            xnu_minor=0, # We can't determine this from the build number
            os_build=self.os_data[1],
            os_version=self.os_data[0],
        ).device_properties

        if results[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED] is True:
            logging.info("KDK required")
        if results[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED] is True:
            # TODO: Download MetalLibSupportPkg
            logging.info("MetallibSupportPkg required")

        if not any([results[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED], results[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED]]):
            logging.info("No additional resources required")
            self._exit()

        self._generate_ui()

        self.kdk_obj: kdk_handler.KernelDebugKitObject = None
        def _kdk_thread_spawn():
            self.kdk_obj = kdk_handler.KernelDebugKitObject(self.constants, self.os_data[1], self.os_data[0], passive=True, check_backups_only=True)


        self.metallib_obj: metallib_handler.MetalLibraryObject = None
        def _metallib_thread_spawn():
            self.metallib_obj = metallib_handler.MetalLibraryObject(self.constants, self.os_data[1], self.os_data[0])


        if results[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED] is True:
            kdk_thread = threading.Thread(target=_kdk_thread_spawn)
            kdk_thread.start()
            gui_support.wait_for_thread(kdk_thread)
        if results[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED] is True:
            metallib_thread = threading.Thread(target=_metallib_thread_spawn)
            metallib_thread.start()
            gui_support.wait_for_thread(metallib_thread)


        download_objects = {
            # Name: xxx
            # download_obj: xxx
        }

        if self.kdk_obj:
            if self.kdk_obj.success is True:
                result = self.kdk_obj.retrieve_download()
                if result is not None:
                    download_objects[f"KDK Build {self.kdk_obj.kdk_url_build}"] = result
        if self.metallib_obj:
            if self.metallib_obj.success is True:
                result = self.metallib_obj.retrieve_download()
                if result is not None:
                    download_objects[f"Metallib Build {self.metallib_obj.metallib_url_build}"] = result

        if len(download_objects) == 0:
            self._exit()

        self.frame.Show()

        self.did_cancel = -1
        self._notifyUser()

        # Allow 10 seconds for the user to cancel the download
        # If nothing, continue
        for i in range(0, 10):
            if self.did_cancel == 1:
                self._exit()
            if self.did_cancel == -1:
                time.sleep(1)

        for item in download_objects:
            name = item
            download_obj = download_objects[item]
            self.download_obj = download_obj
            gui_download.DownloadFrame(
                self,
                title=self.title,
                global_constants=self.constants,
                download_obj=download_obj,
                item_name=name
            )
            if download_obj.download_complete is True:
                if item.startswith("KDK"):
                    self._handle_kdk(self.kdk_obj)
                if item.startswith("Metallib"):
                    self._handle_metallib(self.metallib_obj)

        self._exit()


    def _handle_kdk(self, kdk_obj: kdk_handler.KernelDebugKitObject) -> None:
        """
        Handle KDK installation
        """
        logging.info("KDK download complete, validating with hdiutil")
        self.kdk_checksum_result = False
        def _validate_kdk_checksum_thread():
            self.kdk_checksum_result = kdk_obj.validate_kdk_checksum()

        kdk_checksum_thread = threading.Thread(target=_validate_kdk_checksum_thread)
        kdk_checksum_thread.start()

        gui_support.wait_for_thread(kdk_checksum_thread)

        if self.kdk_checksum_result is False:
            logging.error("KDK checksum validation failed")
            logging.error(kdk_obj.error_msg)
            self._exit()


        logging.info("KDK checksum validation passed")

        logging.info("Mounting KDK")
        if not Path(self.constants.kdk_download_path).exists():
            logging.error("KDK download path does not exist")
            return

        self.kdk_install_result = False
        def _install_kdk_thread():
            self.kdk_install_result = kdk_handler.KernelDebugKitUtilities().install_kdk_dmg(self.constants.kdk_download_path, only_install_backup=True)

        kdk_install_thread = threading.Thread(target=_install_kdk_thread)
        kdk_install_thread.start()

        gui_support.wait_for_thread(kdk_install_thread)

        if self.kdk_install_result is False:
            logging.info("Failed to install KDK")
            return

        logging.info("KDK installed successfully")



    def _handle_metallib(self, metallib_obj: metallib_handler.MetalLibraryObject) -> None:
        """
        Handle Metallib installation
        """
        self.metallib_install_result = False
        def _install_metallib_thread():
            self.metallib_install_result = metallib_obj.install_metallib()

        metallib_install_thread = threading.Thread(target=_install_metallib_thread)
        metallib_install_thread.start()

        gui_support.wait_for_thread(metallib_install_thread)

        if self.metallib_install_result is False:
            logging.info("Failed to install Metallib")
            return

        logging.info("Metallib installed successfully")


    def _generate_ui(self) -> None:
        """
        Display frame


        Title: OpenCore Legacy Patcher is preparing to update your system
        Body:  Please wait while we prepare your system for the update.
               This may take a few minutes.
        """

        header = wx.StaticText(self.frame, label="Preparing for macOS Software Update", pos=(-1,5))
        header.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        header.Centre(wx.HORIZONTAL)

        # list OS
        label = wx.StaticText(self.frame, label=f"macOS {self.os_data[0]} ({self.os_data[1]})", pos=(-1, 35))
        label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        label.Centre(wx.HORIZONTAL)

        # this may take a few minutes
        label = wx.StaticText(self.frame, label="This may take a few minutes.", pos=(-1, 55))
        label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        label.Centre(wx.HORIZONTAL)

        # Add a progress bar
        self.progress_bar = wx.Gauge(self.frame, range=100, pos=(10, 75), size=(340, 20))
        self.progress_bar.SetValue(0)
        self.progress_bar.Pulse()

        # Set frame size below progress bar
        self.frame.SetSize((360, 140))


    def _notifyUser(self) -> None:
        """
        Notify user of what OCLP is doing
        Note will be spawned through wx.CallAfter
        """
        threading.Thread(target=self._notifyUserThread).start()


    def _notifyUserThread(self) -> None:
        """
        Notify user of what OCLP is doing
        """
        message=f"OpenCore Legacy Patcher has detected that a macOS update is being downloaded:\n{self.os_data[0]} ({self.os_data[1]})\n\nThe patcher needs to prepare the system for the update, and will download any additional resources it may need post-update.\n\nThis may take a few minutes, the patcher will exit when it is done."
        # Yes/No for caching
        dlg = wx.MessageDialog(self.frame, message=message, caption="OpenCore Legacy Patcher", style=wx.YES_NO | wx.ICON_INFORMATION)
        dlg.SetYesNoLabels("&Ok", "&Cancel")
        result = dlg.ShowModal()
        if result == wx.ID_NO:
            logging.info("User cancelled OS caching")
            if hasattr(self, "download_obj"):
                self.download_obj.stop()
            self.did_cancel = 1
        else:
            self.did_cancel = 0

    def _exit(self):
        """
        Exit the frame
        """
        self.frame.Close()
        sys.exit()


#gui_download.py:
"""
gui_download.py: Generate UI for downloading files
"""

import wx
import logging
import time

from .. import constants

from ..wx_gui import gui_support

from ..support import (
    network_handler,
    utilities
)


class DownloadFrame(wx.Frame):
    """
    Update provided frame with download stats
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, download_obj: network_handler.DownloadObject, item_name: str, download_icon = None) -> None:
        logging.info("Initializing Download Frame")
        self.constants: constants.Constants = global_constants
        self.title: str = title
        self.parent: wx.Frame = parent
        self.download_obj: network_handler.DownloadObject = download_obj
        self.item_name: str = item_name
        if download_icon:
            self.download_icon: str = download_icon
        else:
            self.download_icon: str = "/System/Library/CoreServices/Installer.app/Contents/Resources/package.icns"

        self.user_cancelled: bool = False

        self.frame_modal = wx.Dialog(parent, title=title, size=(400, 200))

        self._generate_elements(self.frame_modal)


    def _generate_elements(self, frame: wx.Dialog = None) -> None:
        """
        Generate elements for download frame
        """

        frame = self if not frame else frame
        icon = self.download_icon
        icon = wx.StaticBitmap(frame, bitmap=wx.Bitmap(icon, wx.BITMAP_TYPE_ICON), pos=(-1, 20))
        icon.SetSize((100, 100))
        icon.Centre(wx.HORIZONTAL)

        title_label = wx.StaticText(frame, label=f"Downloading: {self.item_name}", pos=(-1,icon.GetPosition()[1] + icon.GetSize()[1] + 20))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        progress_bar = wx.Gauge(frame, range=100, pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5), size=(300, 20), style=wx.GA_SMOOTH|wx.GA_PROGRESS)
        progress_bar.Centre(wx.HORIZONTAL)

        label_amount = wx.StaticText(frame, label="Preparing download", pos=(-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1]))
        label_amount.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        label_amount.Centre(wx.HORIZONTAL)

        return_button = wx.Button(frame, label="Cancel", pos=(-1, label_amount.GetPosition()[1] + label_amount.GetSize()[1] + 10))
        return_button.Bind(wx.EVT_BUTTON, lambda event: self.terminate_download())
        return_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        frame.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))
        frame.ShowWindowModal()

        self.download_obj.download()
        while self.download_obj.is_active():

            percentage: int = round(self.download_obj.get_percent())
            if percentage == 0:
                percentage = 1

            if percentage == -1:
                amount_str = f"{utilities.human_fmt(self.download_obj.downloaded_file_size)} downloaded ({utilities.human_fmt(self.download_obj.get_speed())}/s)"
                progress_bar.Pulse()
            else:
                amount_str = f"{utilities.seconds_to_readable_time(self.download_obj.get_time_remaining())}left - {utilities.human_fmt(self.download_obj.downloaded_file_size)} of {utilities.human_fmt(self.download_obj.total_file_size)} ({utilities.human_fmt(self.download_obj.get_speed())}/s)"
                progress_bar.SetValue(int(percentage))

            label_amount.SetLabel(amount_str)
            label_amount.Centre(wx.HORIZONTAL)

            wx.Yield()
            time.sleep(self.constants.thread_sleep_interval)

        if self.download_obj.download_complete is False and self.user_cancelled is False:
            wx.MessageBox(f"Download failed: \n{self.download_obj.error_msg}", "Error", wx.OK | wx.ICON_ERROR)

        progress_bar.Destroy()
        frame.Destroy()


    def terminate_download(self) -> None:
        """
        Terminate download
        """
        if wx.MessageBox("Are you sure you want to cancel the download?", "Cancel Download", wx.YES_NO | wx.ICON_QUESTION | wx.NO_DEFAULT) == wx.YES:
            logging.info("User cancelled download")
            self.user_cancelled = True
            self.download_obj.stop()


#gui_entry.py
"""
gui_entry.py: Entry point for the wxPython GUI
"""

import wx
import sys
import atexit
import logging

from Cocoa import NSApp, NSApplication


from .. import constants

from ..sys_patch.patchsets import HardwarePatchsetDetection

from ..wx_gui import (
    gui_cache_os_update,
    gui_main_menu,
    gui_build,
    gui_install_oc,
    gui_sys_patch_start,
    gui_update,
)


class SupportedEntryPoints:
    """
    Enum for supported entry points
    """
    MAIN_MENU  = gui_main_menu.MainFrame
    BUILD_OC   = gui_build.BuildFrame
    INSTALL_OC = gui_install_oc.InstallOCFrame
    SYS_PATCH  = gui_sys_patch_start.SysPatchStartFrame
    UPDATE_APP = gui_update.UpdateFrame
    OS_CACHE   = gui_cache_os_update.OSUpdateFrame


class EntryPoint:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.app: wx.App = None
        self.main_menu_frame: gui_main_menu.MainFrame = None
        self.constants: constants.Constants = global_constants

        self.constants.gui_mode = True


    def _generate_base_data(self) -> None:
        self.app = wx.App()
        self.app.SetAppName(self.constants.patcher_name)

        # Reference:
        # - https://discuss.wxpython.org/t/macos-window-opens-in-the-background-and-does-not-receive-focus/36763/10
        NSApplication.sharedApplication()
        NSApp().activateIgnoringOtherApps_(True)


    def start(self, entry: SupportedEntryPoints = gui_main_menu.MainFrame, start_patching: bool = False) -> None:
        """
        Launches entry point for the wxPython GUI
        """
        self._generate_base_data()

        if "--gui_patch" in sys.argv or "--gui_unpatch" in sys.argv or start_patching is True :
            entry = gui_sys_patch_start.SysPatchStartFrame
            patches = HardwarePatchsetDetection(constants=self.constants).device_properties

        logging.info(f"Entry point set: {entry.__name__}")

        # Normally set by main.py, but transitions from CLI mode may not have this set
        self.constants.gui_mode = True

        self.frame: wx.Frame = entry(
            None,
            title=f"{self.constants.patcher_name} {self.constants.patcher_version}{' (Nightly)' if not self.constants.commit_info[0].startswith('refs/tags') else ''}",
            global_constants=self.constants,
            screen_location=None,
            **({"patches": patches} if "--gui_patch" in sys.argv or "--gui_unpatch" in sys.argv or start_patching is True else {})
        )

        atexit.register(self.OnCloseFrame)

        if "--gui_patch" in sys.argv or start_patching is True:
            self.frame.start_root_patching()
        elif "--gui_unpatch" in sys.argv:
            self.frame.revert_root_patching()

        self.app.MainLoop()


    def OnCloseFrame(self, event: wx.Event = None) -> None:
        """
        Closes the wxPython GUI
        """

        if not self.frame:
            return

        logging.info("Cleaning up wxPython GUI")

        self.frame.SetTransparent(0)
        wx.Yield()

        self.frame.DestroyChildren()
        self.frame.Destroy()
        self.app.ExitMainLoop()

#gui_help.py
"""
gui_help.py: GUI Help Menu
"""

import wx
import logging
import webbrowser

from .. import constants

from ..wx_gui import gui_support


class HelpFrame(wx.Frame):
    """
    Append to main menu through a modal dialog
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None) -> None:
        logging.info("Initializing Help Frame")
        self.dialog = wx.Dialog(parent, title=title, size=(300, 200))

        self.constants: constants.Constants = global_constants
        self.title: str = title

        self._generate_elements(self.dialog)
        self.dialog.ShowWindowModal()


    def _generate_elements(self, frame: wx.Frame = None) -> None:
        """
        Format:
            - Title: Patcher Resources
            - Text:  Following resources are available:
            - Button: Official Guide
            - Button: Community Discord Server
            - Button: Official Phone Support
            - Button: Return to Main Menu
        """

        frame = self if not frame else frame

        title_label = wx.StaticText(frame, label="Patcher Resources", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        text_label = wx.StaticText(frame, label="Following resources are available:", pos=(-1,30))
        text_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        text_label.Centre(wx.HORIZONTAL)

        buttons = {
            "Official Guide":           self.constants.guide_link,
            "Official Phone Support":   "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            "Community Discord Server": self.constants.discord_link,
        }

        for button in buttons:
            help_button = wx.Button(frame, label=button, pos=(-1, text_label.GetPosition()[1] + text_label.GetSize()[1] + (list(buttons.keys()).index(button) * 30)), size=(200, 30))
            help_button.Bind(wx.EVT_BUTTON, lambda event, temp=buttons[button]: webbrowser.open(temp))
            help_button.Centre(wx.HORIZONTAL)

        # Button: Return to Main Menu
        return_button = wx.Button(frame, label="Return to Main Menu", pos=(-1, help_button.GetPosition()[1] + help_button.GetSize()[1]), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, lambda event: frame.Close())
        return_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        frame.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))


#gui_install_oc.py
"""
gui_install_oc.py: Frame for installing OpenCore to disk
"""

import wx
import logging
import threading
import traceback

from .. import constants

from ..datasets import os_data
from ..support import install

from ..wx_gui import (
    gui_main_menu,
    gui_support,
    gui_sys_patch_display
)


class InstallOCFrame(wx.Frame):
    """
    Create a frame for installing OpenCore to disk
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing Install OpenCore Frame")
        super(InstallOCFrame, self).__init__(parent, title=title, size=(300, 120), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, global_constants).generate()

        self.constants: constants.Constants = global_constants
        self.title: str = title
        self.result: bool = False

        self.available_disks: dict = None
        self.stock_output = logging.getLogger().handlers[0].stream

        self.progress_bar_animation: gui_support.GaugePulseCallback = None

        self.hyperlink_colour = (25, 179, 231)

        self._generate_elements()

        if self.constants.update_stage != gui_support.AutoUpdateStages.INACTIVE:
            self.constants.update_stage = gui_support.AutoUpdateStages.INSTALLING

        self.Centre()
        self.Show()

        self._display_disks()


    def _generate_elements(self) -> None:
        """
        Display indeterminate progress bar while collecting disk information

        Format:
            - Title label:        Install OpenCore
            - Text:               Fetching information on local disks...
            - Progress bar:       {indeterminate}
        """

        # Title label: Install OpenCore
        title_label = wx.StaticText(self, label="Install OpenCore", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Text: Parsing local disks...
        text_label = wx.StaticText(self, label="Fetching information on local disks...", pos=(-1,30))
        text_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        text_label.Centre(wx.HORIZONTAL)
        self.text_label = text_label

        # Progress bar: {indeterminate}
        progress_bar = wx.Gauge(self, range=100, pos=(-1, text_label.GetPosition()[1] + text_label.GetSize()[1]), size=(150, 30), style=wx.GA_HORIZONTAL | wx.GA_SMOOTH)
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        self.progress_bar_animation = progress_bar_animation
        self.progress_bar = progress_bar


    def _fetch_disks(self) -> None:
        """
        Fetch information on local disks
        """
        self.available_disks = install.tui_disk_installation(self.constants).list_disks()

        # Need to clean up output on pre-Sierra
        # Disk images are mixed in with regular disks (ex. payloads.dmg)
        ignore = ["disk image", "read-only", "virtual"]
        for disk in self.available_disks.copy():
            if any(string in self.available_disks[disk]['name'].lower() for string in ignore):
                del self.available_disks[disk]


    def _display_disks(self) -> None:
        """
        Display disk selection dialog
        """
        thread = threading.Thread(target=self._fetch_disks)
        thread.start()

        gui_support.wait_for_thread(thread)

        self.progress_bar_animation.stop_pulse()
        self.progress_bar.Hide()

        # Create wxDialog for disk selection
        dialog = wx.Dialog(self, title=self.title, size=(380, -1))

        # Title label: Install OpenCore
        title_label = wx.StaticText(dialog, label="Install OpenCore", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Text: select disk to install OpenCore onto
        text_label = wx.StaticText(dialog, label="Select disk to install OpenCore onto:", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5))
        text_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        text_label.Centre(wx.HORIZONTAL)

        # Add note: "Missing disks? Ensure they're FAT32 or formatted as GUID/GPT"
        gpt_note = wx.StaticText(dialog, label="Missing disks? Ensure they're FAT32 or formatted as GUID/GPT", pos=(-1, text_label.GetPosition()[1] + text_label.GetSize()[1] + 5))
        gpt_note.SetFont(gui_support.font_factory(10, wx.FONTWEIGHT_NORMAL))
        gpt_note.Centre(wx.HORIZONTAL)

        # Add buttons for each disk
        if self.available_disks:
            # Only show booted disk if building for host
            disk_root = self.constants.booted_oc_disk if self.constants.custom_model is None else None
            if disk_root:
                # disk6s1 -> disk6
                disk_root = self.constants.booted_oc_disk.strip("disk")
                disk_root = "disk" + disk_root.split("s")[0]
                logging.info(f"Checking if booted disk is present: {disk_root}")

            # Add buttons for each disk
            items = len(self.available_disks)
            longest_label = max((len(self.available_disks[disk]['disk']) + len(self.available_disks[disk]['name']) + len(str(self.available_disks[disk]['size']))) for disk in self.available_disks)
            longest_label = longest_label * 9
            spacer = 0
            logging.info("Available disks:")
            for disk in self.available_disks:
                # Create a button for each disk
                logging.info(f"- {self.available_disks[disk]['disk']} - {self.available_disks[disk]['name']} - {self.available_disks[disk]['size']}")
                disk_button = wx.Button(dialog, label=f"{self.available_disks[disk]['disk']} - {self.available_disks[disk]['name']} - {self.available_disks[disk]['size']}", size=(longest_label ,30), pos=(-1, gpt_note.GetPosition()[1] + gpt_note.GetSize()[1] + 5 + spacer))
                disk_button.Centre(wx.HORIZONTAL)
                disk_button.Bind(wx.EVT_BUTTON, lambda event, disk=disk: self._display_volumes(disk, self.available_disks))
                if disk_root == self.available_disks[disk]['disk'] or items == 1:
                    disk_button.SetDefault()
                spacer += 25

            if disk_root:
                # Add note: "Note: Blue represent the disk OpenCore is currently booted from"
                disk_label = wx.StaticText(dialog, label="Note: Blue represent the disk OpenCore is currently booted from", pos=(-1, disk_button.GetPosition()[1] + disk_button.GetSize()[1] + 5))
                disk_label.SetFont(gui_support.font_factory(10, wx.FONTWEIGHT_NORMAL))
                disk_label.Centre(wx.HORIZONTAL)
            else:
                disk_label = wx.StaticText(dialog, label="", pos=(-1, disk_button.GetPosition()[1] + 15))
                disk_label.SetFont(gui_support.font_factory(10, wx.FONTWEIGHT_NORMAL))
        else:
            # Text: Failed to find any applicable disks
            disk_label = wx.StaticText(dialog, label="Failed to find any applicable disks", pos=(-1, gpt_note.GetPosition()[1] + gpt_note.GetSize()[1] + 5))
            disk_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
            disk_label.Centre(wx.HORIZONTAL)

        # Add button: Search for disks again
        search_button = wx.Button(dialog, label="Search for disks again", size=(150,30), pos=(-1, disk_label.GetPosition()[1] + disk_label.GetSize()[1] + 5))
        search_button.Centre(wx.HORIZONTAL)
        search_button.Bind(wx.EVT_BUTTON, self.on_reload_frame)

        # Add button: Return to main menu
        return_button = wx.Button(dialog, label="Return to Main Menu", size=(150,30), pos=(-1, search_button.GetPosition()[1] + 20))
        return_button.Centre(wx.HORIZONTAL)
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)

        # Set size
        dialog.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))
        dialog.ShowWindowModal()
        self.dialog = dialog


    def _display_volumes(self, disk: str, dataset: dict) -> None:
        """
        List volumes on disk
        """

        self.dialog.Close()

        # Create dialog
        dialog = wx.Dialog(
            self,
            title=f"Volumes on {disk}",
            style=wx.CAPTION | wx.CLOSE_BOX,
            size=(300, 300)
        )

        # Add text: "Volumes on {disk}"
        text_label = wx.StaticText(dialog, label=f"Volumes on {disk}", pos=(-1, 10))
        text_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        text_label.Centre(wx.HORIZONTAL)

        partitions = install.tui_disk_installation(self.constants).list_partitions(disk, dataset)
        items = len(partitions)
        longest_label = max((len(partitions[partition]['partition']) + len(partitions[partition]['name']) + len(str(partitions[partition]['size']))) for partition in partitions)
        longest_label = longest_label * 10
        spacer = 0
        logging.info(f"Available partitions for {disk}:")
        for partition in partitions:
            logging.info(f"- {partitions[partition]['partition']} - {partitions[partition]['name']} - {partitions[partition]['size']}")
            disk_button = wx.Button(dialog, label=f"{partitions[partition]['partition']} - {partitions[partition]['name']} - {partitions[partition]['size']}", size=(longest_label,30), pos=(-1, text_label.GetPosition()[1] + text_label.GetSize()[1] + 5 + spacer))
            disk_button.Centre(wx.HORIZONTAL)
            disk_button.Bind(wx.EVT_BUTTON, lambda event, partition=partition: self._install_oc_process(partition))
            if items == 1 or self.constants.booted_oc_disk == partitions[partition]['partition']:
                disk_button.SetDefault()
            spacer += 25

        # Add button: Return to main menu
        return_button = wx.Button(dialog, label="Return to Main Menu", size=(150,30), pos=(-1, disk_button.GetPosition()[1] + disk_button.GetSize()[1]))
        return_button.Centre(wx.HORIZONTAL)
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)

        # Set size
        dialog.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))

        # Show dialog
        dialog.ShowWindowModal()
        self.dialog = dialog


    def _install_oc_process(self, partition: dict) -> None:
        """
        Install OpenCore to disk
        """
        self.dialog.Close()

        # Create dialog
        dialog = wx.Dialog(
            self,
            title=f"Installing OpenCore to {partition}",
            style=wx.CAPTION | wx.CLOSE_BOX,
            size=(370, 200)
        )

        # Add text: "Installing OpenCore to {partition}"
        text_label = wx.StaticText(dialog, label=f"Installing OpenCore to {partition}", pos=(-1, 10))
        text_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        text_label.Centre(wx.HORIZONTAL)

        # Read-only text box: {empty}
        text_box = wx.TextCtrl(dialog, value="", pos=(-1, text_label.GetPosition()[1] + text_label.GetSize()[1] + 10), size=(350, 200), style=wx.TE_READONLY | wx.TE_MULTILINE | wx.TE_RICH2)
        text_box.Centre(wx.HORIZONTAL)
        self.text_box = text_box

        # Add button: Return to main menu
        return_button = wx.Button(dialog, label="Return to Main Menu", size=(150,30), pos=(-1, text_box.GetPosition()[1] + text_box.GetSize()[1] + 10))
        return_button.Centre(wx.HORIZONTAL)
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        return_button.Disable()

        # Set size
        dialog.SetSize((370, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))

        # Show dialog
        dialog.ShowWindowModal()
        self.dialog = dialog

        # Install OpenCore
        self._invoke_install_oc(partition)
        return_button.Enable()


    def _invoke_install_oc(self, partition: dict) -> None:
        """
        Invoke OpenCore installation
        """
        thread = threading.Thread(target=self._install_oc, args=(partition,))
        thread.start()

        gui_support.wait_for_thread(thread)

        if self.result is True:
            if self.constants.update_stage != gui_support.AutoUpdateStages.INACTIVE and self.constants.detected_os >= os_data.os_data.big_sur:
                self.constants.update_stage = gui_support.AutoUpdateStages.ROOT_PATCHING
                popup_message = wx.MessageDialog(
                    self,
                    f"OpenCore has finished installing to disk.\n\nWould you like to update your root patches next?", "Success",
                    wx.YES_NO | wx.YES_DEFAULT
                )
                popup_message.ShowModal()
                if popup_message.GetReturnCode() == wx.ID_YES:
                    self.Hide()
                    gui_sys_patch_display.SysPatchDisplayFrame(
                        parent=None,
                        title=self.title,
                        global_constants=self.constants,
                        screen_location=self.GetPosition()
                    )
                    self.Destroy()
                return

            elif not self.constants.custom_model:
                gui_support.RestartHost(self).restart(message="OpenCore has finished installing to disk.\n\nYou will need to reboot and hold the Option key and select OpenCore/Boot EFI's option.\n\nWould you like to reboot?")
            else:
                popup_message = wx.MessageDialog(
                    self,
                    f"OpenCore has finished installing to disk.\n\nYou can eject the drive, insert it into the {self.constants.custom_model}, reboot, hold the Option key and select OpenCore/Boot EFI's option.", "Success",
                    wx.OK
                )
                popup_message.ShowModal()
        else:
            if self.constants.update_stage != gui_support.AutoUpdateStages.INACTIVE:
                self.constants.update_stage = gui_support.AutoUpdateStages.FINISHED


    def _install_oc(self, partition: dict) -> None:
        """
        Install OpenCore to disk
        """
        logging.info(f"Installing OpenCore to {partition}")

        logger = logging.getLogger()
        logger.addHandler(gui_support.ThreadHandler(self.text_box))
        try:
            self.result = install.tui_disk_installation(self.constants).install_opencore(partition)
        except:
            logging.error("An internal error occurred while installing:\n")
            logging.error(traceback.format_exc())
        logger.removeHandler(logger.handlers[2])


    def on_reload_frame(self, event: wx.Event = None) -> None:
        """
        Reload frame
        """
        self.Destroy()
        frame = InstallOCFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        frame.Show()


    def on_return_to_main_menu(self, event: wx.Event = None) -> None:
        """
        Return to main menu
        """
        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        main_menu_frame.Show()
        self.Destroy()



#gui_macos_installer_download.py
"""
gui_macos_installer_download.py: macOS Installer Download Frame
"""

import wx
import locale
import logging
import threading
import webbrowser

from pathlib import Path

from .. import (
    constants,
    sucatalog
)

from ..datasets import (
    os_data,
    smbios_data,
    cpu_data
)
from ..wx_gui import (
    gui_main_menu,
    gui_support,
    gui_download,
    gui_macos_installer_flash
)
from ..support import (
    macos_installer_handler,
    utilities,
    network_handler,
    integrity_verification
)


class macOSInstallerDownloadFrame(wx.Frame):
    """
    Create a frame for downloading and creating macOS installers
    Uses a Modal Dialog for smoother transition from other frames
    Note: Flashing installers is passed to gui_macos_installer_flash.py
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing macOS Installer Download Frame")
        self.constants: constants.Constants = global_constants
        self.title: str = title
        self.parent: wx.Frame = parent

        self.available_installers = None
        self.available_installers_latest = None

        self.catalog_seed: sucatalog.SeedType = sucatalog.SeedType.DeveloperSeed

        self.frame_modal = wx.Dialog(parent, title=title, size=(330, 200))

        self._generate_elements(self.frame_modal)
        self.frame_modal.ShowWindowModal()

        self.icons = [[self._icon_to_bitmap(i), self._icon_to_bitmap(i, (64, 64))] for i in self.constants.icons_path]

    def _icon_to_bitmap(self, icon: str, size: tuple = (32, 32)) -> wx.Bitmap:
        """
        Convert icon to bitmap
        """
        return wx.Bitmap(wx.Bitmap(icon, wx.BITMAP_TYPE_ICON).ConvertToImage().Rescale(size[0], size[1], wx.IMAGE_QUALITY_HIGH))

    def _macos_version_to_icon(self, version: int) -> int:
        """
        Convert macOS version to icon
        """
        try:
            self.constants.icons_path[version - 19]
            return version - 19
        except IndexError:
            return 0


    def _generate_elements(self, frame: wx.Frame = None) -> None:
        """
        Format:
        - Title:  Create macOS Installer
        - Button: Download macOS Installer
        - Button: Use existing macOS Installer
        - Button: Return to Main Menu
        """

        frame = self if not frame else frame

        title_label = wx.StaticText(frame, label="Create macOS Installer", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Button: Download macOS Installer
        download_button = wx.Button(frame, label="Download macOS Installer", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5), size=(200, 30))
        download_button.Bind(wx.EVT_BUTTON, self.on_download)
        download_button.Centre(wx.HORIZONTAL)

        # Button: Use existing macOS Installer
        existing_button = wx.Button(frame, label="Use existing macOS Installer", pos=(-1, download_button.GetPosition()[1] + download_button.GetSize()[1] - 5), size=(200, 30))
        existing_button.Bind(wx.EVT_BUTTON, self.on_existing)
        existing_button.Centre(wx.HORIZONTAL)

        # Button: Return to Main Menu
        return_button = wx.Button(frame, label="Return to Main Menu", pos=(-1, existing_button.GetPosition()[1] + existing_button.GetSize()[1] + 5), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return)
        return_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        frame.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))


    def _generate_catalog_frame(self) -> None:
        """
        Generate frame to display available installers
        """
        super(macOSInstallerDownloadFrame, self).__init__(None, title=self.title, size=(300, 200), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, self.constants).generate()
        self.Centre()

        # Title: Pulling installer catalog
        title_label = wx.StaticText(self, label="Finding Available Software", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self, range=100, pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5), size=(250, 30))
        progress_bar.Centre(wx.HORIZONTAL)
        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set size of frame
        self.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))

        self.Show()

        # Grab installer catalog
        def _fetch_installers():
            logging.info(f"Fetching installer catalog: {sucatalog.SeedType.DeveloperSeed.name}")

            sucatalog_contents = sucatalog.CatalogURL(seed=sucatalog.SeedType.DeveloperSeed).url_contents
            if sucatalog_contents is None:
                logging.error("Failed to download Installer Catalog from Apple")
                return

            self.available_installers        = sucatalog.CatalogProducts(sucatalog_contents).products
            self.available_installers_latest = sucatalog.CatalogProducts(sucatalog_contents).latest_products


        thread = threading.Thread(target=_fetch_installers)
        thread.start()

        gui_support.wait_for_thread(thread)

        progress_bar_animation.stop_pulse()
        progress_bar.Hide()
        self._display_available_installers()


    def _display_available_installers(self, event: wx.Event = None, show_full: bool = False) -> None:
        """
        Display available installers in frame
        """


        bundles = [wx.BitmapBundle.FromBitmaps(icon) for icon in self.icons]

        self.frame_modal.Destroy()
        self.frame_modal = wx.Dialog(self, title="Select macOS Installer", size=(505, 500))

        # Title: Select macOS Installer
        title_label = wx.StaticText(self.frame_modal, label="Select macOS Installer", pos=(-1,-1))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))

        # macOS Installers list
        id = wx.NewIdRef()

        self.list = wx.ListCtrl(self.frame_modal, id, style=wx.LC_REPORT | wx.LC_SINGLE_SEL | wx.LC_NO_HEADER | wx.BORDER_SUNKEN)
        self.list.SetSmallImages(bundles)

        self.list.InsertColumn(0, "Title",        width=175)
        self.list.InsertColumn(1, "Version",      width=50)
        self.list.InsertColumn(2, "Build",        width=75)
        self.list.InsertColumn(3, "Size",         width=75)
        self.list.InsertColumn(4, "Release Date", width=100)

        installers = self.available_installers_latest if show_full is False else self.available_installers
        if show_full is False:
            self.frame_modal.SetSize((490, 370))

        if installers:
            locale.setlocale(locale.LC_TIME, '')
            logging.info(f"Available installers on SUCatalog ({'All entries' if show_full else 'Latest only'}):")
            for item in installers:
                logging.info(f"- {item['Title']} ({item['Version']} - {item['Build']}):\n  - Size: {utilities.human_fmt(item['InstallAssistant']['Size'])}\n  - Link: {item['InstallAssistant']['URL']}\n")
                index = self.list.InsertItem(self.list.GetItemCount(), f"{item['Title']}")
                self.list.SetItemImage(index, self._macos_version_to_icon(int(item['Build'][:2])))
                self.list.SetItem(index, 1, item['Version'])
                self.list.SetItem(index, 2, item['Build'])
                self.list.SetItem(index, 3, utilities.human_fmt(item['InstallAssistant']['Size']))
                self.list.SetItem(index, 4, item['PostDate'].strftime("%x"))
        else:
            logging.error("No installers found on SUCatalog")
            wx.MessageDialog(self.frame_modal, "Failed to download Installer Catalog from Apple", "Error", wx.OK | wx.ICON_ERROR).ShowModal()

        if show_full is False:
            self.list.Select(-1)

        self.list.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.on_select_list)
        self.list.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_select_list)

        self.select_button = wx.Button(self.frame_modal, label="Download", pos=(-1, -1), size=(150, -1))
        self.select_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        self.select_button.Bind(wx.EVT_BUTTON, lambda event, installers=installers: self.on_download_installer(installers))
        self.select_button.SetToolTip("Download the selected macOS Installer.")
        self.select_button.SetDefault()
        if show_full is True:
            self.select_button.Disable()

        self.copy_button = wx.Button(self.frame_modal, label="Copy Link", pos=(-1, -1), size=(80, -1))
        self.copy_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        if show_full is True:
            self.copy_button.Disable()
        self.copy_button.SetToolTip("Copy the download link of the selected macOS Installer.")
        self.copy_button.Bind(wx.EVT_BUTTON, lambda event, installers=installers: self.on_copy_link(installers))

        return_button = wx.Button(self.frame_modal, label="Return to Main Menu", pos=(-1, -1), size=(150, -1))
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        return_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))

        self.showolderversions_checkbox = wx.CheckBox(self.frame_modal, label="Show Older/Beta Versions", pos=(-1, -1))
        if show_full is True:
            self.showolderversions_checkbox.SetValue(True)
        self.showolderversions_checkbox.Bind(wx.EVT_CHECKBOX, lambda event: self._display_available_installers(event, self.showolderversions_checkbox.GetValue()))

        rectbox = wx.StaticBox(self.frame_modal, -1)
        rectsizer = wx.StaticBoxSizer(rectbox, wx.HORIZONTAL)
        rectsizer.Add(self.copy_button, 0, wx.EXPAND | wx.RIGHT, 5)
        rectsizer.Add(self.select_button, 0, wx.EXPAND | wx.LEFT, 5)

        checkboxsizer = wx.BoxSizer(wx.HORIZONTAL)
        checkboxsizer.Add(self.showolderversions_checkbox, 0, wx.ALIGN_CENTRE | wx.RIGHT, 5)

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.AddSpacer(10)
        sizer.Add(title_label, 0, wx.ALIGN_CENTRE | wx.ALL, 0)
        sizer.Add(self.list, 1, wx.EXPAND | wx.ALL, 10)
        sizer.Add(rectsizer, 0, wx.ALIGN_CENTRE | wx.ALL, 0)
        sizer.Add(checkboxsizer, 0, wx.ALIGN_CENTRE | wx.ALL, 15)
        sizer.Add(return_button, 0, wx.ALIGN_CENTRE | wx.BOTTOM, 15)

        self.frame_modal.SetSizer(sizer)
        self.frame_modal.ShowWindowModal()

    def on_copy_link(self, installers: dict) -> None:

        selected_item = self.list.GetFirstSelected()
        if selected_item != -1:
            clipboard = wx.Clipboard.Get()

            if not clipboard.IsOpened():
                clipboard.Open()

            clipboard.SetData(wx.TextDataObject(installers[selected_item]['InstallAssistant']['URL']))

            clipboard.Close()

            wx.MessageDialog(self.frame_modal, "Download link copied to clipboard", "", wx.OK | wx.ICON_INFORMATION).ShowModal()


    def on_select_list(self, event):
        if self.list.GetSelectedItemCount() > 0:
            self.select_button.Enable()
            self.copy_button.Enable()
        else:
            self.select_button.Disable()
            self.copy_button.Disable()

    def on_download_installer(self, installers: dict) -> None:
        """
        Download macOS installer
        """

        selected_item = self.list.GetFirstSelected()
        if selected_item != -1:
            selected_installer = installers[selected_item]

            logging.info(f"Selected macOS {selected_installer['Version']} ({selected_installer['Build']})")

            # Notify user whether their model is compatible with the selected installer
            problems = []
            model = self.constants.custom_model or self.constants.computer.real_model
            if model in smbios_data.smbios_dictionary:
                if selected_installer["InstallAssistant"]["XNUMajor"] >= os_data.os_data.ventura:
                    if smbios_data.smbios_dictionary[model]["CPU Generation"] <= cpu_data.CPUGen.penryn or model in ["MacPro4,1", "MacPro5,1", "Xserve3,1"]:
                        if model.startswith("MacBook"):
                            problems.append("Lack of internal Keyboard/Trackpad in macOS installer.")
                        else:
                            problems.append("Lack of internal Keyboard/Mouse in macOS installer.")

            if problems:
                logging.warning(f"Potential issues with {model} and {selected_installer['Version']} ({selected_installer['Build']}): {problems}")
                problems = "\n".join(problems)
                dlg = wx.MessageDialog(self.frame_modal, f"Your model ({model}) may not be fully supported by this installer. You may encounter the following issues:\n\n{problems}\n\nFor more information, see associated page. Otherwise, we recommend using macOS Monterey", "Potential Issues", wx.YES_NO | wx.CANCEL | wx.ICON_WARNING)
                dlg.SetYesNoCancelLabels("View Github Issue", "Download Anyways", "Cancel")
                result = dlg.ShowModal()
                if result == wx.ID_CANCEL:
                    return
                elif result == wx.ID_YES:
                    webbrowser.open("https://github.com/dortania/OpenCore-Legacy-Patcher/issues/1021")
                    return

            host_space = utilities.get_free_space()
            needed_space = selected_installer['InstallAssistant']['Size'] * 2
            if host_space < needed_space:
                logging.error(f"Insufficient space to download and extract: {utilities.human_fmt(host_space)} available vs {utilities.human_fmt(needed_space)} required")
                dlg = wx.MessageDialog(self.frame_modal, f"You do not have enough free space to download and extract this installer. Please free up some space and try again\n\n{utilities.human_fmt(host_space)} available vs {utilities.human_fmt(needed_space)} required", "Insufficient Space", wx.OK | wx.ICON_WARNING)
                dlg.ShowModal()
                return

            self.frame_modal.Close()

            download_obj = network_handler.DownloadObject(selected_installer['InstallAssistant']['URL'], self.constants.payload_path / "InstallAssistant.pkg")

            gui_download.DownloadFrame(
                self,
                title=self.title,
                global_constants=self.constants,
                download_obj=download_obj,
                item_name=f"macOS {selected_installer['Version']} ({selected_installer['Build']})",
                download_icon=self.constants.icons_path[self._macos_version_to_icon(selected_installer["InstallAssistant"]["XNUMajor"])]
            )

            if download_obj.download_complete is False:
                self.on_return_to_main_menu()
                return

            self._validate_installer(selected_installer['InstallAssistant']['IntegrityDataURL'])


    def _validate_installer(self, chunklist_link: str) -> None:
        """
        Validate macOS installer
        """
        self.SetSize((300, 200))
        for child in self.GetChildren():
            child.Destroy()

        # Title: Validating macOS Installer
        title_label = wx.StaticText(self, label="Validating macOS Installer", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Label: Validating chunk 0 of 0
        chunk_label = wx.StaticText(self, label="Validating chunk 0 of 0", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5))
        chunk_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        chunk_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self, range=100, pos=(-1, chunk_label.GetPosition()[1] + chunk_label.GetSize()[1] + 5), size=(270, 30))
        progress_bar.Centre(wx.HORIZONTAL)

        # Set size of frame
        self.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))
        self.Show()

        chunklist_stream = network_handler.NetworkUtilities().get(chunklist_link).content
        if chunklist_stream:
            logging.info("Validating macOS installer")
            utilities.disable_sleep_while_running()
            chunk_obj = integrity_verification.ChunklistVerification(self.constants.payload_path / Path("InstallAssistant.pkg"), chunklist_stream)
            if chunk_obj.chunks:
                progress_bar.SetValue(chunk_obj.current_chunk)
                progress_bar.SetRange(chunk_obj.total_chunks)

                wx.App.Get().Yield()
                chunk_obj.validate()

                while chunk_obj.status == integrity_verification.ChunklistStatus.IN_PROGRESS:
                    progress_bar.SetValue(chunk_obj.current_chunk)
                    chunk_label.SetLabel(f"Validating chunk {chunk_obj.current_chunk} of {chunk_obj.total_chunks}")
                    chunk_label.Centre(wx.HORIZONTAL)
                    wx.App.Get().Yield()

                if chunk_obj.status == integrity_verification.ChunklistStatus.FAILURE:
                    logging.error(f"Chunklist validation failed: Hash mismatch on {chunk_obj.current_chunk}")
                    wx.MessageBox(f"Chunklist validation failed: Hash mismatch on {chunk_obj.current_chunk}\n\nThis generally happens when downloading on unstable connections such as WiFi or cellular.\n\nPlease try redownloading again on a stable connection (ie. Ethernet)", "Corrupted Installer!", wx.OK | wx.ICON_ERROR)
                    self.on_return_to_main_menu()
                    return

        logging.info("macOS installer validated")

        # Extract installer
        title_label.SetLabel("Extracting macOS Installer")
        title_label.Centre(wx.HORIZONTAL)

        chunk_label.SetLabel("May take a few minutes...")
        chunk_label.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Start thread to extract installer
        self.result = False
        def extract_installer():
            self.result = macos_installer_handler.InstallerCreation().install_macOS_installer(self.constants.payload_path)

        thread = threading.Thread(target=extract_installer)
        thread.start()

        # Show frame
        self.Show()

        # Wait for thread to finish
        gui_support.wait_for_thread(thread)

        progress_bar_animation.stop_pulse()
        progress_bar.Hide()
        chunk_label.SetLabel("Successfully extracted macOS installer" if self.result is True else "Failed to extract macOS installer")
        chunk_label.Centre(wx.HORIZONTAL)

        # Create macOS Installer button
        create_installer_button = wx.Button(self, label="Create macOS Installer", pos=(-1, progress_bar.GetPosition()[1]), size=(170, 30))
        create_installer_button.Bind(wx.EVT_BUTTON, self.on_existing)
        create_installer_button.Centre(wx.HORIZONTAL)
        if self.result is False:
            create_installer_button.Disable()

        # Return to main menu button
        return_button = wx.Button(self, label="Return to Main Menu", pos=(-1, create_installer_button.GetPosition()[1] + create_installer_button.GetSize()[1]), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        return_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        self.SetSize((-1, return_button.GetPosition()[1] + return_button.GetSize()[1] + 40))

        # Show frame
        self.Show()

        if self.result is False:
            wx.MessageBox("An error occurred while extracting the macOS installer. Could be due to a corrupted installer", "Error", wx.OK | wx.ICON_ERROR)
            return

        user_input = wx.MessageBox("Finished extracting the installer, would you like to continue and create a macOS installer?", "Create macOS Installer?", wx.YES_NO | wx.ICON_QUESTION)
        if user_input == wx.YES:
            self.on_existing()


    def on_download(self, event: wx.Event) -> None:
        """
        Display available macOS versions to download
        """
        self.frame_modal.Close()
        self.parent.Hide()
        self._generate_catalog_frame()
        self.parent.Close()


    def on_existing(self, event: wx.Event = None) -> None:
        """
        Display local macOS installers
        """
        frames = [self, self.frame_modal, self.parent]
        for frame in frames:
            if frame:
                frame.Close()
        gui_macos_installer_flash.macOSInstallerFlashFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            **({"screen_location": self.GetScreenPosition()} if self else {})
        )
        for frame in frames:
            if frame:
                frame.Destroy()


    def on_return(self, event: wx.Event) -> None:
        """
        Return to main menu (dismiss frame)
        """
        self.frame_modal.Close()


    def on_return_to_main_menu(self, event: wx.Event = None) -> None:
        """
        Return to main menu
        """
        if self.frame_modal:
            self.frame_modal.Hide()
        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        main_menu_frame.Show()
        if self.frame_modal:
            self.frame_modal.Destroy()
        self.Destroy()

#gui_macos_installer_flash.py
"""
gui_macos_installer_flash.py: macOS Installer Flash Frame
"""

import wx
import logging
import plistlib
import tempfile
import threading
import subprocess

from pathlib import Path

from .. import constants

from ..datasets import os_data
from ..volume   import generate_copy_arguments

from ..wx_gui import (
    gui_main_menu,
    gui_build,
    gui_support
)
from ..support import (
    macos_installer_handler,
    utilities,
    network_handler,
    kdk_handler,
    metallib_handler,
    subprocess_wrapper
)


class macOSInstallerFlashFrame(wx.Frame):

    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing macOS Installer Flash Frame")
        super(macOSInstallerFlashFrame, self).__init__(parent, title=title, size=(350, 200), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, global_constants).generate()

        self.constants: constants.Constants = global_constants
        self.title: str = title

        self.available_installers_local: dict = {}
        self.available_disks: dict = {}
        self.prepare_result: bool = False

        self.progress_bar_animation: gui_support.GaugePulseCallback = None

        self.frame_modal: wx.Dialog = None

        self._generate_elements()

        self.Centre()
        self.Show()

        self._populate_installers()


    def _generate_elements(self) -> None:
        """
        Fetches local macOS Installers for users to select from
        """

        # Title: Fetching local macOS Installers
        title_label = wx.StaticText(self, label="Fetching local macOS Installers", pos=(-1,1))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self, range=100, pos=(-1, 30), size=(200, 30))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()
        self.progress_bar_animation = progress_bar_animation

        # Set size of frame
        self.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))


    def _populate_installers(self) -> None:
        # Grab installer catalog
        def fetch_installers():
            self.available_installers_local = macos_installer_handler.LocalInstallerCatalog().available_apps

        thread = threading.Thread(target=fetch_installers)
        thread.start()

        gui_support.wait_for_thread(thread)

        frame_modal = wx.Dialog(self, title=self.title, size=(350, 200))

        # Title: Select macOS Installer
        title_label = wx.StaticText(frame_modal, label="Select local macOS Installer", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # List of installers
        if self.available_installers_local:
            logging.info("Installer(s) found:")
            spacer = 10
            entries = len(self.available_installers_local)
            for app in self.available_installers_local:
                logging.info(f"- {self.available_installers_local[app]['Short Name']}: {self.available_installers_local[app]['Version']} ({self.available_installers_local[app]['Build']})")

                app_str = f"{self.available_installers_local[app]['Short Name']}"
                unsupported: bool = self.available_installers_local[app]['Minimum Host OS'] > self.constants.detected_os

                if unsupported:
                    min_str = os_data.os_conversion.convert_kernel_to_marketing_name(self.available_installers_local[app]['Minimum Host OS'])
                    app_str += f" (Requires {min_str})"
                else:
                    app_str += f": {self.available_installers_local[app]['Version']} ({self.available_installers_local[app]['Build']})"

                installer_button = wx.Button(frame_modal, label=app_str, pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + spacer), size=(300, 30))
                installer_button.Bind(wx.EVT_BUTTON, lambda event, temp=app: self.on_select(self.available_installers_local[temp]))
                installer_button.Centre(wx.HORIZONTAL)
                spacer += 25
                if unsupported:
                    installer_button.Disable()
                elif entries == 1:
                    installer_button.SetDefault()

        else:
            installer_button = wx.StaticText(frame_modal, label="No installers found in '/Applications'", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5))
            installer_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            installer_button.Centre(wx.HORIZONTAL)

        # Button: Return to Main Menu
        cancel_button = wx.Button(frame_modal, label="Return to Main Menu", pos=(-1, installer_button.GetPosition()[1] + installer_button.GetSize()[1]), size=(150, 30))
        cancel_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        cancel_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        frame_modal.SetSize((-1, cancel_button.GetPosition()[1] + cancel_button.GetSize()[1] + 40))

        self.progress_bar_animation.stop_pulse()

        frame_modal.ShowWindowModal()
        self.frame_modal = frame_modal


    def on_select(self, installer: dict) -> None:
        logging.info(f"Selected installer: {installer['Short Name']} ({installer['Version']} ({installer['Build']}))")
        self.frame_modal.Destroy()

        for child in self.GetChildren():
            child.Destroy()

        # Fetching information on local disks
        title_label = wx.StaticText(self, label="Fetching information on local disks", pos=(-1,1))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self, range=100, pos=(-1, 30), size=(200, 30))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set size of frame
        self.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))

        # Fetch local disks
        def _fetch_disks():
            self.available_disks = macos_installer_handler.InstallerCreation().list_disk_to_format()

            # Need to clean up output on pre-Sierra
            # Disk images are mixed in with regular disks (ex. payloads.dmg)
            ignore = ["disk image", "read-only", "virtual"]
            for disk in self.available_disks.copy():
                if any(string in self.available_disks[disk]['name'].lower() for string in ignore):
                    del self.available_disks[disk]


        thread = threading.Thread(target=_fetch_disks)
        thread.start()

        gui_support.wait_for_thread(thread)

        self.frame_modal = wx.Dialog(self, title=self.title, size=(350, 200))

        # Title: Select local disk
        title_label = wx.StaticText(self.frame_modal, label="Select local disk", pos=(-1,5))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Label: Selected USB will be erased, please backup any data
        warning_label = wx.StaticText(self.frame_modal, label="Selected USB will be erased, please backup any data", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5))
        warning_label.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
        warning_label.Centre(wx.HORIZONTAL)

        # List of disks
        if self.available_disks:
            spacer = 5
            entries = len(self.available_disks)
            logging.info("Available disks:")
            for disk in self.available_disks:
                logging.info(f" - {disk}: {self.available_disks[disk]['name']} - {utilities.human_fmt(self.available_disks[disk]['size'])}")
                disk_button = wx.Button(self.frame_modal, label=f"{disk}: {self.available_disks[disk]['name']} - {utilities.human_fmt(self.available_disks[disk]['size'])}", pos=(-1, warning_label.GetPosition()[1] + warning_label.GetSize()[1] + spacer), size=(300, 30))
                disk_button.Bind(wx.EVT_BUTTON, lambda event, temp=disk: self.on_select_disk(self.available_disks[temp], installer))
                disk_button.Centre(wx.HORIZONTAL)
                if entries == 1:
                    disk_button.SetDefault()
                spacer += 25
        else:
            disk_button = wx.StaticText(self.frame_modal, label="No disks found", pos=(-1, warning_label.GetPosition()[1] + warning_label.GetSize()[1] + 5))
            disk_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
            disk_button.Centre(wx.HORIZONTAL)

        # Search for disks again
        search_button = wx.Button(self.frame_modal, label="Search for disks again", pos=(-1, disk_button.GetPosition()[1] + disk_button.GetSize()[1]), size=(150, 30))
        search_button.Bind(wx.EVT_BUTTON, lambda event, temp=installer: self.on_select(temp))
        search_button.Centre(wx.HORIZONTAL)

        # Button: Return to Main Menu
        cancel_button = wx.Button(self.frame_modal, label="Return to Main Menu", pos=(-1, search_button.GetPosition()[1] + search_button.GetSize()[1] - 10), size=(150, 30))
        cancel_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        cancel_button.Centre(wx.HORIZONTAL)

        # Set size of frame
        self.frame_modal.SetSize((-1, cancel_button.GetPosition()[1] + cancel_button.GetSize()[1] + 40))

        progress_bar_animation.stop_pulse()

        self.frame_modal.ShowWindowModal()


    def on_select_disk(self, disk: dict, installer: dict) -> None:
        answer = wx.MessageBox(f"Are you sure you want to erase '{disk['name']}'?\nAll data will be lost, this cannot be undone.", "Confirmation", wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        if answer != wx.YES:
            return

        logging.info(f"Selected disk: {disk['name']}")

        self.frame_modal.Destroy()

        for child in self.GetChildren():
            child.Destroy()

        self.SetSize((450, -1))

        # Title: Creating Installer: {installer_name}
        title_label = wx.StaticText(self, label=f"Creating Installer: {installer['Short Name']}", pos=(-1,1))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Label: Creating macOS installers can take 30min+ on slower USB drives.
        warning_label = wx.StaticText(self, label="Creating macOS installers can take 30min+ on slower USB drives.", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 5))
        warning_label.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
        warning_label.Centre(wx.HORIZONTAL)

        # Label: We will notify you when the installer is ready.
        warning_label = wx.StaticText(self, label="We will notify you when the installer is ready.", pos=(-1, warning_label.GetPosition()[1] + warning_label.GetSize()[1] + 5))
        warning_label.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
        warning_label.Centre(wx.HORIZONTAL)

        # Label: Bytes Written: 0 MB
        bytes_written_label = wx.StaticText(self, label="Bytes Written: 0.00 MB", pos=(-1, warning_label.GetPosition()[1] + warning_label.GetSize()[1] + 5))
        bytes_written_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        bytes_written_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self, range=100, pos=(-1, bytes_written_label.GetPosition()[1] + bytes_written_label.GetSize()[1] + 5), size=(300, 30))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set size of frame
        self.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))
        self.Show()

        # Prepare resources
        if self._prepare_resources(installer['Path'], disk['identifier']) is False:
            logging.error("Failed to prepare resources, cannot continue.")
            wx.MessageBox("Failed to prepare resources, cannot continue.", "Error", wx.OK | wx.ICON_ERROR)
            self.on_return_to_main_menu()
            return

        # Base Size
        estimated_size = 16000
        # AutoPkg (700MB~)
        estimated_size += 700 if installer['OS'] >= os_data.os_data.big_sur else 0
        # KDK (700MB~, and overhead for copying to installer)
        estimated_size += 700 * 2 if installer['OS'] >= os_data.os_data.ventura else 0

        progress_bar_animation.stop_pulse()
        progress_bar.SetRange(estimated_size)

        # /dev/diskX -> diskX
        root_disk = disk['identifier'][5:]
        initial_bytes_written = float(utilities.monitor_disk_output(root_disk))
        self.result = False
        def _flash():
            logging.info(f"Flashing {installer['Path']} to {root_disk}")
            self.result = self._flash_installer(root_disk)

        thread = threading.Thread(target=_flash)
        thread.start()

        # Wait for installer to be created
        while thread.is_alive():
            try:
                total_bytes_written = float(utilities.monitor_disk_output(root_disk))
            except:
                total_bytes_written = initial_bytes_written
            bytes_written = total_bytes_written - initial_bytes_written
            wx.CallAfter(bytes_written_label.SetLabel, f"Bytes Written: {bytes_written:.2f} MB")
            try:
                bytes_written = int(bytes_written)
            except:
                bytes_written = 0
            wx.CallAfter(progress_bar.SetValue, bytes_written)

            wx.Yield()
            thread.join(timeout=self.constants.thread_sleep_interval)

        if self.result is False:
            logging.error("Failed to flash installer, cannot continue.")
            self.on_return_to_main_menu()
            return

        # Next verify the installer
        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        bytes_written_label.SetLabel("Validating Installer Integrity...")
        error_message = self._validate_installer_pkg(disk['identifier'])

        progress_bar_animation.stop_pulse()

        if error_message != "":
            progress_bar.SetValue(0)
            wx.MessageBox(f"Failed to validate installer, cannot continue.\n This can generally happen due to a faulty USB drive, as flashing is an intensive process that can trigger hardware faults not normally seen. \n\n{error_message}", "Corrupted Installer!", wx.OK | wx.ICON_ERROR)
            self.on_return_to_main_menu()
            return

        progress_bar.SetValue(estimated_size)

        if gui_support.CheckProperties(self.constants).host_can_build() is False:
            wx.MessageBox("Installer created successfully! If you want to install OpenCore to this USB, you will need to change the Target Model in settings", "Successfully created the macOS installer!", wx.OK | wx.ICON_INFORMATION)
            self.on_return_to_main_menu()
            return

        answer = wx.MessageBox("Installer created successfully, would you like to continue and Install OpenCore to this disk?", "Successfully created the macOS installer!", wx.YES_NO | wx.ICON_QUESTION)
        if answer != wx.YES:
            self.on_return_to_main_menu()
            return

        # Install OpenCore
        self.Hide()
        gui_build.BuildFrame(
            parent=None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )
        self.Destroy()


    def _prepare_resources(self, installer_path: str, disk: str) -> None:

        def prepare_script(self, installer_path: str, disk: str, constants: constants.Constants):
            self.prepare_result = macos_installer_handler.InstallerCreation().generate_installer_creation_script(constants.payload_path, installer_path, disk)

        thread = threading.Thread(target=prepare_script, args=(self, installer_path, disk, self.constants))
        thread.start()

        gui_support.wait_for_thread(thread)

        return self.prepare_result


    def _flash_installer(self, disk) -> bool:
        utilities.disable_sleep_while_running()
        logging.info("Creating macOS installer")

        thread = threading.Thread(target=self._auto_package_handler)
        thread.start()

        # print contents of installer.sh
        with open(self.constants.installer_sh_path, "r") as f:
            logging.info(f"installer.sh contents:\n{f.read()}")

        args   = ["/bin/sh", self.constants.installer_sh_path]
        result = subprocess_wrapper.run_as_root(args, capture_output=True, text=True)
        output = result.stdout
        error  = result.stderr if result.stderr else ""

        if "Install media now available at" not in output:
            logging.info("Failed to create macOS installer")
            popup = wx.MessageDialog(self, f"Failed to create macOS installer\n\nOutput: {output}\n\nError: {error}", "Error", wx.OK | wx.ICON_ERROR)
            popup.ShowModal()
            return False

        logging.info("Successfully created macOS installer")

        # wait for download_thread to finish
        # though highly unlikely this thread is still alive (flashing an Installer will take a while)
        gui_support.wait_for_thread(thread)

        logging.info("Installing Root Patcher to drive")
        self._install_installer_pkg(disk)

        utilities.enable_sleep_after_running()
        return True


    def _auto_package_handler(self):
        """
        Function's main goal is to grab the correct AutoPkg-Assets.pkg and unzip it
        Note the following:
            - When running a release build, pull from Github's release page with the same versioning
            - When running from source/unable to find on Github, use the nightly.link variant
            - If nightly also fails, fall back to the manually uploaded variant
        """
        link = self.constants.installer_pkg_url
        if network_handler.NetworkUtilities(link).validate_link() is False:
            logging.info("Stock Install.pkg is missing on Github, falling back to Nightly")
            link = self.constants.installer_pkg_url_nightly

        if link.endswith(".zip"):
            path = self.constants.installer_pkg_zip_path
        else:
            path = self.constants.installer_pkg_path

        autopkg_download = network_handler.DownloadObject(link, path)
        autopkg_download.download(spawn_thread=False)

        if autopkg_download.download_complete is False:
            logging.warning("Failed to download Install.pkg")
            logging.warning(autopkg_download.error_msg)
            return

        # Download thread will re-enable Idle Sleep after downloading
        utilities.disable_sleep_while_running()
        if not str(path).endswith(".zip"):
            return
        if Path(self.constants.installer_pkg_path).exists():
            subprocess.run(["/bin/rm", self.constants.installer_pkg_path])
        subprocess.run(["/usr/bin/ditto", "-V", "-x", "-k", "--sequesterRsrc", "--rsrc", self.constants.installer_pkg_zip_path, self.constants.payload_path])


    def _install_installer_pkg(self, disk):
        disk = disk + "s2" # ESP sits at 1, and we know macOS will have created the main partition at 2

        if not Path(self.constants.installer_pkg_path).exists():
            return

        path = utilities.grab_mount_point_from_disk(disk)
        if not Path(path + "/System/Library/CoreServices/SystemVersion.plist").exists():
            return

        os_version = plistlib.load(Path(path + "/System/Library/CoreServices/SystemVersion.plist").open("rb"))
        kernel_version = os_data.os_conversion.os_to_kernel(os_version["ProductVersion"])
        if int(kernel_version) < os_data.os_data.big_sur:
            logging.info("Installer unsupported, requires Big Sur or newer")
            return

        subprocess.run(["/bin/mkdir", "-p", f"{path}/Library/Packages/"])
        subprocess.run(generate_copy_arguments(self.constants.installer_pkg_path, f"{path}/Library/Packages/"))

        # Chainload KDK and Metallib
        self._chainload_metallib(os_version["ProductBuildVersion"], os_version["ProductVersion"], Path(path + "/Library/Packages/"))
        self._kdk_chainload(os_version["ProductBuildVersion"], os_version["ProductVersion"], Path(path + "/Library/Packages/"))


    def _kdk_chainload(self, build: str, version: str, download_dir: str):
        """
        Download the correct KDK to be chainloaded in the macOS installer

        Parameters
            build (str): The build number of the macOS installer (e.g. 20A5343j)
            version (str): The version of the macOS installer (e.g. 11.0.1)
        """

        kdk_dmg_path = Path(download_dir) / "KDK.dmg"
        kdk_pkg_path = Path(download_dir) / "KDK.pkg"

        if kdk_dmg_path.exists():
            kdk_dmg_path.unlink()
        if kdk_pkg_path.exists():
            kdk_pkg_path.unlink()

        logging.info("Initiating KDK download")
        logging.info(f"- Build: {build}")
        logging.info(f"- Version: {version}")
        logging.info(f"- Working Directory: {download_dir}")

        kdk_obj = kdk_handler.KernelDebugKitObject(self.constants, build, version, ignore_installed=True)
        if kdk_obj.success is False:
            logging.info("Failed to retrieve KDK")
            logging.info(kdk_obj.error_msg)
            return

        kdk_download_obj = kdk_obj.retrieve_download(override_path=kdk_dmg_path)
        if kdk_download_obj is None:
            logging.info("Failed to retrieve KDK")
            logging.info(kdk_obj.error_msg)

        # Check remaining disk space before downloading
        space = utilities.get_free_space(download_dir)
        if space < (kdk_obj.kdk_url_expected_size * 2):
            logging.info("Not enough disk space to download and install KDK")
            logging.info(f"Attempting to download locally first")
            if space < kdk_obj.kdk_url_expected_size:
                logging.info("Not enough disk space to install KDK, skipping")
                return
            # Ideally we'd download the KDK onto the disk to display progress in the UI
            # However we'll just download to our temp directory and move it to the target disk
            kdk_dmg_path = self.constants.kdk_download_path

        kdk_download_obj.download(spawn_thread=False)
        if kdk_download_obj.download_complete is False:
            logging.info("Failed to download KDK")
            logging.info(kdk_download_obj.error_msg)
            return

        if not kdk_dmg_path.exists():
            logging.info(f"KDK missing: {kdk_dmg_path}")
            return

        # Now that we have a KDK, extract it to get the pkg
        with tempfile.TemporaryDirectory() as mount_point:
            logging.info("Mounting KDK")
            result = subprocess.run(["/usr/bin/hdiutil", "attach", kdk_dmg_path, "-mountpoint", mount_point, "-nobrowse"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info("Failed to mount KDK")
                subprocess_wrapper.log(result)
                return

            logging.info("Copying KDK")
            subprocess.run(generate_copy_arguments(f"{mount_point}/KernelDebugKit.pkg", kdk_pkg_path))

            logging.info("Unmounting KDK")
            result = subprocess.run(["/usr/bin/hdiutil", "detach", mount_point], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            if result.returncode != 0:
                logging.info("Failed to unmount KDK")
                subprocess_wrapper.log(result)
                return

        logging.info("Removing KDK Disk Image")
        kdk_dmg_path.unlink()


    def _chainload_metallib(self, build: str, version: str, download_dir: str):
        """
        Download the correct Metallib to be chainloaded in the macOS installer
        """

        metallib_pkg_path = Path(download_dir) / "MetallibSupportPkg.pkg"

        if metallib_pkg_path.exists():
            metallib_pkg_path.unlink()

        logging.info("Initiating Metallib download")
        logging.info(f"- Build: {build}")
        logging.info(f"- Version: {version}")
        logging.info(f"- Working Directory: {download_dir}")

        metallib_obj = metallib_handler.MetalLibraryObject(self.constants, build, version, ignore_installed=True)
        if metallib_obj.success is False:
            logging.info("Failed to retrieve Metallib")
            logging.info(metallib_obj.error_msg)
            return

        metallib_download_obj = metallib_obj.retrieve_download(override_path=metallib_pkg_path)
        if metallib_download_obj is None:
            logging.info("Failed to retrieve Metallib")
            logging.info(metallib_obj.error_msg)

        # Check remaining disk space before downloading
        space = utilities.get_free_space(download_dir)
        size = 100 * 1024 * 1024
        if space < size:
            logging.info("Not enough disk space to download and install Metallib")
            return

        metallib_download_obj.download(spawn_thread=False)
        if metallib_download_obj.download_complete is False:
            logging.info("Failed to download Metallib")
            logging.info(metallib_download_obj.error_msg)
            return

        if not metallib_pkg_path.exists():
            logging.info(f"Metallib missing: {metallib_pkg_path}")
            return


    def _validate_installer_pkg(self, disk: str) -> bool:
        logging.info("Validating installer pkg")
        error_message = ""
        def _integrity_check():
            nonlocal error_message
            for folder in Path(utilities.grab_mount_point_from_disk(disk + "s2")).glob("*.app"):
                if folder.is_dir():
                    dmg_path = folder / "Contents" / "SharedSupport" / "SharedSupport.dmg"
                    break

            if not Path(dmg_path).exists():
                logging.error(f"Failed to find {dmg_path}")
                error_message = f"Failed to find {dmg_path}"
                return error_message
            result = subprocess.run(["/usr/bin/hdiutil", "verify", dmg_path],stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            if result.returncode != 0:
                if result.stdout:
                    logging.error(result.stdout.decode("utf-8"))
                    error_message = "STDOUT: " + result.stdout.decode("utf-8")
                if result.stderr:
                    logging.error(result.stderr.decode("utf-8"))
                    error_message += "\n\nSTDERR: " + result.stderr.decode("utf-8")


        thread = threading.Thread(target=_integrity_check)
        thread.start()
        gui_support.wait_for_thread(thread)

        if error_message == "":
            logging.info("Installer pkg validated")
            return error_message

        return error_message


    def on_return_to_main_menu(self, event: wx.Event = None):
        if self.frame_modal:
            self.frame_modal.Hide()
        if self:
            if isinstance(self, wx.Frame):
                self.Hide()
        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetScreenPosition()
        )
        main_menu_frame.Show()
        if self.frame_modal:
            self.frame_modal.Destroy()
        if self:
            if isinstance(self, wx.Frame):
                self.Destroy()

#gui_main_menu.py
"""
gui_main_menu.py: Generate GUI for main menu
"""

import wx
import wx.html2

import sys
import logging
import requests
import markdown2
import threading
import webbrowser

from .. import constants

from ..support import (
    global_settings,
    updates
)
from ..datasets import (
    os_data,
    css_data
)
from ..wx_gui import (
    gui_build,
    gui_macos_installer_download,
    gui_support,
    gui_help,
    gui_settings,
    gui_sys_patch_display,
    gui_update,
)


class MainFrame(wx.Frame):
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing Main Menu Frame")
        super(MainFrame, self).__init__(parent, title=title, size=(600, 400), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, global_constants).generate()

        self.constants: constants.Constants = global_constants
        self.title: str = title

        self.model_label: wx.StaticText = None
        self.build_button: wx.Button = None

        self.constants.update_stage = gui_support.AutoUpdateStages.INACTIVE

        self._generate_elements()

        self.Centre()
        self.Show()


        self._preflight_checks()


    def _generate_elements(self) -> None:
        """
        Generate UI elements for the main menu

        Format:
          - Title label: OpenCore Legacy Patcher v{X.Y.Z}
          - Text:        Model: {Build or Host Model}
          - Buttons:
            - Build and Install OpenCore
            - Post-Install Root Patch
            - Create macOS Installer
            - Settings
            - Help
          - Text:        Copyright
        """

        # Title label: OpenCore Legacy Patcher v{X.Y.Z}
        title_label = wx.StaticText(self, label=f"OpenCore Legacy Patcher {'' if self.constants.special_build else ''}{self.constants.patcher_version}{' (Nightly)' if not self.constants.commit_info[0].startswith('refs/tags') else ''}", pos=(-1, 10))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Text: Model: {Build or Host Model}
        model_label = wx.StaticText(self, label=f"Model: {self.constants.custom_model or self.constants.computer.real_model}", pos=(-1, title_label.GetPosition()[1] + 25
                                                                                                                                    ))
        model_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        model_label.Centre(wx.HORIZONTAL)
        self.model_label = model_label

        # Buttons:
        menu_buttons = {
            "Build and Install OpenCore": {
                "function": self.on_build_and_install,
                "description": [
                    "Prepares provided drive to be able",
                    "to boot unsupported OSes.",
                    "Use on installers or internal drives."
                ],
                "icon": str(self.constants.icns_resource_path / "OC-Build.icns"),
            },
            "Create macOS Installer": {
                "function": self.on_create_macos_installer,
                "description": [
                    "Download and flash a macOS",
                    "Installer for your system.",
                ],
                "icon": str(self.constants.icns_resource_path / "OC-Installer.icns"),
            },
            "âï¸ Settings": {
                "function": self.on_settings,
                "description": [
                ],
            },
            "Post-Install Root Patch": {
                "function": self.on_post_install_root_patch,
                "description": [
                    "Installs hardware drivers and",
                    "patches for your system after",
                    "installing a new version of macOS.",
                ],
                "icon": str(self.constants.icns_resource_path / "OC-Patch.icns"),
            },

            "Support": {
                "function": self.on_help,
                "description": [
                    "Resources for OpenCore Legacy",
                    "Patcher.",
                ],
                "icon": str(self.constants.icns_resource_path / "OC-Support.icns"),
            },
        }
        button_x = 30
        button_y = model_label.GetPosition()[1] + 30
        rollover = len(menu_buttons) / 2
        if rollover % 1 != 0:
            rollover = int(rollover) + 1
        index = 0
        max_height = 0
        for button_name, button_function in menu_buttons.items():
            # place icon
            if "icon" in button_function:
                icon = wx.StaticBitmap(self, bitmap=wx.Bitmap(button_function["icon"], wx.BITMAP_TYPE_ICON), pos=(button_x - 10, button_y), size=(64, 64))
                if button_name == "Post-Install Root Patch":
                    icon.SetPosition((-1, button_y + 7))
                if button_name == "Create macOS Installer":
                    icon.SetPosition((button_x - 5, button_y + 3))
                if button_name == "Support":
                    # icon_mac.SetSize((80, 80))
                    icon.SetPosition((button_x - 7, button_y + 3))
                if button_name == "Build and Install OpenCore":
                    icon.SetSize((70, 70))
            if button_name == "âï¸ Settings":
                button_y += 5

            button = wx.Button(self, label=button_name, pos=(button_x + 70, button_y), size=(180, 30))
            button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            button.Bind(wx.EVT_BUTTON, lambda event, function=button_function["function"]: function(event))
            button_y += 30

            # # Text: Description
            description_label = wx.StaticText(self, label='\n'.join(button_function["description"]), pos=(button_x + 75, button.GetPosition()[1] + button.GetSize()[1] + 3))
            description_label.SetFont(gui_support.font_factory(10, wx.FONTWEIGHT_NORMAL))
            # button_y += 15

            for i, line in enumerate(button_function["description"]):
                if line == "":
                    continue
                if i == 0:
                    button_y += 11
                else:
                    button_y += 13

            button_y += 25

            if button_name == "Build and Install OpenCore":
                self.build_button = button
                if gui_support.CheckProperties(self.constants).host_can_build() is False:
                    button.Disable()
            elif button_name == "Post-Install Root Patch":
                if self.constants.detected_os < os_data.os_data.big_sur:
                    button.Disable()
            elif button_name == "âï¸ Settings":
                button.SetSize((100, -1))
                button.Centre(wx.HORIZONTAL)
                description_label.Centre(wx.HORIZONTAL)

            index += 1
            if index == rollover:
                max_height = button_y
                button_x = 320
                button_y = model_label.GetPosition()[1] + 30


        # Text: Copyright
        copy_label = wx.StaticText(self, label=self.constants.copyright_date, pos=(-1, max_height - 15))
        copy_label.SetFont(gui_support.font_factory(10, wx.FONTWEIGHT_NORMAL))
        copy_label.Centre(wx.HORIZONTAL)

        # Set window size
        self.SetSize((-1, copy_label.GetPosition()[1] + 50))


    def _preflight_checks(self):
        if (
                self.constants.computer.build_model != None and
                self.constants.computer.build_model != self.constants.computer.real_model and
                self.constants.host_is_hackintosh is False
            ):
            # Notify user they're booting an unsupported configuration
            pop_up = wx.MessageDialog(
                self,
                f"We found you are currently booting OpenCore built for a different unit: {self.constants.computer.build_model}\n\nWe builds configs to match individual units and cannot be mixed or reused with different Macs.\n\nPlease Build and Install a new OpenCore config, and reboot your Mac.",
                "Unsupported Configuration Detected!",
                style=wx.OK | wx.ICON_EXCLAMATION
            )
            pop_up.ShowModal()
            self.on_build_and_install()
            return

        if "--update_installed" in sys.argv and self.constants.has_checked_updates is False and gui_support.CheckProperties(self.constants).host_can_build():
            # Notify user that the update has been installed
            self.constants.has_checked_updates = True
            pop_up = wx.MessageDialog(
                self,
                f"OpenCore Legacy Patcher has been updated to the latest version: {self.constants.patcher_version}\n\nWould you like to update OpenCore and your root volume patches?",
                "Update successful!",
                style=wx.YES_NO | wx.YES_DEFAULT | wx.ICON_INFORMATION
            )
            pop_up.ShowModal()

            if pop_up.GetReturnCode() != wx.ID_YES:
                logging.info("Skipping OpenCore and root volume patch update...")
                return


            logging.info("Updating OpenCore and root volume patches...")
            self.constants.update_stage = gui_support.AutoUpdateStages.CHECKING
            self.Hide()
            pos = self.GetPosition()
            gui_build.BuildFrame(
                parent=None,
                title=self.title,
                global_constants=self.constants,
                screen_location=pos
            )
            self.Close()

        threading.Thread(target=self._check_for_updates).start()


    def _check_for_updates(self):
        if self.constants.has_checked_updates is True:
            return

        ignore_updates = global_settings.GlobalEnviromentSettings().read_property("IgnoreAppUpdates")
        if ignore_updates is True:
            self.constants.ignore_updates = True
            return

        self.constants.ignore_updates = False
        self.constants.has_checked_updates = True
        dict = updates.CheckBinaryUpdates(self.constants).check_binary_updates()
        if not dict:
            return

        version = dict["Version"]
        logging.info(f"New version: {version}")

        wx.CallAfter(self.on_update, dict["Link"], version, dict["Github Link"])

    def on_build_and_install(self, event: wx.Event = None):
        self.Hide()
        gui_build.BuildFrame(
            parent=None,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )
        self.Destroy()


    def on_post_install_root_patch(self, event: wx.Event = None):
        gui_sys_patch_display.SysPatchDisplayFrame(
            parent=self,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )


    def on_create_macos_installer(self, event: wx.Event = None):
        gui_macos_installer_download.macOSInstallerDownloadFrame(
            parent=self,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )


    def on_settings(self, event: wx.Event = None):
        gui_settings.SettingsFrame(
            parent=self,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )

    def on_help(self, event: wx.Event = None):
        gui_help.HelpFrame(
            parent=self,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition()
        )

    def on_update(self, oclp_url: str, oclp_version: str, oclp_github_url: str):

        ID_GITHUB = wx.NewId()
        ID_UPDATE = wx.NewId()

        url = "https://api.github.com/repos/dortania/OpenCore-Legacy-Patcher/releases/latest"
        response = requests.get(url).json()
        try:
            changelog = response["body"].split("## Asset Information")[0]
        except: #if user constantly checks for updates, github will rate limit them
            changelog = """## Unable to fetch changelog

Please check the Github page for more information about this release."""

        html_markdown = markdown2.markdown(changelog, extras=["tables"])
        html_css = css_data.updater_css
        frame = wx.Dialog(None, -1, title="", size=(650, 500))
        frame.SetMinSize((650, 500))
        frame.SetWindowStyle(wx.STAY_ON_TOP)
        panel = wx.Panel(frame)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.AddSpacer(10)
        self.title_text = wx.StaticText(panel, label="A new version of OpenCore Legacy Patcher is available!")
        self.description = wx.StaticText(panel, label=f"OpenCore Legacy Patcher {oclp_version} is now available - You have {self.constants.patcher_version}{' (Nightly)' if not self.constants.commit_info[0].startswith('refs/tags') else ''}. Would you like to update?")
        self.title_text.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        self.description.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        self.web_view = wx.html2.WebView.New(panel, style=wx.BORDER_SUNKEN)
        html_code = f'''
<html>
    <head>
        <style>
            {html_css}
        </style>
    </head>
    <body class="markdown-body">
        {html_markdown.replace("<a href=", "<a target='_blank' href=")}
    </body>
</html>
'''
        self.web_view.SetPage(html_code, "")
        self.web_view.Bind(wx.html2.EVT_WEBVIEW_NEWWINDOW, self._onWebviewNav)
        self.web_view.EnableContextMenu(False)
        self.close_button = wx.Button(panel, label="Dismiss")
        self.close_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(wx.ID_CANCEL))
        self.view_button = wx.Button(panel, ID_GITHUB, label="View on GitHub")
        self.view_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(ID_GITHUB))
        self.install_button = wx.Button(panel, label="Download and Install")
        self.install_button.Bind(wx.EVT_BUTTON, lambda event: frame.EndModal(ID_UPDATE))
        self.install_button.SetDefault()

        buttonsizer = wx.BoxSizer(wx.HORIZONTAL)
        buttonsizer.Add(self.close_button, 0, wx.ALIGN_CENTRE | wx.RIGHT, 5)
        buttonsizer.Add(self.view_button, 0, wx.ALIGN_CENTRE | wx.LEFT|wx.RIGHT, 5)
        buttonsizer.Add(self.install_button, 0, wx.ALIGN_CENTRE | wx.LEFT, 5)
        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.Add(self.title_text, 0, wx.ALIGN_CENTRE | wx.TOP, 20)
        sizer.Add(self.description, 0, wx.ALIGN_CENTRE | wx.BOTTOM, 20)
        sizer.Add(self.web_view, 1, wx.EXPAND | wx.LEFT|wx.RIGHT, 10)
        sizer.Add(buttonsizer, 0, wx.ALIGN_RIGHT | wx.ALL, 20)
        panel.SetSizer(sizer)
        frame.Centre()

        result = frame.ShowModal()


        if result == ID_GITHUB:
            webbrowser.open(oclp_github_url)
        elif result == ID_UPDATE:
            gui_update.UpdateFrame(
            parent=self,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.GetPosition(),
            url=oclp_url,
            version_label=oclp_version
        )

        frame.Destroy()

    def _onWebviewNav(self, event):
        url = event.GetURL()
        webbrowser.open(url)

#gui_settings
"""
gui_settings.py: Settings Frame for the GUI
"""

import wx
import wx.adv
import pprint
import logging
import py_sip_xnu
import subprocess

from pathlib import Path

from .. import constants

from ..sys_patch import sys_patch

from ..wx_gui import (
    gui_support,
    gui_update
)
from ..support import (
    global_settings,
    defaults,
    generate_smbios,
    network_handler,
    subprocess_wrapper
)
from ..datasets import (
    model_array,
    sip_data,
    smbios_data,
    os_data,
    cpu_data
)


class SettingsFrame(wx.Frame):
    """
    Modal-based Settings Frame
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing Settings Frame")
        self.constants: constants.Constants = global_constants
        self.title: str = title
        self.parent: wx.Frame = parent

        self.hyperlink_colour = (25, 179, 231)

        self.settings = self._settings()

        self.frame_modal = wx.Dialog(parent, title=title, size=(600, 685))

        self._generate_elements(self.frame_modal)
        self.frame_modal.ShowWindowModal()

    def _generate_elements(self, frame: wx.Frame = None) -> None:
        """
        Generates elements for the Settings Frame
        Uses wx.Notebook to implement a tabbed interface
        and relies on 'self._settings()' for populating
        """

        notebook = wx.Notebook(frame)
        notebook.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))

        sizer = wx.BoxSizer(wx.VERTICAL)
        sizer.AddSpacer(10)

        model_label = wx.StaticText(frame, label="Target Model", pos=(-1, -1))
        model_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
        sizer.Add(model_label, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        model_choice = wx.Choice(frame, choices=model_array.SupportedSMBIOS + ["Host Model"], pos=(-1, -1), size=(150, -1))
        model_choice.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        model_choice.Bind(wx.EVT_CHOICE, lambda event: self.on_model_choice(event, model_choice))
        selection = self.constants.custom_model if self.constants.custom_model else "Host Model"
        model_choice.SetSelection(model_choice.FindString(selection))
        sizer.Add(model_choice, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        model_description = wx.StaticText(frame, label="Overrides Mac Model the Patcher will build for.", pos=(-1, -1))
        model_description.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
        sizer.Add(model_description, 0, wx.ALIGN_CENTER | wx.ALL, 5)

        tabs = list(self.settings.keys())
        if not Path("~/.dortania_developer").expanduser().exists():
            tabs.remove("Developer")
        for tab in tabs:
            panel = wx.Panel(notebook)
            notebook.AddPage(panel, tab)

        sizer.Add(notebook, 1, wx.EXPAND | wx.ALL, 10)

        # Add return button
        return_button = wx.Button(frame, label="Return", pos=(-1, -1), size=(100, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return)
        return_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        sizer.Add(return_button, 0, wx.ALIGN_CENTER | wx.ALL, 10)

        frame.SetSizer(sizer)

        horizontal_center = frame.GetSize()[0] / 2
        for tab in tabs:
            if tab not in self.settings:
                continue

            stock_height = 0
            stock_width = 20

            height = stock_height
            width = stock_width

            lowest_height_reached = height
            highest_height_reached = height

            panel = notebook.GetPage(tabs.index(tab))

            for setting, setting_info in self.settings[tab].items():
                if setting_info["type"] == "populate":
                    # execute populate function
                    if setting_info["args"] == wx.Frame:
                        setting_info["function"](panel)
                    else:
                        raise Exception("Invalid populate function")
                    continue

                if setting_info["type"] == "title":
                    stock_height = lowest_height_reached
                    height = stock_height
                    width = stock_width

                    height += 10

                    # Add title
                    title = wx.StaticText(panel, label=setting, pos=(-1, -1))
                    title.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))

                    title.SetPosition((int(horizontal_center) - int(title.GetSize()[0] / 2) - 15, height))
                    highest_height_reached = height + title.GetSize()[1] + 10
                    height += title.GetSize()[1] + 10
                    continue

                if setting_info["type"] == "sub_title":
                    # Add sub-title
                    sub_title = wx.StaticText(panel, label=setting, pos=(-1, -1))
                    sub_title.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))

                    sub_title.SetPosition((int(horizontal_center) - int(sub_title.GetSize()[0] / 2) - 15, height))
                    highest_height_reached = height + sub_title.GetSize()[1] + 10
                    height += sub_title.GetSize()[1] + 10
                    continue

                if setting_info["type"] == "wrap_around":
                    height = highest_height_reached
                    width = 300 if width is stock_width else stock_width
                    continue

                if setting_info["type"] == "checkbox":
                    # Add checkbox, and description underneath
                    checkbox = wx.CheckBox(panel, label=setting, pos=(10 + width, 10 + height), size = (300,-1))

                    value = False
                    if "value" in setting_info:
                        try:
                            value = bool(setting_info["value"])
                        except ValueError:
                            logging.error(f"Invalid value for {setting}, got {setting_info['value']} (type: {type(setting_info['value'])})")
                            value = False

                    checkbox.SetValue(value)
                    checkbox.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                    event = lambda event, warning=setting_info["warning"] if "warning" in setting_info else "", override=bool(setting_info["override_function"]) if "override_function" in setting_info else False: self.on_checkbox(event, warning, override)
                    checkbox.Bind(wx.EVT_CHECKBOX, event)
                    if "condition" in setting_info:
                        checkbox.Enable(setting_info["condition"])
                        if setting_info["condition"] is False:
                            checkbox.SetValue(False)

                elif setting_info["type"] == "spinctrl":
                    # Add spinctrl, and description underneath
                    spinctrl = wx.SpinCtrl(panel, value=str(setting_info["value"]), pos=(width - 20, 10 + height), min=setting_info["min"], max=setting_info["max"], size = (45,-1))
                    spinctrl.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                    spinctrl.Bind(wx.EVT_TEXT, lambda event, variable=setting: self.on_spinctrl(event, variable))
                    # Add label next to spinctrl
                    label = wx.StaticText(panel, label=setting, pos=(spinctrl.GetSize()[0] + width - 16, spinctrl.GetPosition()[1]))
                    label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                elif setting_info["type"] == "choice":
                    # Title
                    title = wx.StaticText(panel, label=setting, pos=(width + 30, 10 + height))
                    title.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                    height += title.GetSize()[1] + 10

                    # Add combobox, and description underneath
                    choice = wx.Choice(panel, pos=(width + 25, 10 + height), choices=setting_info["choices"], size = (150,-1))
                    choice.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                    choice.SetSelection(choice.FindString(setting_info["value"]))
                    if "override_function" in setting_info:
                        choice.Bind(wx.EVT_CHOICE, lambda event, variable=setting: self.settings[tab][variable]["override_function"](event))
                    else:
                        choice.Bind(wx.EVT_CHOICE, lambda event, variable=setting: self.on_choice(event, variable))
                    height += 10
                elif setting_info["type"] == "button":
                    button = wx.Button(panel, label=setting, pos=(width + 25, 10 + height), size = (200,-1))
                    button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                    button.Bind(wx.EVT_BUTTON, lambda event, variable=setting: self.settings[tab][variable]["function"](event))
                    height += 10

                else:
                    raise Exception("Invalid setting type")

                lines = '\n'.join(setting_info["description"])
                description = wx.StaticText(panel, label=lines, pos=(30 + width, 10 + height + 20))
                description.SetFont(gui_support.font_factory(11, wx.FONTWEIGHT_NORMAL))
                height += 40
                if "condition" in setting_info:
                    if setting_info["condition"] is False:
                        description.SetForegroundColour((128, 128, 128))

                # Check number of lines in description, and adjust spacer accordingly
                for i, line in enumerate(lines.split('\n')):
                    if line == "":
                        continue
                    if i == 0:
                        height += 11
                    else:
                        height += 13

                if height > lowest_height_reached:
                    lowest_height_reached = height


    def _settings(self) -> dict:
        """
        Generates a dictionary of settings to be used in the GUI
        General format:
        {
            "Tab Name": {
                "type": "title" | "checkbox" | "spinctrl" | "populate" | "wrap_around",
                "value": bool | int | str,
                "variable": str,  (Variable name)
                "constants_variable": str, (Constants variable name, if different from "variable")
                "description": [str, str, str], (List of strings)
                "warning": str, (Optional) (Warning message to be displayed when checkbox is checked)
                "override_function": function, (Optional) (Function to be executed when checkbox is checked)
            }
        }
        """

        models = [model for model in smbios_data.smbios_dictionary if "_" not in model and " " not in model and smbios_data.smbios_dictionary[model]["Board ID"] is not None]
        socketed_imac_models = ["iMac9,1", "iMac10,1", "iMac11,1", "iMac11,2", "iMac11,3", "iMac12,1", "iMac12,2"]
        socketed_gpu_models = socketed_imac_models + ["MacPro3,1", "MacPro4,1", "MacPro5,1", "Xserve2,1", "Xserve3,1"]

        settings = {
            "Build": {
                "General": {
                    "type": "title",
                },
                "FireWire Booting": {
                    "type": "checkbox",
                    "value": self.constants.firewire_boot,
                    "variable": "firewire_boot",
                    "description": [
                        "Enable booting macOS from",
                        "FireWire drives.",
                    ],
                    "condition": not (generate_smbios.check_firewire(self.constants.custom_model or self.constants.computer.real_model) is False)
                },
                "XHCI Booting": {
                    "type": "checkbox",
                    "value": self.constants.xhci_boot,
                    "variable": "xhci_boot",
                    "description": [
                        "Enable booting macOS from add-in",
                        "USB 3.0 expansion cards on systems",
                        "without native support.",
                    ],
                    "condition": not gui_support.CheckProperties(self.constants).host_has_cpu_gen(cpu_data.CPUGen.ivy_bridge) # Sandy Bridge and older do not natively support XHCI booting
                },
                "NVMe Booting": {
                    "type": "checkbox",
                    "value": self.constants.nvme_boot,
                    "variable": "nvme_boot",
                    "description": [
                        "Enable booting macOS from NVMe",
                        "drives on systems without native",
                        "support.",
                        "Note: Requires Firmware support",
                        "for OpenCore to load from NVMe.",
                    ],
                    "condition": not gui_support.CheckProperties(self.constants).host_has_cpu_gen(cpu_data.CPUGen.ivy_bridge) # Sandy Bridge and older do not natively support NVMe booting
                },
                "wrap_around 2": {
                    "type": "wrap_around",
                },
                "OpenCore Vaulting": {
                    "type": "checkbox",
                    "value": self.constants.vault,
                    "variable": "vault",
                    "description": [
                        "Digitally sign OpenCore to prevent",
                        "tampering or corruption."
                    ],
                },

                "Show OpenCore Boot Picker": {
                    "type": "checkbox",
                    "value": self.constants.showpicker,
                    "variable": "showpicker",
                    "description": [
                        "When disabled, users can hold ESC to",
                        "show picker in the firmware.",
                    ],
                },
                "Boot Picker Timeout": {
                    "type": "spinctrl",
                    "value": self.constants.oc_timeout,
                    "variable": "oc_timeout",
                    "description": [
                        "Timeout before boot picker selects default",
                        "entry in seconds.",
                        "Set to 0 for no timeout.",
                    ],

                    "min": 0,
                    "max": 60,
                },
                "MacPro3,1/Xserve2,1 Workaround": {
                    "type": "checkbox",
                    "value": self.constants.force_quad_thread,
                    "variable": "force_quad_thread",
                    "description": [
                        "Limits to 4 threads max on these units.",
                        "Required for macOS Sequoia and later.",
                    ],
                    "condition": (self.constants.custom_model and self.constants.custom_model in ["MacPro3,1", "Xserve2,1"]) or self.constants.computer.real_model in ["MacPro3,1", "Xserve2,1"]
                },
                "Debug": {
                    "type": "title",
                },

                "Verbose": {
                    "type": "checkbox",
                    "value": self.constants.verbose_debug,
                    "variable": "verbose_debug",
                    "description": [
                        "Verbose output during boot.",
                    ],

                },
                "Kext Debugging": {
                    "type": "checkbox",
                    "value": self.constants.kext_debug,
                    "variable": "kext_debug",
                    "description": [
                        "Use DEBUG variants of kexts and",
                        "enables additional kernel logging.",
                    ],
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "OpenCore Debugging": {
                    "type": "checkbox",
                    "value": self.constants.opencore_debug,
                    "variable": "opencore_debug",
                    "description": [
                        "Use DEBUG variant of OpenCore",
                        "and enables additional logging.",
                    ],
                },
            },
            "Extras": {
                "General (Continued)": {
                    "type": "title",
                },
                "Wake on WLAN": {
                    "type": "checkbox",
                    "value": self.constants.enable_wake_on_wlan,
                    "variable": "enable_wake_on_wlan",
                    "description": [
                        "Disabled by default due to",
                        "performance degradation",
                        "on some systems from wake.",
                        "Only applies to BCM943224, 331,",
                        "360 and 3602 chipsets.",
                    ],
                },
                "Disable Thunderbolt": {
                    "type": "checkbox",
                    "value": self.constants.disable_tb,
                    "variable": "disable_tb",
                    "description": [
                        "For MacBookPro11,x with faulty",
                        "PCHs that may crash sporadically.",
                    ],
                    "condition": (self.constants.custom_model and self.constants.custom_model in ["MacBookPro11,1", "MacBookPro11,2", "MacBookPro11,3"]) or self.constants.computer.real_model in ["MacBookPro11,1", "MacBookPro11,2", "MacBookPro11,3"]
                },
                "Windows GMUX": {
                    "type": "checkbox",
                    "value": self.constants.dGPU_switch,
                    "variable": "dGPU_switch",
                    "description": [
                        "Allow iGPU to be exposed in Windows",
                        "for dGPU-based MacBooks.",
                    ],
                },
                "Disable CPUFriend": {
                    "type": "checkbox",
                    "value": self.constants.disallow_cpufriend,
                    "variable": "disallow_cpufriend",
                    "description": [
                        "Disables power management helper",
                        "for unsupported models.",
                    ],
                },
                "Disable mediaanalysisd service": {
                    "type": "checkbox",
                    "value": self.constants.disable_mediaanalysisd,
                    "variable": "disable_mediaanalysisd",
                    "description": [
                        "For systems that are the primary iCloud",
                        "Photo Library host with a 3802-based GPU,",
                        "this may aid in prolonged idle stability.",
                    ],
                    "condition": gui_support.CheckProperties(self.constants).host_has_3802_gpu()
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Allow AppleALC Audio": {
                    "type": "checkbox",
                    "value": self.constants.set_alc_usage,
                    "variable": "set_alc_usage",
                    "description": [
                        "Allow AppleALC to manage audio",
                        "if applicable.",
                        "Only disable if your host lacks",
                        "a GOP ROM.",
                    ],
                },
                "NVRAM WriteFlash": {
                    "type": "checkbox",
                    "value": self.constants.nvram_write,
                    "variable": "nvram_write",
                    "description": [
                        "Allow OpenCore to write to NVRAM.",
                        "Disable on systems with faulty or",
                        "degraded NVRAM.",
                    ],
                },

                "3rd Party NVMe PM": {
                    "type": "checkbox",
                    "value": self.constants.allow_nvme_fixing,
                    "variable": "allow_nvme_fixing",
                    "description": [
                        "Enable non-stock NVMe power",
                        "management in macOS.",
                    ],
                },
                "3rd Party SATA PM": {
                    "type": "checkbox",
                    "value": self.constants.allow_3rd_party_drives,
                    "variable": "allow_3rd_party_drives",
                    "description": [
                        "Enable non-stock SATA power",
                        "management in macOS.",
                    ],
                    "condition": not bool(self.constants.computer.third_party_sata_ssd is False and not self.constants.custom_model)
                },
                "APFS Trim": {
                    "type": "checkbox",
                    "value": self.constants.apfs_trim_timeout,
                    "variable": "apfs_trim_timeout",
                    "description": [
                        "Recommended for all users, however faulty",
                        "SSDs may benefit from disabling this.",
                    ],
                },
            },
            "Advanced": {
                "Miscellaneous": {
                    "type": "title",
                },
                "Disable Firmware Throttling": {
                    "type": "checkbox",
                    "value": self.constants.disable_fw_throttle,
                    "variable": "disable_fw_throttle",
                    "description": [
                        "Disables firmware-based throttling",
                        "caused by missing hardware.",
                        "Ex. Missing Display, Battery, etc.",
                    ],
                },
                "Software DeMUX": {
                    "type": "checkbox",
                    "value": self.constants.software_demux,
                    "variable": "software_demux",
                    "description": [
                        "Enable software based DeMUX",
                        "for MacBookPro8,2 and MacBookPro8,3.",
                        "Prevents faulty dGPU from turning on.",
                        "Note: Requires associated NVRAM arg:",
                        "'gpu-power-prefs'.",
                    ],
                    "warning": "This settings requires 'gpu-power-prefs' NVRAM argument to be set to '1'.\n\nIf missing and this option is toggled, the system will not boot\n\nFull command:\nnvram FA4CE28D-B62F-4C99-9CC3-6815686E30F9:gpu-power-prefs=%01%00%00%00",
                    "condition": not bool((not self.constants.custom_model and self.constants.computer.real_model not in ["MacBookPro8,2", "MacBookPro8,3"]) or (self.constants.custom_model and self.constants.custom_model not in ["MacBookPro8,2", "MacBookPro8,3"]))
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "FeatureUnlock": {
                    "type": "choice",
                    "choices": [
                        "Enabled",
                        "Partial",
                        "Disabled",
                    ],
                    "value": "Enabled",
                    "variable": "",
                    "description": [
                        "Configure FeatureUnlock level.",
                        "Recommend lowering if your system",
                        "experiences memory instability.",
                    ],
                },
                "Populate FeatureUnlock Override": {
                    "type": "populate",
                    "function": self._populate_fu_override,
                    "args": wx.Frame,
                },
                "Hibernation Work-around": {
                    "type": "checkbox",
                    "value": self.constants.disable_connectdrivers,
                    "variable": "disable_connectdrivers",
                    "description": [
                        "Only load minimum EFI drivers",
                        "to prevent hibernation issues.",
                        "Note: This may break booting from",
                        "external drives.",
                    ],
                },
                "Graphics": {
                    "type": "title",
                },
                "AMD GOP Injection": {
                    "type": "checkbox",
                    "value": self.constants.amd_gop_injection,
                    "variable": "amd_gop_injection",
                    "description": [
                        "Inject AMD GOP for boot screen",
                        "support on PC GPUs.",
                    ],
                    "condition": not bool((not self.constants.custom_model and self.constants.computer.real_model not in socketed_gpu_models) or (self.constants.custom_model and self.constants.custom_model not in socketed_gpu_models))
                },
                "Nvidia GOP Injection": {
                    "type": "checkbox",
                    "value": self.constants.nvidia_kepler_gop_injection,
                    "variable": "nvidia_kepler_gop_injection",
                    "description": [
                        "Inject Nvidia Kepler GOP for boot",
                        "screen support on PC GPUs.",
                    ],
                    "condition": not bool((not self.constants.custom_model and self.constants.computer.real_model not in socketed_gpu_models) or (self.constants.custom_model and self.constants.custom_model not in socketed_gpu_models))
                },
                "wrap_around 2": {
                    "type": "wrap_around",
                },
                "Graphics Override": {
                    "type": "choice",
                    "choices": [
                        "None",
                        "Nvidia Kepler",
                        "AMD GCN",
                        "AMD Polaris",
                        "AMD Lexa",
                        "AMD Navi",
                    ],
                    "value": "None",
                    "variable": "",
                    "description": [
                        "Override detected/assumed GPU on",
                        "socketed MXM-based iMacs.",
                    ],
                    "condition": bool((not self.constants.custom_model and self.constants.computer.real_model in socketed_imac_models) or (self.constants.custom_model and self.constants.custom_model in socketed_imac_models))
                },
                "Populate Graphics Override": {
                    "type": "populate",
                    "function": self._populate_graphics_override,
                    "args": wx.Frame,
                },

            },
            "Security": {
                "Kernel Security": {
                    "type": "title",
                },
                "Disable Library Validation": {
                    "type": "checkbox",
                    "value": self.constants.disable_cs_lv,
                    "variable": "disable_cs_lv",
                    "description": [
                        "Required for loading modified",
                        "system files from root patching.",
                    ],
                },
                "Disable AMFI": {
                    "type": "checkbox",
                    "value": self.constants.disable_amfi,
                    "variable": "disable_amfi",
                    "description": [
                        "Extended version of 'Disable",
                        "Library Validation', required",
                        "for systems with deeper",
                        "root patches.",
                    ],
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Secure Boot Model": {
                    "type": "checkbox",
                    "value": self.constants.secure_status,
                    "variable": "secure_status",
                    "description": [
                        "Set Apple Secure Boot Model Identifier",
                        "to matching T2 model if spoofing.",
                        "Note: Incompatible with Root Patching.",
                    ],
                },
                "System Integrity Protection": {
                    "type": "title",
                },
                "Populate SIP": {
                    "type": "populate",
                    "function": self._populate_sip_settings,
                    "args": wx.Frame,
                },
            },
            "SMBIOS": {
                "Model Spoofing": {
                    "type": "title",
                },
                "SMBIOS Spoof Level": {
                    "type": "choice",
                    "choices": [
                        "None",
                        "Minimal",
                        "Moderate",
                        "Advanced",
                    ],
                    "value": self.constants.serial_settings,
                    "variable": "serial_settings",
                    "description": [
                        "Supported Levels:",
                        "   - None: No spoofing.",
                        "   - Minimal: Overrides Board ID.",
                        "   - Moderate: Overrides Model.",
                        "   - Advanced: Overrides Model and serial.",
                    ],
                },

                "SMBIOS Spoof Model": {
                    "type": "choice",
                    "choices": models + ["Default"],
                    "value": self.constants.override_smbios,
                    "variable": "override_smbios",
                    "description": [
                        "Set Mac Model to spoof to.",
                    ],

                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Allow spoofing native Macs": {
                    "type": "checkbox",
                    "value": self.constants.allow_native_spoofs,
                    "variable": "allow_native_spoofs",
                    "description": [
                        "Allow OpenCore to spoof natively",
                        "supported Macs.",
                        "Primarily used for enabling",
                        "Universal Control on unsupported Macs",
                    ],
                },
                "Serial Spoofing": {
                    "type": "title",
                },
                "Populate Serial Spoofing": {
                    "type": "populate",
                    "function": self._populate_serial_spoofing_settings,
                    "args": wx.Frame,
                },
            },
            "Root Patching": {
                "Root Volume Patching": {
                    "type": "title",
                },
                "TeraScale 2 Acceleration": {
                    "type": "checkbox",
                    "value": global_settings.GlobalEnviromentSettings().read_property("MacBookPro_TeraScale_2_Accel") or self.constants.allow_ts2_accel,
                    "variable": "MacBookPro_TeraScale_2_Accel",
                    "constants_variable": "allow_ts2_accel",
                    "description": [
                        "Enable AMD TeraScale 2 GPU",
                        "Acceleration on MacBookPro8,2 and",
                        "MacBookPro8,3.",
                        "By default this is disabled due to",
                        "common GPU failures on these models.",
                    ],
                    "override_function": self._update_global_settings,
                    "condition": not bool(self.constants.computer.real_model not in ["MacBookPro8,2", "MacBookPro8,3"])
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Non-Metal Configuration": {
                    "type": "title",
                },
                "Log out required to apply changes to SkyLight": {
                    "type": "sub_title",
                },
                "Dark Menu Bar": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Moraea_DarkMenuBar"),
                    "variable": "Moraea_DarkMenuBar",
                    "description": [
                        "If Beta Menu Bar is enabled,",
                        "menu bar colour will dynamically",
                        "change as needed.",
                    ],
                    "override_function": self._update_system_defaults,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)
                },
                "Beta Blur": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Moraea_BlurBeta"),
                    "variable": "Moraea_BlurBeta",
                    "description": [
                        "Control window blur behaviour.",
                    ],
                    "override_function": self._update_system_defaults,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)

                },
                "Beach Ball Cursor Workaround": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Moraea.EnableSpinHack"),
                    "variable": "Moraea.EnableSpinHack",
                    "description": [
                        "Control beach ball cursor behaviour.",
                    ],
                    "override_function": self._update_system_defaults_root,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)
                },
                "wrap_around 2": {
                    "type": "wrap_around",
                },
                "Beta Menu Bar": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Amy.MenuBar2Beta"),
                    "variable": "Amy.MenuBar2Beta",
                    "description": [
                        "Supports dynamic colour changes.",
                        "Note: Setting is still experimental.",
                        "If you experience issues, please",
                        "disable this setting.",
                    ],
                    "override_function": self._update_system_defaults,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)
                },
                "Disable Beta Rim": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Moraea_RimBetaDisabled"),
                    "variable": "Moraea_RimBetaDisabled",
                    "description": [
                        "Control Window Rim rendering.",
                    ],
                    "override_function": self._update_system_defaults,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)
                },
                "Disable Color Widgets Enforcement": {
                    "type": "checkbox",
                    "value": self._get_system_settings("Moraea_ColorWidgetDisabled"),
                    "variable": "Moraea_ColorWidgetDisabled",
                    "description": [
                        "Control Color Desktop Widgets Enforcement.",
                    ],
                    "override_function": self._update_system_defaults,
                    "condition": gui_support.CheckProperties(self.constants).host_is_non_metal(general_check=True)
                },
            },
            "App": {
                "General": {
                    "type": "title",
                },
                "Allow native models": {
                    "type": "checkbox",
                    "value": self.constants.allow_oc_everywhere,
                    "variable": "allow_oc_everywhere",
                    "description": [
                        "Allow OpenCore to be installed",
                        "on natively supported Macs.",
                        "Note this will not allow unsupported",
                        "macOS versions to be installed on",
                        "your system.",
                    ],
                    "warning": "This option should only be used if your Mac natively supports the OSes you wish to run.\n\nIf you are currently running an unsupported OS, this option will break booting. Only toggle for enabling OS features on a native Mac.\n\nAre you certain you want to continue?",
                },
                "Ignore App Updates": {
                    "type": "checkbox",
                    "value": global_settings.GlobalEnviromentSettings().read_property("IgnoreAppUpdates") or self.constants.ignore_updates,
                    "variable": "IgnoreAppUpdates",
                    "constants_variable": "ignore_updates",
                    "description": [
                        # "Ignore app updates",
                    ],
                    "override_function": self._update_global_settings,
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Disable Reporting": {
                    "type": "checkbox",
                    "value": global_settings.GlobalEnviromentSettings().read_property("DisableCrashAndAnalyticsReporting"),
                    "variable": "DisableCrashAndAnalyticsReporting",
                    "description": [
                        "When enabled, patcher will not",
                        "report any info to Dortania.",
                    ],
                    "override_function": self._update_global_settings,
                },
                "Remove Unused KDKs": {
                    "type": "checkbox",
                    "value": global_settings.GlobalEnviromentSettings().read_property("ShouldNukeKDKs") or self.constants.should_nuke_kdks,
                    "variable": "ShouldNukeKDKs",
                    "constants_variable": "should_nuke_kdks",
                    "description": [
                        "When enabled, the app will remove",
                        "unused Kernel Debug Kits from the system",
                        "during root patching.",
                    ],
                    "override_function": self._update_global_settings,
                },
                "Statistics": {
                    "type": "title",
                },
                "Populate Stats": {
                    "type": "populate",
                    "function": self._populate_app_stats,
                    "args": wx.Frame,
                },
            },
            "Developer": {
                "Validation": {
                    "type": "title",
                },
                "Install latest nightly build ð§ª": {
                    "type": "button",
                    "function": self.on_nightly,
                    "description": [
                        "If you're already here, I assume you're ok",
                        "bricking your system ð§±.",
                        "Check CHANGELOG before blindly updating.",
                    ],
                },
                "Trigger Exception": {
                    "type": "button",
                    "function": self.on_test_exception,
                    "description": [
                    ],
                },
                "wrap_around 1": {
                    "type": "wrap_around",
                },
                "Export constants": {
                    "type": "button",
                    "function": self.on_export_constants,
                    "description": [
                        "Export constants.py values to a txt file.",
                    ],
                },

                "Developer Root Volume Patching": {
                    "type": "title",
                },
                "Mount Root Volume": {
                    "type": "button",
                    "function": self.on_mount_root_vol,
                    "description": [
                        "Life's too short to type 'sudo mount -o",
                        "nobrowse -t apfs /dev/diskXsY",
                        "/System/Volumes/Update/mnt1' every time.",
                    ],
                },
                "wrap_around 2": {
                    "type": "wrap_around",
                },
                "Save Root Volume": {
                    "type": "button",
                    "function": self.on_bless_root_vol,
                    "description": [
                        "Rebuild kernel cache and bless snapshot ð",
                    ],
                },
            },
        }

        return settings


    def on_model_choice(self, event: wx.Event, model_choice: wx.Choice) -> None:
        """
        Sets model to use for patching.
        """

        selection = model_choice.GetStringSelection()
        if selection == "Host Model":
            selection = self.constants.computer.real_model
            self.constants.custom_model = None
            logging.info(f"Using Real Model: {self.constants.computer.real_model}")
            defaults.GenerateDefaults(self.constants.computer.real_model, True, self.constants)
        else:
            logging.info(f"Using Custom Model: {selection}")
            self.constants.custom_model = selection
            defaults.GenerateDefaults(self.constants.custom_model, False, self.constants)
            self.parent.build_button.Enable()



        self.parent.model_label.SetLabel(f"Model: {selection}")
        self.parent.model_label.Centre(wx.HORIZONTAL)

        self.frame_modal.Destroy()
        SettingsFrame(
            parent=self.parent,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.parent.GetPosition()
        )


    def _populate_sip_settings(self, panel: wx.Frame) -> None:

        horizontal_spacer = 250

        # Look for title on frame
        sip_title: wx.StaticText = None
        for child in panel.GetChildren():
            if child.GetLabel() == "System Integrity Protection":
                sip_title = child
                break


        # Label: Flip individual bits corresponding to XNU's csr.h
        # If you're unfamiliar with how SIP works, do not touch this menu
        sip_label = wx.StaticText(panel, label="Flip individual bits corresponding to", pos=(sip_title.GetPosition()[0] - 20, sip_title.GetPosition()[1] + 30))
        sip_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))

        # Hyperlink: csr.h
        spacer = 1 if self.constants.detected_os >= os_data.os_data.big_sur else 3
        sip_csr_h = wx.adv.HyperlinkCtrl(panel, id=wx.ID_ANY, label="XNU's csr.h", url="https://github.com/apple-oss-distributions/xnu/blob/xnu-8020.101.4/bsd/sys/csr.h", pos=(sip_label.GetPosition()[0] + sip_label.GetSize()[0] + 4, sip_label.GetPosition()[1] + spacer))
        sip_csr_h.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        sip_csr_h.SetHoverColour(self.hyperlink_colour)
        sip_csr_h.SetNormalColour(self.hyperlink_colour)
        sip_csr_h.SetVisitedColour(self.hyperlink_colour)

        # Label: SIP Status
        if self.constants.custom_sip_value is not None:
            self.sip_value = int(self.constants.custom_sip_value, 16)
        elif self.constants.sip_status is True:
            self.sip_value = 0x00
        else:
            self.sip_value = 0x803
        sip_configured_label = wx.StaticText(panel, label=f"Currently configured SIP: {hex(self.sip_value)}", pos=(sip_label.GetPosition()[0] + 35, sip_label.GetPosition()[1] + 20))
        sip_configured_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
        self.sip_configured_label = sip_configured_label

        # Label: SIP Status
        sip_booted_label = wx.StaticText(panel, label=f"Currently booted SIP: {hex(py_sip_xnu.SipXnu().get_sip_status().value)}", pos=(sip_configured_label.GetPosition()[0], sip_configured_label.GetPosition()[1] + 20))
        sip_booted_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))


        # SIP toggles
        entries_per_row = len(sip_data.system_integrity_protection.csr_values) // 2
        horizontal_spacer = 15
        vertical_spacer = 25
        index = 1
        for sip_bit in sip_data.system_integrity_protection.csr_values_extended:
            self.sip_checkbox = wx.CheckBox(panel, label=sip_data.system_integrity_protection.csr_values_extended[sip_bit]["name"].split("CSR_")[1], pos = (vertical_spacer, sip_booted_label.GetPosition()[1] + 20 + horizontal_spacer))
            self.sip_checkbox.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            self.sip_checkbox.SetToolTip(f'Description: {sip_data.system_integrity_protection.csr_values_extended[sip_bit]["description"]}\nValue: {hex(sip_data.system_integrity_protection.csr_values_extended[sip_bit]["value"])}\nIntroduced in: macOS {sip_data.system_integrity_protection.csr_values_extended[sip_bit]["introduced_friendly"]}')

            if self.sip_value & sip_data.system_integrity_protection.csr_values_extended[sip_bit]["value"] == sip_data.system_integrity_protection.csr_values_extended[sip_bit]["value"]:
                self.sip_checkbox.SetValue(True)

            horizontal_spacer += 20
            if index == entries_per_row:
                horizontal_spacer = 15
                vertical_spacer += 250

            index += 1
            self.sip_checkbox.Bind(wx.EVT_CHECKBOX, self.on_sip_value)


    def _populate_serial_spoofing_settings(self, panel: wx.Frame) -> None:
        title: wx.StaticText = None
        for child in panel.GetChildren():
            if child.GetLabel() == "Serial Spoofing":
                title = child
                break

        # Label: Custom Serial Number
        custom_serial_number_label = wx.StaticText(panel, label="Custom Serial Number", pos=(title.GetPosition()[0] - 150, title.GetPosition()[1] + 30))
        custom_serial_number_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))

        # Textbox: Custom Serial Number
        custom_serial_number_textbox = wx.TextCtrl(panel, pos=(custom_serial_number_label.GetPosition()[0] - 27, custom_serial_number_label.GetPosition()[1] + 20), size=(200, 25))
        custom_serial_number_textbox.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        custom_serial_number_textbox.SetToolTip("Enter a custom serial number here. This will be used for the SMBIOS and iMessage.\n\nNote: This will not be used if the \"Use Custom Serial Number\" checkbox is not checked.")
        custom_serial_number_textbox.Bind(wx.EVT_TEXT, self.on_custom_serial_number_textbox)
        custom_serial_number_textbox.SetValue(self.constants.custom_serial_number)
        self.custom_serial_number_textbox = custom_serial_number_textbox

        # Label: Custom Board Serial Number
        custom_board_serial_number_label = wx.StaticText(panel, label="Custom Board Serial Number", pos=(title.GetPosition()[0] + 120, custom_serial_number_label.GetPosition()[1]))
        custom_board_serial_number_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))

        # Textbox: Custom Board Serial Number
        custom_board_serial_number_textbox = wx.TextCtrl(panel, pos=(custom_board_serial_number_label.GetPosition()[0] - 5, custom_serial_number_textbox.GetPosition()[1]), size=(200, 25))
        custom_board_serial_number_textbox.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        custom_board_serial_number_textbox.SetToolTip("Enter a custom board serial number here. This will be used for the SMBIOS and iMessage.\n\nNote: This will not be used if the \"Use Custom Board Serial Number\" checkbox is not checked.")
        custom_board_serial_number_textbox.Bind(wx.EVT_TEXT, self.on_custom_board_serial_number_textbox)
        custom_board_serial_number_textbox.SetValue(self.constants.custom_board_serial_number)
        self.custom_board_serial_number_textbox = custom_board_serial_number_textbox

        # Button: Generate Serial Number (below)
        generate_serial_number_button = wx.Button(panel, label=f"Generate S/N: {self.constants.custom_model or self.constants.computer.real_model}", pos=(title.GetPosition()[0] - 30, custom_board_serial_number_label.GetPosition()[1] + 60), size=(200, 25))
        generate_serial_number_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        generate_serial_number_button.Bind(wx.EVT_BUTTON, self.on_generate_serial_number)


    def _populate_app_stats(self, panel: wx.Frame) -> None:
        title: wx.StaticText = None
        for child in panel.GetChildren():
            if child.GetLabel() == "Statistics":
                title = child
                break

        lines = f"""Application Information:
    Application Version: {self.constants.patcher_version}
    PatcherSupportPkg Version: {self.constants.patcher_support_pkg_version}
    Application Path: {self.constants.launcher_binary}
    Application Mount: {self.constants.payload_path}

Commit Information:
    Branch: {self.constants.commit_info[0]}
    Date: {self.constants.commit_info[1]}
    URL: {self.constants.commit_info[2] if self.constants.commit_info[2] != "" else "N/A"}

Booted Information:
    Booted OS: XNU {self.constants.detected_os} ({self.constants.detected_os_version})
    Booted Patcher Version: {self.constants.computer.oclp_version}
    Booted OpenCore Version: {self.constants.computer.opencore_version}
    Booted OpenCore Disk: {self.constants.booted_oc_disk}

Hardware Information:
    {pprint.pformat(self.constants.computer, indent=4)}
"""
        # TextCtrl: properties
        self.app_stats = wx.TextCtrl(panel, value=lines, pos=(-1, title.GetPosition()[1] + 30), size=(600, 240), style=wx.TE_READONLY | wx.TE_MULTILINE | wx.TE_RICH2)
        self.app_stats.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))


    def on_checkbox(self, event: wx.Event, warning_pop: str = "", override_function: bool = False) -> None:
        """
        """
        label = event.GetEventObject().GetLabel()
        value = event.GetEventObject().GetValue()
        if warning_pop != "" and value is True:
            warning = wx.MessageDialog(self.frame_modal, warning_pop, f"Warning: {label}", wx.YES_NO | wx.ICON_WARNING | wx.NO_DEFAULT)
            if warning.ShowModal() == wx.ID_NO:
                event.GetEventObject().SetValue(not event.GetEventObject().GetValue())
                return
            if label == "Allow native models":
                if self.constants.computer.real_model in smbios_data.smbios_dictionary:
                    if self.constants.detected_os > smbios_data.smbios_dictionary[self.constants.computer.real_model]["Max OS Supported"]:
                        chassis_type = "aluminum"
                        if self.constants.computer.real_model in ["MacBook5,2", "MacBook6,1", "MacBook7,1"]:
                            chassis_type = "plastic"
                        dlg = wx.MessageDialog(self.frame_modal, f"This model, {self.constants.computer.real_model}, does not natively support macOS {os_data.os_conversion.kernel_to_os(self.constants.detected_os)}, {os_data.os_conversion.convert_kernel_to_marketing_name(self.constants.detected_os)}. The last native OS was macOS {os_data.os_conversion.kernel_to_os(smbios_data.smbios_dictionary[self.constants.computer.real_model]['Max OS Supported'])}, {os_data.os_conversion.convert_kernel_to_marketing_name(smbios_data.smbios_dictionary[self.constants.computer.real_model]['Max OS Supported'])}\n\nToggling this option will break booting on this OS. Are you absolutely certain this is desired?\n\nYou may end up with a nice {chassis_type} brick ð§±", "Are you certain?", wx.YES_NO | wx.ICON_WARNING | wx.NO_DEFAULT)
                        if dlg.ShowModal() == wx.ID_NO:
                            event.GetEventObject().SetValue(not event.GetEventObject().GetValue())
                            return
        if override_function is True:
            self.settings[self._find_parent_for_key(label)][label]["override_function"](self.settings[self._find_parent_for_key(label)][label]["variable"], value, self.settings[self._find_parent_for_key(label)][label]["constants_variable"] if "constants_variable" in self.settings[self._find_parent_for_key(label)][label] else None)
            return

        self._update_setting(self.settings[self._find_parent_for_key(label)][label]["variable"], value)
        if label == "Allow native models":
            if gui_support.CheckProperties(self.constants).host_can_build() is True:
                self.parent.build_button.Enable()
            else:
                self.parent.build_button.Disable()


    def on_spinctrl(self, event: wx.Event, label: str) -> None:
        """
        """
        value = event.GetEventObject().GetValue()
        self._update_setting(self.settings[self._find_parent_for_key(label)][label]["variable"], value)


    def _update_setting(self, variable, value):
        logging.info(f"Updating Local Setting: {variable} = {value}")
        setattr(self.constants, variable, value)
        tmp_value = value
        if tmp_value is None:
            tmp_value = "PYTHON_NONE_VALUE"
        global_settings.GlobalEnviromentSettings().write_property(f"GUI:{variable}", tmp_value)


    def _update_global_settings(self, variable, value, global_setting = None):
        logging.info(f"Updating Global Setting: {variable} = {value}")
        tmp_value = value
        if tmp_value is None:
            tmp_value = "PYTHON_NONE_VALUE"
        global_settings.GlobalEnviromentSettings().write_property(variable, tmp_value)
        if global_setting is not None:
            self._update_setting(global_setting, value)


    def _update_system_defaults(self, variable, value, global_setting = None):
        value_type = type(value)
        if value_type is str:
            value_type = "-string"
        elif value_type is int:
            value_type = "-int"
        elif value_type is bool:
            value_type = "-bool"

        logging.info(f"Updating System Defaults: {variable} = {value} ({value_type})")
        subprocess.run(["/usr/bin/defaults", "write", "-globalDomain", variable, value_type, str(value)])


    def _update_system_defaults_root(self, variable, value, global_setting = None):
        value_type = type(value)
        if value_type is str:
            value_type = "-string"
        elif value_type is int:
            value_type = "-int"
        elif value_type is bool:
            value_type = "-bool"

        logging.info(f"Updating System Defaults (root): {variable} = {value} ({value_type})")
        subprocess_wrapper.run_as_root(["/usr/bin/defaults", "write", "/Library/Preferences/.GlobalPreferences.plist", variable, value_type, str(value)])


    def _find_parent_for_key(self, key: str) -> str:
        for parent in self.settings:
            if key in self.settings[parent]:
                return parent


    def on_sip_value(self, event: wx.Event) -> None:
        """
        """
        dict = sip_data.system_integrity_protection.csr_values_extended[f"CSR_{event.GetEventObject().GetLabel()}"]

        if event.GetEventObject().GetValue() is True:
            self.sip_value = self.sip_value + dict["value"]
        else:
            self.sip_value = self.sip_value - dict["value"]

        if hex(self.sip_value) == "0x0":
            self.constants.custom_sip_value = None
            self.constants.sip_status = True
            global_settings.GlobalEnviromentSettings().write_property("GUI:custom_sip_value", "PYTHON_NONE_VALUE")
            global_settings.GlobalEnviromentSettings().write_property("GUI:sip_status", True)
        elif hex(self.sip_value) == "0x803":
            self.constants.custom_sip_value = None
            self.constants.sip_status = False
            global_settings.GlobalEnviromentSettings().write_property("GUI:custom_sip_value", "PYTHON_NONE_VALUE")
            global_settings.GlobalEnviromentSettings().write_property("GUI:sip_status", False)
        else:
            self.constants.custom_sip_value = hex(self.sip_value)
            global_settings.GlobalEnviromentSettings().write_property("GUI:custom_sip_value", hex(self.sip_value))

        self.sip_configured_label.SetLabel(f"Currently configured SIP: {hex(self.sip_value)}")

    def on_choice(self, event: wx.Event, label: str) -> None:
        """
        """
        value = event.GetString()
        self._update_setting(self.settings[self._find_parent_for_key(label)][label]["variable"], value)


    def on_generate_serial_number(self, event: wx.Event) -> None:
        dlg = wx.MessageDialog(self.frame_modal, "Please take caution when using serial spoofing. This should only be used on machines that were legally obtained and require reserialization.\n\nNote: new serials are only overlayed through OpenCore and are not permanently installed into ROM.\n\nMisuse of this setting can break power management and other aspects of the OS if the system does not need spoofing\n\nDortania does not condone the use of our software on stolen devices.\n\nAre you certain you want to continue?", "Warning", wx.YES_NO | wx.ICON_WARNING | wx.NO_DEFAULT)
        if dlg.ShowModal() != wx.ID_YES:
            return

        macserial_output = subprocess.run([self.constants.macserial_path, "--generate", "--model", self.constants.custom_model or self.constants.computer.real_model, "--num", "1"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        macserial_output = macserial_output.stdout.decode().strip().split(" | ")
        if len(macserial_output) == 2:
            self.custom_serial_number_textbox.SetValue(macserial_output[0])
            self.custom_board_serial_number_textbox.SetValue(macserial_output[1])
        else:
            wx.MessageBox(f"Failed to generate serial number:\n\n{macserial_output}", "Error", wx.OK | wx.ICON_ERROR)


    def on_custom_serial_number_textbox(self, event: wx.Event) -> None:
        self.constants.custom_serial_number = event.GetEventObject().GetValue()
        global_settings.GlobalEnviromentSettings().write_property("GUI:custom_serial_number", self.constants.custom_serial_number)


    def on_custom_board_serial_number_textbox(self, event: wx.Event) -> None:
        self.constants.custom_board_serial_number = event.GetEventObject().GetValue()
        global_settings.GlobalEnviromentSettings().write_property("GUI:custom_board_serial_number", self.constants.custom_board_serial_number)


    def _populate_fu_override(self, panel: wx.Panel) -> None:
        gpu_combo_box: wx.Choice = None
        for child in panel.GetChildren():
            if isinstance(child, wx.Choice):
                gpu_combo_box = child
                break

        gpu_combo_box.Bind(wx.EVT_CHOICE, self.fu_selection_click)
        if self.constants.fu_status is False:
            gpu_combo_box.SetStringSelection("Disabled")
        elif self.constants.fu_arguments is None or self.constants.fu_arguments == "":
            gpu_combo_box.SetStringSelection("Enabled")
        else:
            gpu_combo_box.SetStringSelection("Partial")


    def fu_selection_click(self, event: wx.Event) -> None:
        value = event.GetEventObject().GetStringSelection()
        if value == "Enabled":
            logging.info("Updating FU Status: Enabled")
            self.constants.fu_status = True
            self.constants.fu_arguments = None
            global_settings.GlobalEnviromentSettings().write_property("GUI:fu_status", True)
            global_settings.GlobalEnviromentSettings().write_property("GUI:fu_arguments", "PYTHON_NONE_VALUE")
            return

        if value == "Partial":
            logging.info("Updating FU Status: Partial")
            self.constants.fu_status = True
            self.constants.fu_arguments = " -disable_sidecar_mac"
            global_settings.GlobalEnviromentSettings().write_property("GUI:fu_status", True)
            global_settings.GlobalEnviromentSettings().write_property("GUI:fu_arguments", " -disable_sidecar_mac")
            return

        logging.info("Updating FU Status: Disabled")
        self.constants.fu_status = False
        self.constants.fu_arguments = None
        global_settings.GlobalEnviromentSettings().write_property("GUI:fu_status", False)
        global_settings.GlobalEnviromentSettings().write_property("GUI:fu_arguments", "PYTHON_NONE_VALUE")


    def _populate_graphics_override(self, panel: wx.Panel) -> None:
        gpu_combo_box: wx.Choice = None
        index = 0
        for child in panel.GetChildren():
            if isinstance(child, wx.Choice):
                if index == 0:
                    index = index + 1
                    continue
                gpu_combo_box = child
                break

        gpu_combo_box.Bind(wx.EVT_CHOICE, self.gpu_selection_click)
        gpu_combo_box.SetStringSelection(f"{self.constants.imac_vendor} {self.constants.imac_model}")

        socketed_gpu_models = ["iMac9,1", "iMac10,1", "iMac11,1", "iMac11,2", "iMac11,3", "iMac12,1", "iMac12,2"]
        if ((not self.constants.custom_model and self.constants.computer.real_model not in socketed_gpu_models) or (self.constants.custom_model and self.constants.custom_model not in socketed_gpu_models)):
            gpu_combo_box.Disable()
            return


    def gpu_selection_click(self, event: wx.Event) -> None:
        gpu_choice = event.GetEventObject().GetStringSelection()

        logging.info(f"Updating GPU Selection: {gpu_choice}")
        if "AMD" in gpu_choice:
            self.constants.imac_vendor = "AMD"
            self.constants.metal_build = True
            if "Polaris" in gpu_choice:
                self.constants.imac_model = "Polaris"
            elif "GCN" in gpu_choice:
                self.constants.imac_model = "GCN"
            elif "Lexa" in gpu_choice:
                self.constants.imac_model = "Lexa"
            elif "Navi" in gpu_choice:
                self.constants.imac_model = "Navi"
            else:
                raise Exception("Unknown GPU Model")
            global_settings.GlobalEnviromentSettings().write_property("GUI:imac_vendor", "AMD")
            global_settings.GlobalEnviromentSettings().write_property("GUI:metal_build", True)
            global_settings.GlobalEnviromentSettings().write_property("GUI:imac_model", self.constants.imac_model)
        elif "Nvidia" in gpu_choice:
            self.constants.imac_vendor = "Nvidia"
            self.constants.metal_build = True
            if "Kepler" in gpu_choice:
                self.constants.imac_model = "Kepler"
            elif "GT" in gpu_choice:
                self.constants.imac_model = "GT"
            else:
                raise Exception("Unknown GPU Model")
            global_settings.GlobalEnviromentSettings().write_property("GUI:imac_vendor", "Nvidia")
            global_settings.GlobalEnviromentSettings().write_property("GUI:metal_build", True)
            global_settings.GlobalEnviromentSettings().write_property("GUI:imac_model", self.constants.imac_model)
        else:
            self.constants.imac_vendor = "None"
            self.constants.metal_build = False
            global_settings.GlobalEnviromentSettings().write_property("GUI:imac_vendor", "None")
            global_settings.GlobalEnviromentSettings().write_property("GUI:metal_build", False)


    def _get_system_settings(self, variable) -> bool:
        result = subprocess.run(["/usr/bin/defaults", "read", "-globalDomain", variable], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        if result.returncode == 0:
            try:
                return bool(int(result.stdout.decode().strip()))
            except:
                return False
        return False


    def on_return(self, event):
        self.frame_modal.Destroy()


    def on_nightly(self, event: wx.Event) -> None:
        # Ask prompt for which branch
        branches = ["main"]
        if self.constants.commit_info[0] not in ["Running from source", "Built from source"]:
            branches = [self.constants.commit_info[0].split("/")[-1]]
        result = network_handler.NetworkUtilities().get("https://api.github.com/repos/dortania/OpenCore-Legacy-Patcher/branches")
        if result is not None:
            result = result.json()
            for branch in result:
                if branch["name"] == "gh-pages":
                    continue
                if branch["name"] not in branches:
                    branches.append(branch["name"])

            with wx.SingleChoiceDialog(self.parent, "Which branch would you like to download?", "Branch Selection", branches) as dialog:
                if dialog.ShowModal() == wx.ID_CANCEL:
                    return

                branch = dialog.GetStringSelection()
        else:
            branch = "main"

        gui_update.UpdateFrame(
            parent=self.parent,
            title=self.title,
            global_constants=self.constants,
            screen_location=self.parent.GetPosition(),
            url=f"https://nightly.link/dortania/OpenCore-Legacy-Patcher/workflows/build-app-wxpython/{branch}/OpenCore-Patcher.pkg.zip",
            version_label="(Nightly)"
        )


    def on_export_constants(self, event: wx.Event) -> None:
        # Throw pop up to get save location
        with wx.FileDialog(self.parent, "Save Constants File", wildcard="JSON files (*.txt)|*.txt", style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT, defaultFile=f"constants-{self.constants.patcher_version}.txt") as fileDialog:
            if fileDialog.ShowModal() == wx.ID_CANCEL:
                return

            # Save the current contents in the file
            pathname = fileDialog.GetPath()
            logging.info(f"Saving constants to {pathname}")
            with open(pathname, 'w') as file:
                file.write(pprint.pformat(vars(self.constants), indent=4))


    def on_test_exception(self, event: wx.Event) -> None:
        raise Exception("Test Exception")

    def on_mount_root_vol(self, event: wx.Event) -> None:
        #Don't need to pass model as we're bypassing all logic
        if sys_patch.PatchSysVolume("",self.constants)._mount_root_vol() == True:
            wx.MessageDialog(self.parent, "Root Volume Mounted, remember to fix permissions before saving the Root Volume", "Success", wx.OK | wx.ICON_INFORMATION).ShowModal()
        else:
            wx.MessageDialog(self.parent, "Root Volume Mount Failed, check terminal output", "Error", wx.OK | wx.ICON_ERROR).ShowModal()

    def on_bless_root_vol(self, event: wx.Event) -> None:
        #Don't need to pass model as we're bypassing all logic
        if sys_patch.PatchSysVolume("",self.constants)._rebuild_root_volume() == True:
            wx.MessageDialog(self.parent, "Root Volume saved, please reboot to apply changes", "Success", wx.OK | wx.ICON_INFORMATION).ShowModal()
        else:
            wx.MessageDialog(self.parent, "Root Volume update Failed, check terminal output", "Error", wx.OK | wx.ICON_ERROR).ShowModal()

#gui_support.py
"""
gui_support.py: Utilities for interacting with wxPython GUI
"""

import wx
import sys
import time
import logging
import plistlib
import threading
import subprocess
import applescript
import packaging.version

from pathlib import Path

from . import gui_about

from .. import constants

from ..detections import device_probe

from ..datasets import (
    model_array,
    os_data,
    smbios_data
)


def get_font_face():
    if not get_font_face.font_face:
        get_font_face.font_face = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT).GetFaceName() or "Lucida Grande"

    return get_font_face.font_face


get_font_face.font_face = None


# Centralize the common options for font creation
def font_factory(size: int, weight):
    return wx.Font(size, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, weight, False, get_font_face())


class AutoUpdateStages:
    INACTIVE = 0
    CHECKING = 1
    BUILDING = 2
    INSTALLING = 3
    ROOT_PATCHING = 4
    FINISHED = 5


class GenerateMenubar:

    def __init__(self, frame: wx.Frame, global_constants: constants.Constants) -> None:
        self.frame: wx.Frame = frame
        self.constants: constants.Constants = global_constants


    def generate(self) -> wx.MenuBar:
        menubar = wx.MenuBar()
        fileMenu = wx.Menu()

        aboutItem = fileMenu.Append(wx.ID_ABOUT, "&About OpenCore Legacy Patcher")
        fileMenu.AppendSeparator()
        revealLogItem = fileMenu.Append(wx.ID_ANY, "&Reveal Log File")

        menubar.Append(fileMenu, "&File")
        self.frame.SetMenuBar(menubar)

        self.frame.Bind(wx.EVT_MENU, lambda event: gui_about.AboutFrame(self.constants), aboutItem)
        self.frame.Bind(wx.EVT_MENU, lambda event: subprocess.run(["/usr/bin/open", "--reveal", self.constants.log_filepath]), revealLogItem)


class GaugePulseCallback:
    """
    Uses an alternative Pulse() method for wx.Gauge() on macOS Monterey+ with non-Metal GPUs
    Dirty hack, however better to display some form of animation than none at all

    Note: This work-around is no longer needed on hosts using PatcherSupportPkg 1.1.2 or newer
    """

    def __init__(self, global_constants: constants.Constants, gauge: wx.Gauge) -> None:
        self.gauge: wx.Gauge = gauge

        self.pulse_thread: threading.Thread = None
        self.pulse_thread_active: bool = False

        self.gauge_value: int = 0
        self.pulse_forward: bool = True

        self.max_value: int = gauge.GetRange()

        self.non_metal_alternative: bool = CheckProperties(global_constants).host_is_non_metal()
        if self.non_metal_alternative is True:
            if CheckProperties(global_constants).host_psp_version() >= packaging.version.Version("1.1.2"):
                self.non_metal_alternative = False


    def start_pulse(self) -> None:
        if self.non_metal_alternative is False:
            self.gauge.Pulse()
            return
        self.pulse_thread_active = True
        self.pulse_thread = threading.Thread(target=self._pulse)
        self.pulse_thread.start()


    def stop_pulse(self) -> None:
        if self.non_metal_alternative is False:
            return
        self.pulse_thread_active = False
        self.pulse_thread.join()


    def _pulse(self) -> None:
        while self.pulse_thread_active:
            if self.gauge_value == 0:
                self.pulse_forward = True

            elif self.gauge_value == self.max_value:
                self.pulse_forward = False

            if self.pulse_forward:
                self.gauge_value += 1
            else:
                self.gauge_value -= 1

            wx.CallAfter(self.gauge.SetValue, self.gauge_value)
            time.sleep(0.005)


class CheckProperties:

    def __init__(self, global_constants: constants.Constants) -> None:
        self.constants: constants.Constants = global_constants


    def host_can_build(self):
        """
        Check if host supports building OpenCore configs
        """
        if self.constants.custom_model:
            return True
        if self.constants.host_is_hackintosh is True:
            return False
        if self.constants.allow_oc_everywhere is True:
            return True
        if self.constants.computer.real_model in model_array.SupportedSMBIOS:
            return True

        return False


    def host_is_non_metal(self, general_check: bool = False):
        """
        Check if host is non-metal
        Primarily for wx.Gauge().Pulse() workaround (where animation doesn't work on Monterey+)
        """

        if self.constants.detected_os < os_data.os_data.monterey and general_check is False:
            return False
        if self.constants.detected_os < os_data.os_data.big_sur and general_check is True:
            return False
        if not Path("/System/Library/PrivateFrameworks/SkyLight.framework/Versions/A/SkyLightOld.dylib").exists():
            # SkyLight stubs are only used on non-Metal
            return False

        return True


    def host_has_cpu_gen(self, gen: int) -> bool:
        """
        Check if host has a CPU generation equal to or greater than the specified generation
        """
        model = self.constants.custom_model if self.constants.custom_model else self.constants.computer.real_model
        if model in smbios_data.smbios_dictionary:
            if smbios_data.smbios_dictionary[model]["CPU Generation"] >= gen:
                return True
        return False


    def host_psp_version(self) -> packaging.version.Version:
        """
        Grab PatcherSupportPkg version from OpenCore-Legacy-Patcher.plist
        """
        oclp_plist_path = "/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist"
        if not Path(oclp_plist_path).exists():
            return packaging.version.Version("0.0.0")

        oclp_plist = plistlib.load(open(oclp_plist_path, "rb"))
        if "PatcherSupportPkg" not in oclp_plist:
            return packaging.version.Version("0.0.0")

        if oclp_plist["PatcherSupportPkg"].startswith("v"):
            oclp_plist["PatcherSupportPkg"] = oclp_plist["PatcherSupportPkg"][1:]

        return packaging.version.parse(oclp_plist["PatcherSupportPkg"])

    def host_has_3802_gpu(self) -> bool:
        """
        Check if either host, or override model, has a 3802 GPU
        """

        gpu_archs = []
        if self.constants.custom_model:
            model = self.constants.custom_model
        else:
            model = self.constants.computer.real_model
            gpu_archs = [gpu.arch for gpu in self.constants.computer.gpus]

        if not gpu_archs:
            gpu_archs = smbios_data.smbios_dictionary.get(model, {}).get("Stock GPUs", [])

        for arch in gpu_archs:
            if arch in [
                device_probe.Intel.Archs.Ivy_Bridge,
                device_probe.Intel.Archs.Haswell,
                device_probe.NVIDIA.Archs.Kepler,
            ]:
                return True

        return False

class PayloadMount:

    def __init__(self, global_constants: constants.Constants, frame: wx.Frame) -> None:
        self.constants: constants.Constants = global_constants
        self.frame: wx.Frame = frame


    def is_unpack_finished(self):
        if self.constants.unpack_thread.is_alive():
            return False

        if Path(self.constants.payload_kexts_path).exists():
            return True

        # Raise error to end program
        popup = wx.MessageDialog(
            self.frame,
            f"During unpacking of our internal files, we seemed to have encountered an error.\n\nIf you keep seeing this error, please try rebooting and redownloading the application.",
            "Internal Error occurred!",
            style=wx.OK | wx.ICON_EXCLAMATION
        )
        popup.ShowModal()
        self.frame.Freeze()
        sys.exit(1)


class ThreadHandler(logging.Handler):
    """
    Reroutes logging output to a wx.TextCtrl using UI callbacks
    """

    def __init__(self, text_box: wx.TextCtrl):
        logging.Handler.__init__(self)
        self.text_box = text_box


    def emit(self, record: logging.LogRecord):
        wx.CallAfter(self.text_box.AppendText, self.format(record) + '\n')


def wait_for_thread(thread: threading.Thread, sleep_interval=None):
    """
    Waits for a thread to finish while processing UI events at regular intervals
    to prevent UI freezing and excessive CPU usage.
    """
    # Use the passed sleep_interval, or get from global_constants
    interval = sleep_interval if sleep_interval is not None else constants.Constants().thread_sleep_interval

    while thread.is_alive():
        wx.Yield()
        thread.join(timeout=interval)


class RestartHost:
    """
    Restarts the host machine
    """

    def __init__(self, frame: wx.Frame) -> None:
        self.frame: wx.Frame = frame


    def restart(self, event: wx.Event = None, message: str = ""):
        self.popup = wx.MessageDialog(
            self.frame,
            message,
            "Reboot to apply?",
            wx.YES_NO | wx.YES_DEFAULT | wx.ICON_INFORMATION
        )
        self.popup.SetYesNoLabels("Reboot", "Ignore")
        answer = self.popup.ShowModal()
        if answer == wx.ID_YES:
            # Reboots with Count Down prompt (user can still dismiss if needed)
            self.frame.Hide()
            wx.Yield()
            try:
                applescript.AppleScript('tell app "loginwindow" to Â«event aevtrrstÂ»').run()
            except applescript.ScriptError as e:
                logging.error(f"Error while trying to reboot: {e}")
            sys.exit(0)

#gui_sys_patch_display.py
"""
gui_sys_patch_display.py: Display root patching menu
"""

import wx
import logging
import plistlib
import threading

from pathlib import Path

from .. import constants

from ..sys_patch.patchsets import HardwarePatchsetDetection, HardwarePatchsetValidation

from ..wx_gui import (
    gui_main_menu,
    gui_support,
    gui_sys_patch_start,
)


class SysPatchDisplayFrame(wx.Frame):
    """
    Create a modal frame for displaying root patches
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None):
        logging.info("Initializing Root Patch Display Frame")

        if parent:
            self.frame = parent
        else:
            super().__init__(parent, title=title, size=(360, 200), style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX)
            self.frame = self
            self.frame.Centre()

        self.title = title
        self.constants: constants.Constants = global_constants
        self.frame_modal: wx.Dialog = None
        self.return_button: wx.Button = None
        self.available_patches: bool = False
        self.init_with_parent = True if parent else False

        self.frame_modal = wx.Dialog(self.frame, title=title, size=(360, 200))

        self._generate_elements_display_patches(self.frame_modal)

        if self.constants.update_stage != gui_support.AutoUpdateStages.INACTIVE:
            if self.available_patches is False:
                gui_support.RestartHost(self.frame).restart(message="No root patch updates needed!\n\nWould you like to reboot to apply the new OpenCore build?")


    def _generate_elements_display_patches(self, frame: wx.Frame = None) -> None:
        """
        Generate UI elements for root patching frame

        Format:
            - Title label:        Post-Install Menu
            - Label:              Available patches:
            - Labels:             {patch name}
            - Button:             Start Root Patching
            - Button:             Revert Root Patches
            - Button:             Return to Main Menu
        """
        frame = self if not frame else frame

        title_label = wx.StaticText(frame, label="Post-Install Menu", pos=(-1, 10))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Label: Fetching patches...
        available_label = wx.StaticText(frame, label="Fetching patches for host", pos=(-1, title_label.GetPosition()[1] + title_label.GetSize()[1] + 10))
        available_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
        available_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(frame, range=100, pos=(-1, available_label.GetPosition()[1] + available_label.GetSize()[1] + 10), size=(250, 20))
        progress_bar.Centre(wx.HORIZONTAL)
        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set window height
        frame.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 40))

        # Labels: {patch name}
        patches: dict = {}
        def _fetch_patches(self) -> None:
            nonlocal patches
            patches = HardwarePatchsetDetection(constants=self.constants).device_properties

        thread = threading.Thread(target=_fetch_patches, args=(self,))
        thread.start()

        frame.ShowWindowModal()

        gui_support.wait_for_thread(thread)

        frame.Close()

        progress_bar.Hide()
        progress_bar_animation.stop_pulse()

        available_label.SetLabel("Available patches for your system:")
        available_label.Centre(wx.HORIZONTAL)


        can_unpatch: bool = not patches[HardwarePatchsetValidation.UNPATCHING_NOT_POSSIBLE]

        if not any(not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True for patch in patches):
            logging.info("No applicable patches available")
            patches = {}

        # Check if OCLP has already applied the same patches
        no_new_patches = not self._check_if_new_patches_needed(patches) if patches else False

        if not patches:
            # Prompt user with no patches found
            patch_label = wx.StaticText(frame, label="No patches required", pos=(-1, available_label.GetPosition()[1] + 20))
            patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            patch_label.Centre(wx.HORIZONTAL)

        else:
            # Add Label for each patch
            i = 0
            if no_new_patches is True:
                patch_label = wx.StaticText(frame, label="All applicable patches already installed", pos=(-1, available_label.GetPosition()[1] + 20))
                patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                patch_label.Centre(wx.HORIZONTAL)
                i = i + 20
            else:
                longest_patch = ""
                for patch in patches:
                    if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                        if len(patch) > len(longest_patch):
                            longest_patch = patch
                anchor = wx.StaticText(frame, label=longest_patch, pos=(-1, available_label.GetPosition()[1] + 20))
                anchor.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                anchor.Centre(wx.HORIZONTAL)
                anchor.Hide()

                logging.info("Available patches:")
                for patch in patches:
                    if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                        i = i + 20
                        logging.info(f"- {patch}")
                        patch_label = wx.StaticText(frame, label=f"- {patch}", pos=(anchor.GetPosition()[0], available_label.GetPosition()[1] + i))
                        patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))

                if i == 20:
                    patch_label.SetLabel(patch_label.GetLabel().replace("-", ""))
                    patch_label.Centre(wx.HORIZONTAL)

            if patches[HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE] is True:
                # Cannot patch due to the following reasons:
                patch_label = wx.StaticText(frame, label="Cannot patch due to the following reasons:", pos=(-1, patch_label.GetPosition()[1] + 25))
                patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                patch_label.Centre(wx.HORIZONTAL)

                longest_patch = ""
                for patch in patches:
                    if not patch.startswith("Validation"):
                        continue
                    if patches[patch] is False:
                        continue
                    if patch in [HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE, HardwarePatchsetValidation.UNPATCHING_NOT_POSSIBLE]:
                        continue

                    if len(patch) > len(longest_patch):
                        longest_patch = patch
                anchor = wx.StaticText(frame, label=longest_patch.split('Validation: ')[1], pos=(-1, patch_label.GetPosition()[1] + 20))
                anchor.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                anchor.Centre(wx.HORIZONTAL)
                anchor.Hide()

                i = 0
                for patch in patches:
                    if not patch.startswith("Validation"):
                        continue
                    if patches[patch] is False:
                        continue
                    if patch in [HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE, HardwarePatchsetValidation.UNPATCHING_NOT_POSSIBLE]:
                        continue

                    patch_label = wx.StaticText(frame, label=f"- {patch.split('Validation: ')[1]}", pos=(anchor.GetPosition()[0], anchor.GetPosition()[1] + i))
                    patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                    i = i + 20

                if i == 20:
                    patch_label.SetLabel(patch_label.GetLabel().replace("-", ""))
                    patch_label.Centre(wx.HORIZONTAL)

            else:
                if self.constants.computer.oclp_sys_version and self.constants.computer.oclp_sys_date:
                    date = self.constants.computer.oclp_sys_date.split(" @")
                    date = date[0] if len(date) == 2 else ""

                    patch_text = f"{self.constants.computer.oclp_sys_version}, {date}"

                    patch_label = wx.StaticText(frame, label="Root Volume last patched:", pos=(-1, patch_label.GetPosition().y + 25))
                    patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                    patch_label.Centre(wx.HORIZONTAL)

                    patch_label = wx.StaticText(frame, label=patch_text, pos=(available_label.GetPosition().x - 10, patch_label.GetPosition().y + 20))
                    patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
                    patch_label.Centre(wx.HORIZONTAL)


        # Button: Start Root Patching
        start_button = wx.Button(frame, label="Start Root Patching", pos=(10, patch_label.GetPosition().y + 25), size=(170, 30))
        start_button.Bind(wx.EVT_BUTTON, lambda event: self.on_start_root_patching(patches))
        start_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        start_button.Centre(wx.HORIZONTAL)

        # Button: Revert Root Patches
        revert_button = wx.Button(frame, label="Revert Root Patches", pos=(10, start_button.GetPosition().y + start_button.GetSize().height - 5), size=(170, 30))
        revert_button.Bind(wx.EVT_BUTTON, lambda event: self.on_revert_root_patching(patches))
        revert_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        revert_button.Centre(wx.HORIZONTAL)

        # Button: Return to Main Menu
        return_button = wx.Button(frame, label="Return to Main Menu", pos=(10, revert_button.GetPosition().y + revert_button.GetSize().height), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return_dismiss if self.init_with_parent else self.on_return_to_main_menu)
        return_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        return_button.Centre(wx.HORIZONTAL)
        self.return_button = return_button

        # Disable buttons if unsupported
        if not patches:
            start_button.Disable()
        else:
            self.available_patches = True
            if patches[HardwarePatchsetValidation.PATCHING_NOT_POSSIBLE] is True:
                start_button.Disable()
            elif no_new_patches is False:
                start_button.SetDefault()
            else:
                self.available_patches = False
        if can_unpatch is False:
            revert_button.Disable()

        # Set frame size
        frame.SetSize((-1, return_button.GetPosition().y + return_button.GetSize().height + 15))
        frame.ShowWindowModal()


    def on_start_root_patching(self, patches: dict):
        frame = gui_sys_patch_start.SysPatchStartFrame(
            parent=None,
            title=self.title,
            global_constants=self.constants,
            patches=patches,
        )
        self.frame_modal.Hide()
        self.frame_modal.Destroy()
        self.frame.Hide()
        self.frame.Destroy()
        frame.start_root_patching()


    def on_revert_root_patching(self, patches: dict):
        frame = gui_sys_patch_start.SysPatchStartFrame(
            parent=None,
            title=self.title,
            global_constants=self.constants,
            patches=patches,
        )
        self.frame_modal.Hide()
        self.frame_modal.Destroy()
        self.frame.Hide()
        self.frame.Destroy()
        frame.revert_root_patching()


    def on_return_to_main_menu(self, event: wx.Event = None):
        # Get frame from event
        frame_modal: wx.Dialog = event.GetEventObject().GetParent()
        frame: wx.Frame = frame_modal.Parent
        frame_modal.Hide()
        frame.Hide()

        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
        )
        main_menu_frame.Show()
        frame.Destroy()


    def on_return_dismiss(self, event: wx.Event = None):
        self.frame_modal.Hide()
        self.frame_modal.Destroy()


    def _check_if_new_patches_needed(self, patches: dict) -> bool:
        """
        Checks if any new patches are needed for the user to install
        Newer users will assume the root patch menu will present missing patches.
        Thus we'll need to see if the exact same OCLP build was used already
        """

        logging.info("Checking if new patches are needed")

        if self.constants.commit_info[0] in ["Running from source", "Built from source"]:
            return True

        if self.constants.computer.oclp_sys_url != self.constants.commit_info[2]:
            # If commits are different, assume patches are as well
            return True

        oclp_plist = "/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist"
        if not Path(oclp_plist).exists():
            # If it doesn't exist, no patches were ever installed
            # ie. all patches applicable
            return True

        oclp_plist_data = plistlib.load(open(oclp_plist, "rb"))
        for patch in patches:
            if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                # Patches should share the same name as the plist key
                # See sys_patch/patchsets/base.py for more info
                if patch.split(": ")[1] not in oclp_plist_data:
                    logging.info(f"- Patch {patch} not installed")
                    return True

        logging.info("No new patches detected for system")
        return False

#gui_sys_patch_start.py
"""
gui_sys_patch_start.py: Root Patching Frame
"""

import wx
import sys
import time
import logging
import plistlib
import traceback
import threading
import subprocess

from pathlib import Path

from .. import constants

from ..datasets import os_data

from ..support import (
    kdk_handler,
    metallib_handler
)
from ..sys_patch import (
    sys_patch,
)
from ..wx_gui import (
    gui_main_menu,
    gui_support,
    gui_download,
)

from ..sys_patch.patchsets import HardwarePatchsetDetection, HardwarePatchsetSettings



class SysPatchStartFrame(wx.Frame):
    """
    Create a frame for root patching
    Uses a Modal Dialog for smoother transition from other frames
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: tuple = None, patches: dict = {}):
        logging.info("Initializing Root Patching Frame")

        self.title = title
        self.constants: constants.Constants = global_constants
        self.frame_modal: wx.Dialog = None
        self.return_button: wx.Button = None
        self.available_patches: bool = False
        self.patches: dict = patches

        super(SysPatchStartFrame, self).__init__(parent, title=title, size=(350, 200), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
        gui_support.GenerateMenubar(self, self.constants).generate()
        self.Centre()

        if self.patches == {}:
            self.patches = HardwarePatchsetDetection(constants=self.constants).device_properties


    def _kdk_download(self, frame: wx.Frame = None) -> bool:
        frame = self if not frame else frame

        logging.info("KDK missing, generating KDK download frame")

        header = wx.StaticText(frame, label="Downloading Kernel Debug Kit", pos=(-1,5))
        header.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        header.Centre(wx.HORIZONTAL)

        subheader = wx.StaticText(frame, label="Fetching KDK database...", pos=(-1, header.GetPosition()[1] + header.GetSize()[1] + 5))
        subheader.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        subheader.Centre(wx.HORIZONTAL)

        progress_bar = wx.Gauge(frame, range=100, pos=(-1, subheader.GetPosition()[1] + subheader.GetSize()[1] + 5), size=(250, 20))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set size of frame
        frame.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 35))
        frame.Show()

        # Generate KDK object
        self.kdk_obj: kdk_handler.KernelDebugKitObject = None
        def _kdk_thread_spawn():
            self.kdk_obj = kdk_handler.KernelDebugKitObject(self.constants, self.constants.detected_os_build, self.constants.detected_os_version)

        kdk_thread = threading.Thread(target=_kdk_thread_spawn)
        kdk_thread.start()

        gui_support.wait_for_thread(kdk_thread)

        if self.kdk_obj.success is False:
            progress_bar_animation.stop_pulse()
            progress_bar.SetValue(0)
            wx.MessageBox(f"KDK download failed: {self.kdk_obj.error_msg}", "Error", wx.OK | wx.ICON_ERROR)
            return False

        kdk_download_obj = self.kdk_obj.retrieve_download()
        if not kdk_download_obj:
            # KDK is already downloaded
            return True

        gui_download.DownloadFrame(
            self,
            title=self.title,
            global_constants=self.constants,
            download_obj=kdk_download_obj,
            item_name=f"KDK Build {self.kdk_obj.kdk_url_build}"
        )
        if kdk_download_obj.download_complete is False:
            return False

        logging.info("KDK download complete, validating with hdiutil")
        header.SetLabel(f"Validating KDK: {self.kdk_obj.kdk_url_build}")
        header.Centre(wx.HORIZONTAL)

        subheader.SetLabel("Checking if checksum is valid...")
        subheader.Centre(wx.HORIZONTAL)
        wx.Yield()

        progress_bar_animation.stop_pulse()

        if self.kdk_obj.validate_kdk_checksum() is False:
            progress_bar.SetValue(0)
            logging.error("KDK checksum validation failed")
            logging.error(self.kdk_obj.error_msg)
            msg = wx.MessageDialog(frame, f"KDK checksum validation failed: {self.kdk_obj.error_msg}", "Error", wx.OK | wx.ICON_ERROR)
            msg.ShowModal()
            return False

        progress_bar.SetValue(100)

        logging.info("KDK download complete")

        for child in frame.GetChildren():
            child.Destroy()

        return True


    def _metallib_download(self, frame: wx.Frame = None) -> bool:
        frame = self if not frame else frame

        logging.info("MetallibSupportPkg missing, generating Metallib download frame")

        header = wx.StaticText(frame, label="Downloading Metal Libraries", pos=(-1,5))
        header.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        header.Centre(wx.HORIZONTAL)

        subheader = wx.StaticText(frame, label="Fetching MetallibSupportPkg database...", pos=(-1, header.GetPosition()[1] + header.GetSize()[1] + 5))
        subheader.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        subheader.Centre(wx.HORIZONTAL)

        progress_bar = wx.Gauge(frame, range=100, pos=(-1, subheader.GetPosition()[1] + subheader.GetSize()[1] + 5), size=(250, 20))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        # Set size of frame
        frame.SetSize((-1, progress_bar.GetPosition()[1] + progress_bar.GetSize()[1] + 35))
        frame.Show()

        self.metallib_obj: metallib_handler.MetalLibraryObject = None
        def _metallib_thread_spawn():
            self.metallib_obj = metallib_handler.MetalLibraryObject(self.constants, self.constants.detected_os_build, self.constants.detected_os_version)

        metallib_thread = threading.Thread(target=_metallib_thread_spawn)
        metallib_thread.start()

        gui_support.wait_for_thread(metallib_thread)

        if self.metallib_obj.success is False:
            progress_bar_animation.stop_pulse()
            progress_bar.SetValue(0)
            wx.MessageBox(f"Metallib download failed: {self.metallib_obj.error_msg}", "Error", wx.OK | wx.ICON_ERROR)
            return False

        self.metallib_download_obj = self.metallib_obj.retrieve_download()
        if not self.metallib_download_obj:
            # Metallib is already downloaded
            return True

        gui_download.DownloadFrame(
            self,
            title=self.title,
            global_constants=self.constants,
            download_obj=self.metallib_download_obj,
            item_name=f"Metallib Build {self.metallib_obj.metallib_url_build}"
        )
        if self.metallib_download_obj.download_complete is False:
            return False

        logging.info("Metallib download complete, installing Metallib PKG")

        header.SetLabel(f"Installing Metallib: {self.metallib_obj.metallib_url_build}")
        header.Centre(wx.HORIZONTAL)

        subheader.SetLabel("Installing MetallibSupportPkg PKG...")
        subheader.Centre(wx.HORIZONTAL)

        self.result = False
        def _install_metallib():
            self.result = self.metallib_obj.install_metallib()

        install_thread = threading.Thread(target=_install_metallib)
        install_thread.start()

        gui_support.wait_for_thread(install_thread)

        if self.result is False:
            progress_bar_animation.stop_pulse()
            progress_bar.SetValue(0)
            wx.MessageBox(f"Metallib installation failed: {self.metallib_obj.error_msg}", "Error", wx.OK | wx.ICON_ERROR)
            return False

        progress_bar_animation.stop_pulse()
        progress_bar.SetValue(100)

        logging.info("Metallib installation complete")

        for child in frame.GetChildren():
            child.Destroy()

        return True


    def _generate_modal(self, patches: dict = {}, variant: str = "Root Patching"):
        """
        Create UI for root patching/unpatching
        """
        supported_variants = ["Root Patching", "Revert Root Patches"]
        if variant not in supported_variants:
            logging.error(f"Unsupported variant: {variant}")
            return

        self.frame_modal.Close() if self.frame_modal else None

        dialog = wx.Dialog(self, title=self.title, size=(400, 200))

        # Title
        title = wx.StaticText(dialog, label=variant, pos=(-1, 10))
        title.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title.Centre(wx.HORIZONTAL)

        if variant == "Root Patching":
            # Label
            label = wx.StaticText(dialog, label="Root Patching will patch the following:", pos=(-1, title.GetPosition()[1] + 30))
            label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            label.Centre(wx.HORIZONTAL)


            # Get longest patch label, then create anchor for patch labels
            longest_patch = ""
            for patch in patches:
                if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                    if len(patch) > len(longest_patch):
                        longest_patch = patch

            anchor = wx.StaticText(dialog, label=longest_patch, pos=(label.GetPosition()[0], label.GetPosition()[1] + 20))
            anchor.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            anchor.Centre(wx.HORIZONTAL)
            anchor.Hide()

            # Labels
            i = 0
            logging.info("Available patches:")
            for patch in patches:
                if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                    logging.info(f"- {patch}")
                    patch_label = wx.StaticText(dialog, label=f"- {patch}", pos=(anchor.GetPosition()[0], label.GetPosition()[1] + 20 + i))
                    patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                    i = i + 20

            if i == 20:
                patch_label.SetLabel(patch_label.GetLabel().replace("-", ""))
                patch_label.Centre(wx.HORIZONTAL)

            elif i == 0:
                patch_label = wx.StaticText(dialog, label="No patches to apply", pos=(label.GetPosition()[0], label.GetPosition()[1] + 20))
                patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
                patch_label.Centre(wx.HORIZONTAL)
        else:
            patch_label = wx.StaticText(dialog, label="Reverting to last sealed snapshot", pos=(-1, title.GetPosition()[1] + 30))
            patch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
            patch_label.Centre(wx.HORIZONTAL)


        # Text box
        text_box = wx.TextCtrl(dialog, pos=(10, patch_label.GetPosition()[1] + 30), size=(380, 400), style=wx.TE_READONLY | wx.TE_MULTILINE | wx.TE_RICH2)
        text_box.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        text_box.Centre(wx.HORIZONTAL)
        self.text_box = text_box

        # Button: Return to Main Menu
        return_button = wx.Button(dialog, label="Return to Main Menu", pos=(10, text_box.GetPosition()[1] + text_box.GetSize()[1] + 5), size=(150, 30))
        return_button.Bind(wx.EVT_BUTTON, self.on_return_to_main_menu)
        return_button.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        return_button.Centre(wx.HORIZONTAL)
        self.return_button = return_button

        # Set frame size
        dialog.SetSize((-1, return_button.GetPosition().y + return_button.GetSize().height + 33))
        self.frame_modal = dialog
        dialog.ShowWindowModal()


    def start_root_patching(self):
        logging.info("Starting root patching")

        while gui_support.PayloadMount(self.constants, self).is_unpack_finished() is False:
            wx.Yield()
            time.sleep(self.constants.thread_sleep_interval)

        if self.patches[HardwarePatchsetSettings.KERNEL_DEBUG_KIT_REQUIRED] is True:
            if self._kdk_download(self) is False:
                sys.exit(1)

        if self.patches[HardwarePatchsetSettings.METALLIB_SUPPORT_PKG_REQUIRED] is True:
            if self._metallib_download(self) is False:
                sys.exit(1)

        self._generate_modal(self.patches, "Root Patching")
        self.return_button.Disable()

        thread = threading.Thread(target=self._start_root_patching, args=(self.patches,))
        thread.start()

        gui_support.wait_for_thread(thread)

        self._post_patch()
        self.return_button.Enable()


    def _start_root_patching(self, patches: dict):
        logger = logging.getLogger()
        logger.addHandler(gui_support.ThreadHandler(self.text_box))
        try:
            sys_patch.PatchSysVolume(self.constants.computer.real_model, self.constants, patches).start_patch()
        except:
            logging.error("An internal error occurred while running the Root Patcher:\n")
            logging.error(traceback.format_exc())
        logger.removeHandler(logger.handlers[2])


    def revert_root_patching(self):
        logging.info("Reverting root patches")

        self._generate_modal(self.patches, "Revert Root Patches")
        self.return_button.Disable()

        thread = threading.Thread(target=self._revert_root_patching, args=(self.patches,))
        thread.start()

        gui_support.wait_for_thread(thread)

        self._post_patch()
        self.return_button.Enable()


    def _revert_root_patching(self, patches: dict):
        logger = logging.getLogger()
        logger.addHandler(gui_support.ThreadHandler(self.text_box))
        try:
            sys_patch.PatchSysVolume(self.constants.computer.real_model, self.constants, patches).start_unpatch()
        except:
            logging.error("An internal error occurred while running the Root Patcher:\n")
            logging.error(traceback.format_exc())
        logger.removeHandler(logger.handlers[2])


    def on_return_to_main_menu(self, event: wx.Event = None):
        # Get frame from event
        frame_modal: wx.Dialog = event.GetEventObject().GetParent()
        frame: wx.Frame = frame_modal.Parent
        frame_modal.Hide()
        frame.Hide()

        main_menu_frame = gui_main_menu.MainFrame(
            None,
            title=self.title,
            global_constants=self.constants,
        )
        main_menu_frame.Show()
        frame.Destroy()


    def on_return_dismiss(self, event: wx.Event = None):
        self.frame_modal.Hide()
        self.frame_modal.Destroy()


    def _post_patch(self):
        if self.constants.root_patcher_succeeded is False:
            return

        if self.constants.needs_to_open_preferences is False:
            gui_support.RestartHost(self.frame_modal).restart(message="Root Patcher finished successfully!\n\nWould you like to reboot now?")
            return

        if self.constants.detected_os >= os_data.os_data.ventura:
            gui_support.RestartHost(self.frame_modal).restart(message="Root Patcher finished successfully!\nIf you were prompted to open System Settings to authorize new kexts, this can be ignored. Your system is ready once restarted.\n\nWould you like to reboot now?")
            return

        # Create dialog box to open System Preferences -> Security and Privacy
        self.popup = wx.MessageDialog(
            self.frame_modal,
            "We just finished installing the patches to your Root Volume!\n\nHowever, Apple requires users to manually approve the kernel extensions installed before they can be used next reboot.\n\nWould you like to open System Preferences?",
            "Open System Preferences?",
            wx.YES_NO | wx.ICON_INFORMATION
        )
        self.popup.SetYesNoLabels("Open System Preferences", "Ignore")
        answer = self.popup.ShowModal()
        if answer == wx.ID_YES:
            output =subprocess.run(
                [
                    "/usr/bin/osascript", "-e",
                    'tell app "System Preferences" to activate',
                    "-e", 'tell app "System Preferences" to reveal anchor "General" of pane id "com.apple.preference.security"',
                ],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            if output.returncode != 0:
                # Some form of fallback if unaccelerated state errors out
                subprocess.run(["/usr/bin/open", "-a", "System Preferences"])
            time.sleep(5)
            sys.exit(0)


    def _check_if_new_patches_needed(self, patches: dict) -> bool:
        """
        Checks if any new patches are needed for the user to install
        Newer users will assume the root patch menu will present missing patches.
        Thus we'll need to see if the exact same OCLP build was used already
        """

        logging.info("Checking if new patches are needed")

        if self.constants.commit_info[0] in ["Running from source", "Built from source"]:
            return True

        if self.constants.computer.oclp_sys_url != self.constants.commit_info[2]:
            # If commits are different, assume patches are as well
            return True

        oclp_plist = "/System/Library/CoreServices/OpenCore-Legacy-Patcher.plist"
        if not Path(oclp_plist).exists():
            # If it doesn't exist, no patches were ever installed
            # ie. all patches applicable
            return True

        oclp_plist_data = plistlib.load(open(oclp_plist, "rb"))
        for patch in patches:
            if (not patch.startswith("Settings") and not patch.startswith("Validation") and patches[patch] is True):
                # Patches should share the same name as the plist key
                # See sys_patch/patchsets/base.py for more info
                if patch.split(": ")[1] not in oclp_plist_data:
                    logging.info(f"- Patch {patch} not installed")
                    return True

        logging.info("No new patches detected for system")
        return False

#gui_update.py
"""
gui_update.py: Generate UI for updating the patcher
"""

import wx
import sys
import time
import logging
import threading
import subprocess

from pathlib import Path

from .. import constants

from ..wx_gui import (
    gui_download,
    gui_support
)
from ..support import (
    network_handler,
    updates,
    subprocess_wrapper
)


class UpdateFrame(wx.Frame):
    """
    Create a frame for updating the patcher
    """
    def __init__(self, parent: wx.Frame, title: str, global_constants: constants.Constants, screen_location: wx.Point, url: str = "", version_label: str = "") -> None:
        logging.info("Initializing Update Frame")
        if parent:
            self.parent: wx.Frame = parent

            for child in self.parent.GetChildren():
                child.Hide()
            parent.Hide()
        else:
            super(UpdateFrame, self).__init__(parent, title=title, size=(350, 300), style=wx.DEFAULT_FRAME_STYLE & ~(wx.RESIZE_BORDER | wx.MAXIMIZE_BOX))
            gui_support.GenerateMenubar(self, global_constants).generate()

        self.title: str = title
        self.constants: constants.Constants = global_constants
        self.pkg_download_path = self.constants.payload_path / "OpenCore-Patcher.pkg"
        self.screen_location: wx.Point = screen_location
        if parent:
            self.parent.Centre()
            self.screen_location = parent.GetScreenPosition()
        else:
            self.Centre()
            self.screen_location = self.GetScreenPosition()


        if url == "" or version_label == "":
            dict = updates.CheckBinaryUpdates(self.constants).check_binary_updates()
            if dict:
                version_label = dict["Version"]
                url = dict["Link"]
            else:
                wx.MessageBox("Failed to get update info", "Critical Error")
                sys.exit(1)

        self.version_label = version_label
        self.url = url

        logging.info(f"Update URL: {url}")
        logging.info(f"Update Version: {version_label}")

        self.frame: wx.Frame = wx.Frame(
            parent=parent if parent else self,
            title=self.title,
            size=(350, 130),
            pos=self.screen_location,
            style=wx.DEFAULT_FRAME_STYLE ^ wx.RESIZE_BORDER ^ wx.MAXIMIZE_BOX
        )

        # Title: Preparing update
        title_label = wx.StaticText(self.frame, label="Preparing download...", pos=(-1,1))
        title_label.SetFont(gui_support.font_factory(19, wx.FONTWEIGHT_BOLD))
        title_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar = wx.Gauge(self.frame, range=100, pos=(10, 50), size=(300, 20))
        progress_bar.Centre(wx.HORIZONTAL)

        progress_bar_animation = gui_support.GaugePulseCallback(self.constants, progress_bar)
        progress_bar_animation.start_pulse()

        self.progress_bar = progress_bar
        self.progress_bar_animation = progress_bar_animation

        self.frame.Centre()
        self.frame.Show()
        wx.Yield()

        download_obj = None
        def _fetch_update() -> None:
            nonlocal download_obj
            file_name = "OpenCore-Patcher.pkg.zip" if url.endswith(".zip") else "OpenCore-Patcher.pkg"
            download_obj = network_handler.DownloadObject(url, self.constants.payload_path / file_name)

        thread = threading.Thread(target=_fetch_update)
        thread.start()
        gui_support.wait_for_thread(thread)

        gui_download.DownloadFrame(
            self.frame,
            title=self.title,
            global_constants=self.constants,
            download_obj=download_obj,
            item_name=f"OpenCore Patcher {version_label}",
            download_icon=str(self.constants.app_icon_path)
        )

        if download_obj.download_complete is False:
            progress_bar_animation.stop_pulse()
            progress_bar.SetValue(0)
            wx.MessageBox("Failed to download update. If you continue to have this issue, please manually download OpenCore Legacy Patcher off Github", "Critical Error!", wx.OK | wx.ICON_ERROR)
            sys.exit(1)

        # Title: Extracting update
        title_label.SetLabel("Extracting update...")
        title_label.Centre(wx.HORIZONTAL)
        wx.Yield()

        thread = threading.Thread(target=self._extract_update)
        thread.start()

        gui_support.wait_for_thread(thread)

        # Title: Installing update
        title_label.SetLabel("Installing update...")
        title_label.Centre(wx.HORIZONTAL)

        thread = threading.Thread(target=self._install_update)
        thread.start()

        gui_support.wait_for_thread(thread)

        # Title: Update complete
        title_label.SetLabel("Update complete!")
        title_label.Centre(wx.HORIZONTAL)

        # Progress bar
        progress_bar.Hide()
        progress_bar_animation.stop_pulse()

        # Label: 0.6.6 has been installed to:
        installed_label = wx.StaticText(self.frame, label=f"{version_label} has been installed:", pos=(-1, progress_bar.GetPosition().y - 15))
        installed_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_BOLD))
        installed_label.Centre(wx.HORIZONTAL)

        # Label: '/Library/Application Support/Dortania'
        installed_path_label = wx.StaticText(self.frame, label='/Library/Application Support/Dortania', pos=(-1, installed_label.GetPosition().y + 20))
        installed_path_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        installed_path_label.Centre(wx.HORIZONTAL)

        # Label: Launching update shortly...
        launch_label = wx.StaticText(self.frame, label="Launching update shortly...", pos=(-1, installed_path_label.GetPosition().y + 30))
        launch_label.SetFont(gui_support.font_factory(13, wx.FONTWEIGHT_NORMAL))
        launch_label.Centre(wx.HORIZONTAL)

        # Adjust frame size
        self.frame.SetSize((-1, launch_label.GetPosition().y + 60))

        thread = threading.Thread(target=self._launch_update)
        thread.start()

        gui_support.wait_for_thread(thread)

        timer = 5
        while True:
            launch_label.SetLabel(f"Closing old process in {timer} seconds")
            launch_label.Centre(wx.HORIZONTAL)
            wx.Yield()
            time.sleep(1)
            timer -= 1
            if timer == 0:
                break

        sys.exit(0)


    def _extract_update(self) -> None:
        """
        Extracts the update

        Logic:
        - Distributed through GitHub Actions: Requires extraction
        - Distributed through GitHub Releases: No extraction required
        """
        # GitHub Release
        if not self.url.endswith(".zip"):
            return

        logging.info("Extracting nightly update")
        if Path(self.pkg_download_path).exists():
            subprocess.run(["/bin/rm", "-rf", str(self.pkg_download_path)])

        result = subprocess.run(
            ["/usr/bin/ditto", "-xk", str(self.constants.payload_path / "OpenCore-Patcher.pkg.zip"), str(self.constants.payload_path)], capture_output=True
        )
        if result.returncode != 0:
            logging.error(f"Failed to extract update.")
            subprocess_wrapper.log(result)
            wx.CallAfter(self.progress_bar_animation.stop_pulse)
            wx.CallAfter(self.progress_bar.SetValue, 0)
            wx.CallAfter(wx.MessageBox, f"Failed to extract update. Error: {result.stderr.decode('utf-8')}", "Critical Error!", wx.OK | wx.ICON_ERROR)
            wx.CallAfter(sys.exit, 1)


    def _install_update(self) -> None:
        """
        Install PKG
        """
        logging.info(f"Installing update: {self.pkg_download_path}")
        result = subprocess_wrapper.run_as_root(["/usr/sbin/installer", "-pkg", str(self.pkg_download_path), "-target", "/"], capture_output=True)
        if result.returncode != 0:
            wx.CallAfter(self.progress_bar_animation.stop_pulse)
            wx.CallAfter(self.progress_bar.SetValue, 0)
            if "User cancelled" in result.stderr.decode("utf-8"):
                logging.info("User cancelled update")
                wx.CallAfter(wx.MessageBox, "User cancelled update", "Update Cancelled", wx.OK | wx.ICON_INFORMATION)
            else:
                logging.critical("Failed to install update.")
                subprocess_wrapper.log(result)

                # If it fails, fall back to opening the PKG
                logging.error("Failed to install update, attempting to open PKG")
                subprocess.run(["/usr/bin/open", str(self.pkg_download_path)])

                wx.CallAfter(wx.MessageBox, f"Failed to install update. Please try installing the OpenCore-Patcher.pkg manually or download from GitHub", "Critical Error!", wx.OK | wx.ICON_ERROR)
            wx.CallAfter(sys.exit, 1)


    def _launch_update(self) -> None:
        """
        Launches newly installed update
        """
        logging.info("Launching update: '/Library/Application Support/Dortania/OpenCore-Patcher.app'")
        subprocess.Popen(["/Library/Application Support/Dortania/OpenCore-Patcher.app/Contents/MacOS/OpenCore-Patcher", "--update_installed"])


#OpenCore-Patcher-GUI.command:
#!/usr/bin/env python3
"""
PyInstaller Entry Point
"""

from opencore_legacy_patcher import main

if __name__ == '__main__':
    main()

#OpenCore-Patcher-GUI.spec
# -*- mode: python ; coding: utf-8 -*-

import os
import sys
import time
import subprocess

from pathlib import Path

from PyInstaller.building.api import PYZ, EXE, COLLECT
from PyInstaller.building.osx import BUNDLE
from PyInstaller.building.build_main import Analysis

sys.path.append(os.path.abspath(os.getcwd()))

from opencore_legacy_patcher import constants

block_cipher = None

datas = [
   ('payloads.dmg', '.'),
   ('Universal-Binaries.dmg', '.'),
]

if Path("DortaniaInternalResources.dmg").exists():
   datas.append(('DortaniaInternalResources.dmg', '.'))


a = Analysis(['OpenCore-Patcher-GUI.command'],
             pathex=[],
             binaries=[],
             datas=datas,
             hiddenimports=[],
             hookspath=[],
             hooksconfig={},
             runtime_hooks=[],
             excludes=[],
             win_no_prefer_redirects=False,
             win_private_assemblies=False,
             cipher=block_cipher,
             noarchive=False)

pyz = PYZ(a.pure,
          a.zipped_data,
          cipher=block_cipher)

exe = EXE(pyz,
          a.scripts,
          [],
          exclude_binaries=True,
          name='OpenCore-Patcher',
          debug=False,
          bootloader_ignore_signals=False,
          strip=False,
          upx=True,
          console=False,
          disable_windowed_traceback=False,
          target_arch="universal2",
          codesign_identity=None,
          entitlements_file=None)

coll = COLLECT(exe,
               a.binaries,
               a.zipfiles,
               a.datas,
               strip=False,
               upx=True,
               upx_exclude=[],
               name='OpenCore-Patcher')

app = BUNDLE(coll,
             name='OpenCore-Patcher.app',
             icon="payloads/Icon/AppIcons/OC-Patcher.icns",
             bundle_identifier="com.dortania.opencore-legacy-patcher",
             info_plist={
                "CFBundleName": "OpenCore Legacy Patcher",
                "CFBundleVersion": constants.Constants().patcher_version,
                "CFBundleShortVersionString": constants.Constants().patcher_version,
                "NSHumanReadableCopyright": constants.Constants().copyright_date,
                "LSMinimumSystemVersion": "10.10.0",
                "NSRequiresAquaSystemAppearance": False,
                "NSHighResolutionCapable": True,
                "Build Date": time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()),
                "BuildMachineOSBuild": subprocess.run(["/usr/bin/sw_vers", "-buildVersion"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode().strip(),
                "NSPrincipalClass": "NSApplication",
             })


#requirements.txt
requests
pyobjc
wxpython
pyinstaller
packaging
py_sip_xnu
py-applescript
markdown2
macos-pkg-builder
mac-signing-buddy

#Build-Project.command
#!/usr/bin/env python3
"""
Build-Project.command: Generate OpenCore-Patcher.app and OpenCore-Patcher.pkg
"""

import os
import sys
import time
import argparse

from pathlib import Path

from ci_tooling.build_modules import (
    application,
    disk_images,
    package,
    sign_notarize
)


def main() -> None:
    """
    Parse Command Line Arguments
    """

    parser = argparse.ArgumentParser(description="Build OpenCore Legacy Patcher Suite", add_help=False)

    # Signing Parameters
    parser.add_argument("--application-signing-identity", type=str, help="Application Signing Identity")
    parser.add_argument("--installer-signing-identity", type=str, help="Installer Signing Identity")


    # Notarization Parameters
    parser.add_argument("--notarization-apple-id", type=str, help="Notarization Apple ID", default=None)
    parser.add_argument("--notarization-password", type=str, help="Notarization Password", default=None)
    parser.add_argument("--notarization-team-id", type=str, help="Notarization Team ID", default=None)

    # GitHub Actions CI/CD Parameters
    parser.add_argument("--git-branch", type=str, help="Git Branch", default=None)
    parser.add_argument("--git-commit-url", type=str, help="Git Commit URL", default=None)
    parser.add_argument("--git-commit-date", type=str, help="Git Commit Date", default=None)

    # Local Build Parameters
    parser.add_argument("--reset-dmg-cache", action="store_true", help="Redownload PatcherSupportPkg.dmg and regenerate payloads.dmg", default=False)
    parser.add_argument("--reset-pyinstaller-cache", action="store_true", help="Clean PyInstaller Cache", default=False)

    # CI/CD Parameters for individual steps
    # If not specified, will run all steps
    parser.add_argument("--run-as-individual-steps", action="store_true", help="CI: Run as individual steps", default=False)
    parser.add_argument("--prepare-application", action="store_true", help="CI: Prepare Application", default=False)
    parser.add_argument("--prepare-package", action="store_true", help="CI: Prepare Package", default=False)
    parser.add_argument("--prepare-assets", action="store_true", help="CI: Prepare Assets", default=False)

    # Analytics Parameters
    parser.add_argument("--analytics-key", type=str, help="Analytics Key", default=None)
    parser.add_argument("--analytics-endpoint", type=str, help="Analytics Endpoint", default=None)

    # Help
    parser.add_argument("--help", action="store_true", help="Show this help message and exit", default=False)

    # Parse Arguments
    args = parser.parse_args()

    if args.help:
        parser.print_help()
        print("\n\nIf running outside of CI/CD, simply run the following command:")
        print("$ python3 Build-Project.command")
        sys.exit(0)

    # Set 'Current Working Directory' to script directory
    os.chdir(Path(__file__).resolve().parent)


    if (args.run_as_individual_steps is False) or (args.run_as_individual_steps and args.prepare_assets):
        # Prepare workspace
        disk_images.GenerateDiskImages(args.reset_dmg_cache).generate()

    if (args.run_as_individual_steps is False) or (args.run_as_individual_steps and args.prepare_application):
        # Prepare Privileged Helper Tool
        sign_notarize.SignAndNotarize(
            path=Path("./ci_tooling/privileged_helper_tool/com.dortania.opencore-legacy-patcher.privileged-helper"),
            signing_identity=args.application_signing_identity,
            notarization_apple_id=args.notarization_apple_id,
            notarization_password=args.notarization_password,
            notarization_team_id=args.notarization_team_id,
        ).sign_and_notarize()

        # Build OpenCore-Patcher.app
        application.GenerateApplication(
            reset_pyinstaller_cache=args.reset_pyinstaller_cache,
            git_branch=args.git_branch,
            git_commit_url=args.git_commit_url,
            git_commit_date=args.git_commit_date,
            analytics_key=args.analytics_key,
            analytics_endpoint=args.analytics_endpoint,
        ).generate()

        # Sign OpenCore-Patcher.app
        sign_notarize.SignAndNotarize(
            path=Path("dist/OpenCore-Patcher.app"),
            signing_identity=args.application_signing_identity,
            notarization_apple_id=args.notarization_apple_id,
            notarization_password=args.notarization_password,
            notarization_team_id=args.notarization_team_id,
            entitlements=Path("./ci_tooling/entitlements/entitlements.plist"),
        ).sign_and_notarize()


    if (args.run_as_individual_steps is False) or (args.run_as_individual_steps and args.prepare_package):
        # Build OpenCore-Patcher.pkg and OpenCore-Patcher-Uninstaller.pkg
        package.GeneratePackage().generate()

        # Sign OpenCore-Patcher.pkg
        sign_notarize.SignAndNotarize(
            path=Path("dist/OpenCore-Patcher.pkg"),
            signing_identity=args.installer_signing_identity,
            notarization_apple_id=args.notarization_apple_id,
            notarization_password=args.notarization_password,
            notarization_team_id=args.notarization_team_id,
        ).sign_and_notarize()

        # Sign OpenCore-Patcher-Uninstaller.pkg
        sign_notarize.SignAndNotarize(
            path=Path("dist/OpenCore-Patcher-Uninstaller.pkg"),
            signing_identity=args.installer_signing_identity,
            notarization_apple_id=args.notarization_apple_id,
            notarization_password=args.notarization_password,
            notarization_team_id=args.notarization_team_id,
        ).sign_and_notarize()


if __name__ == '__main__':
    _start = time.time()
    main()
    print(f"Build script completed in {str(round(time.time() - _start, 2))} seconds")

#SOURCE.md
# Build and run from source

OpenCore Legacy Patcher at its core is a Python-based GUI/CLI-based application. In turn, to run the project from source, you simply need to invoke the OpenCore-Patcher-GUI.command file via Python.

For developers wishing to validate mainline changes, you may use this link: [GUI (Graphical Based App)](https://nightly.link/dortania/OpenCore-Legacy-Patcher/workflows/build-app-wxpython/main/OpenCore-Patcher.pkg.zip)

* **Warning**: Nightly builds (untagged builds built from the latest commit) are actively developed OpenCore Legacy Patcher builds. These builds have not been tested, are not guaranteed to work, and are not guaranteed to be safe. Do not use nightlies without a good reason to do so, and do not use them on your main machine. Additionally, these binaries should not be used without first consulting the [CHANGELOG](./CHANGELOG.md).

  **Do not share _any_ links to these binaries** in forums; please link to **this document only**.
  * Additionally, do not reupload these binaries or download binaries from other sites. Using binaries from untrusted sources is a security issue, as they may have been tampered with.
* Users running new builds of the project without understanding what has changed and the implications of installing software under active development are at a higher risk of bricking their installation as they do not read any warnings provided in the CHANGELOG. We wish to minimize these situations as much as possible.

## Getting Started

To start, ensure you have Python 3.6 or newer installed. Additionally, ensure that it was downloaded from the official source, [python.org](https://www.python.org/downloads/macos/).

* Python installations either preinstalled or provided with Xcode or the Xcode Command Line Tools are unsupported due to reliability issues.

Once Python is installed, open Terminal and run the following:

```sh
# Move into a directory to store the project
cd ~/Developer
# Clone project
git clone https://github.com/dortania/OpenCore-Legacy-Patcher
# Move into Project directory
cd ./OpenCore-Legacy-Patcher
# Install Python dependencies used by the project
pip3 install -r requirements.txt
```

If you have any installation errors, see the following troubleshooting options:

* Use Python 3.11
  * Our build server currently uses Python 3.11 for generating binaries used in releases
* Use .whl snapshots for installing additional dependencies

## Running OpenCore Legacy Patcher

To run the project from source, simply invoke via python3:

```sh
# Launch GUI
python3 OpenCore-Patcher-GUI.command
```

Note that the OpenCore-Patcher-GUI.command file can be run as both a GUI and a CLI utility for other programs to call. If no core arguments are passed, the GUI is initialized. Otherwise the CLI will start:

```sh
# Launch CLI
python3 OpenCore-Patcher-GUI.command --build --model iMac12,2 --verbose
```

Pass `-h` or `--help` for more information on supported CLI arguments.

## Generating prebuilt binaries

The main goal of generating prebuilt binaries is to strip the requirement of a local Python installation for users. For developers, there's very little benefit besides enabling dark mode support in the GUI. For development, simply use the OpenCore-Patcher-GUI.command file with a Python 3 installation.

```sh
# Install PyInstaller
pip3 install pyinstaller
# Move into project directory
cd ~/Developer/OpenCore-Legacy-Patcher/
# Create the pyinstaller based Application
python3 Build-Project.command
# Open build folder
open ./dist/
```

Once done, you'll find the application generated at `./dist/OpenCore-Patcher.app`:

![](./images/build-dist.png)


#Please obtain the payloads contents if not already in my GitHub repository you are to work directly with my GitHub repository on this project, now what I need is my app modified to use this gui interface as provided within this document, I want a black theme and the Skyscope Sentinel Intelligence company branding and app name along with Developer: Casey Jay Topojani added to it, ensure to include the advanced options we created and/or append them to the current code within the scripts provided here for you creating an enhanced version of the open core legacy patcher gui application basically but itâs own application in its right, my application. Also note the following items from my system:

#AudioCodecs.txt:
Codecs Detecteds:

Vendor: ONBOARD
Name: Realtek ALC897
Codec: 0x10ec0897

(AppleHDA)	Realtek (Unknown) (10ec:0897) Rev.(00100402)
		Controller 8086:7a50 (sub-ven:1458:a194)


#Bootargs.txt
alcid=12 watchdog=0 agdpmod=pikera e1000=0 npci=0x3000 -wegnoigpu 

#Please ensure to fix to ensure that versions above sequoia have no issues having root patches applied as per normal open core legacy patcher logic , and offer mine as an additional capability 